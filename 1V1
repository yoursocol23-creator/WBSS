
-- Lerp/Tween

local TweenService = {}
local EasingFunctions = {
    Linear = function(t) return t end,
    Sine = {
        In = function(t) return 1 - math.cos((t * math.pi) / 2) end,
        Out = function(t) return math.sin((t * math.pi) / 2) end,
        InOut = function(t) return -(math.cos(math.pi * t) - 1) / 2 end
    },
    Quad = {
        In = function(t) return t * t end,
        Out = function(t) return 1 - (1 - t) * (1 - t) end,
        InOut = function(t) return t < 0.5 and 2 * t * t or 1 - (-2 * t + 2) ^ 2 / 2 end
    },
    Cubic = {
        In = function(t) return t * t * t end,
        Out = function(t) return 1 - (1 - t) ^ 3 end,
        InOut = function(t) return t < 0.5 and 4 * t * t * t or 1 - (-2 * t + 2) ^ 3 / 2 end
    },
    Bounce = {
        Out = function(t)
            local n1 = 7.5625
            local d1 = 2.75
            if t < 1 / d1 then
                return n1 * t * t
            elseif t < 2 / d1 then
                t = t - 1.5 / d1
                return n1 * t * t + 0.75
            elseif t < 2.5 / d1 then
                t = t - 2.25 / d1
                return n1 * t * t + 0.9375
            else
                t = t - 2.625 / d1
                return n1 * t * t + 0.984375
            end
        end
    }
}

local function getEasingFunction(easingStyle, easingDirection)
    if easingStyle == "Linear" then return EasingFunctions.Linear end
    if EasingFunctions[easingStyle] then
        if easingDirection == "In" then return EasingFunctions[easingStyle].In
        elseif easingDirection == "Out" then return EasingFunctions[easingStyle].Out
        else return EasingFunctions[easingStyle].InOut end
    end
    return EasingFunctions.Linear
end

local TweenInfo = {}
TweenInfo.__index = TweenInfo
function TweenInfo.new(time, easingStyle, easingDirection, repeatCount, reverses, delayTime)
    local self = setmetatable({}, TweenInfo)
    self.Time = time or 1
    self.EasingStyle = easingStyle or "Quad"
    self.EasingDirection = easingDirection or "Out"
    self.RepeatCount = repeatCount or 0
    self.Reverses = reverses or false
    self.DelayTime = delayTime or 0
    return self
end

local Tween = {}
Tween.__index = Tween
function Tween.new(instance, tweenInfo, properties)
    local self = setmetatable({}, Tween)
    self.Instance = instance
    self.TweenInfo = (type(tweenInfo) == "table" and getmetatable(tweenInfo) ~= TweenInfo) and TweenInfo.new(tweenInfo.Time, tweenInfo.EasingStyle, tweenInfo.EasingDirection) or tweenInfo
    self.Properties = properties
    self.InitialProperties = {}
    self.IsPlaying = false
    self.Thread = nil

    for prop, targetValue in pairs(properties) do
        local initialValue = instance[prop]
        if type(initialValue) == "userdata" and pcall(function() return initialValue.X end) then
            self.InitialProperties[prop] = {
                type = "Vector3",
                x = initialValue.X,
                y = initialValue.Y,
                z = initialValue.Z
            }
        else
            self.InitialProperties[prop] = initialValue
        end
    end
    return self
end

function Tween:Play()
    if self.IsPlaying then return end
    self.IsPlaying = true
    
    self.Thread = spawn(function()
        local startTime = os.clock()
        local duration = self.TweenInfo.Time
        local easingFunc = getEasingFunction(self.TweenInfo.EasingStyle, self.TweenInfo.EasingDirection)
        local originalGravity = nil
        local humanoid = nil
        pcall(function()
            if self.Instance.Parent then
                local character = self.Instance.Parent
                humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    originalGravity = GetGravity(humanoid)
                    if originalGravity then
                        SetGravity(humanoid, 0)
                    end
                end
            end
        end)
        local originalCanCollide = {}
        pcall(function()
            if self.Instance.Parent then
                for _, part in pairs(self.Instance.Parent:GetDescendants()) do
                    if part:IsA("BasePart") then
                        originalCanCollide[part] = part.CanCollide
                        part.CanCollide = false
                    end
                end
            end
        end)
        
        if self.TweenInfo.DelayTime > 0 then
            wait(self.TweenInfo.DelayTime)
        end
        
        local tweenStart = os.clock()
        
        while self.IsPlaying do
            local elapsed = os.clock() - tweenStart
            local progress = math.min(elapsed / duration, 1)
            local alpha = easingFunc(progress)
            for prop, targetValue in pairs(self.Properties) do
                local initialValue = self.InitialProperties[prop]
                
                if type(initialValue) == "table" and initialValue.type == "Vector3" then
                    local targetX = targetValue.X
                    local targetY = targetValue.Y
                    local targetZ = targetValue.Z
                    
                    local newX = initialValue.x + (targetX - initialValue.x) * alpha
                    local newY = initialValue.y + (targetY - initialValue.y) * alpha
                    local newZ = initialValue.z + (targetZ - initialValue.z) * alpha
                    
                    self.Instance[prop] = Vector3.new(newX, newY, newZ)
                elseif type(initialValue) == "number" then
                    self.Instance[prop] = initialValue + (targetValue - initialValue) * alpha
                end
            end
            pcall(function()
                self.Instance.Velocity = Vector3.new(0, 0, 0)
                self.Instance.RotVelocity = Vector3.new(0, 0, 0)
            end)
            -- this doesn't work future me
            pcall(function()
                if humanoid then
                    SetGravity(humanoid, 0)
                end
            end)
            
            pcall(function()
                if self.Instance.Parent then
                    for _, part in pairs(self.Instance.Parent:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
            
            if progress >= 1 then
                for prop, targetValue in pairs(self.Properties) do
                    self.Instance[prop] = targetValue
                end
                self.IsPlaying = false
                break
            end
            
            wait(0.006) -- 6 or 7 fps
        end
        
        pcall(function()
            for part, canCollide in pairs(originalCanCollide) do
                if part and part.Parent then
                    part.CanCollide = canCollide
                end
            end
        end)
        
        pcall(function()
            if humanoid and originalGravity then
                SetGravity(humanoid, originalGravity)
            end
        end)
    end)
end

function Tween:Stop()
    self.IsPlaying = false
    if self.Thread then
        self.Thread = nil
    end
end

function Tween:Cancel()
    self:Stop()
end

function TweenService:Create(instance, tweenInfo, properties)
    return Tween.new(instance, tweenInfo, properties)
end
-- ============================================================
-- WALKTO SYSTEM
-- ============================================================

local WALKTOPOINT_OFFSET_1 = 0x16C
local DIRECTION_OFFSET = 0x170
local WALKTOPOINT_OFFSET_2 = 0x17C

local WalkToService = {
    isWalking = false,
    currentTarget = nil,
    humanoid = nil,
    character = nil,
    updateThread = nil
}

local function WriteVector3(address, offset, vector3)
    if not address then return false end
    
    local success = pcall(function()
        memory_write("float", address + offset, vector3.X)
        memory_write("float", address + offset + 4, vector3.Y)
        memory_write("float", address + offset + 8, vector3.Z)
    end)
    
    return success
end

local function GetPosition(part)
    local pos = part.Position
    if type(pos) == "userdata" then
        return pos.X or pos.x, pos.Y or pos.y, pos.Z or pos.z
    elseif type(pos) == "table" then
        return pos.X or pos.x, pos.Y or pos.y, pos.Z or pos.z
    end
    return nil, nil, nil
end

function WalkToService.WalkTo(humanoid, targetPosition)
    if not humanoid or not humanoid.Address then
        warn("Invalid humanoid!")
        return false
    end
    
    local character = humanoid.Parent
    if not character then
        warn("No character!")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        warn("No HumanoidRootPart!")
        return false
    end
    
    WalkToService.humanoid = humanoid
    WalkToService.character = character
    WalkToService.currentTarget = targetPosition
    WalkToService.isWalking = true
    
    local posX, posY, posZ = GetPosition(hrp)
    if not posX then
        warn("Can't get position!")
        return false
    end
    
    local dx = targetPosition.X - posX
    local dy = targetPosition.Y - posY
    local dz = targetPosition.Z - posZ
    local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
    
    local direction = Vector3.new(dx / distance, dy / distance, dz / distance)
    
    local humAddress = humanoid.Address
    
    WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, targetPosition)
    WriteVector3(humAddress, DIRECTION_OFFSET, direction)
    WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, targetPosition)
    
    if WalkToService.updateThread then
        WalkToService.updateThread = nil
    end
    
    WalkToService.updateThread = spawn(function()
        local loopCount = 0
        
        while WalkToService.isWalking do
            loopCount = loopCount + 1
            
            if loopCount % 10 == 0 then
            end
            
            local hrp = WalkToService.character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                WalkToService.Stop()
                break
            end
            
            local posX, posY, posZ = GetPosition(hrp)
            if not posX then
                WalkToService.Stop()
                break
            end
            
            local dx = WalkToService.currentTarget.X - posX
            local dy = WalkToService.currentTarget.Y - posY
            local dz = WalkToService.currentTarget.Z - posZ
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if loopCount % 10 == 0 then
            end
            
            if distance < 5 then
                WalkToService.Stop()
                break
            end
            
            local direction = Vector3.new(dx / distance, dy / distance, dz / distance)
            
            WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, WalkToService.currentTarget)
            WriteVector3(humAddress, DIRECTION_OFFSET, direction)
            WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, WalkToService.currentTarget)
            
            wait(0.1)
        end
        
    end)
    
    return true
end

-- ============================================================
-- ANIMATION CONTROL (from unwalk)
-- ============================================================

local animateScript = nil
local animator = nil
local originalAnimateParent = nil
local originalAnimatorParent = nil

local function enableUnwalk()
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then 
        print("character not found")
        return false
    end
    
    print("Disabling animations for smooth tween")
    wait(0.1)
    
    animateScript = character:FindFirstChild("Animate")
    if animateScript then
        originalAnimateParent = animateScript.Parent
        animateScript.Parent = game
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid then
        animator = humanoid:FindFirstChildOfClass("Animator")
        if animator then
            originalAnimatorParent = animator.Parent
            animator.Parent = game
        end
    end
    
    return true
end

local function disableUnwalk()
    print("Re-enabling animations")
    
    if animateScript and originalAnimateParent then
        animateScript.Parent = originalAnimateParent
    end
    
    if animator and originalAnimatorParent then
        animator.Parent = originalAnimatorParent
    end
    
    animateScript = nil
    animator = nil
    originalAnimateParent = nil
    originalAnimatorParent = nil
end

function WalkToService.Stop()
    WalkToService.isWalking = false
    
    if WalkToService.humanoid and WalkToService.humanoid.Address then
        local humAddress = WalkToService.humanoid.Address
        local zero = Vector3.new(0, 0, 0)
        
        WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, zero)
        WriteVector3(humAddress, DIRECTION_OFFSET, zero)
        WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, zero)
    end
    
    WalkToService.currentTarget = nil
    WalkToService.updateThread = nil
end

function WalkTo(targetPosition)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then
        warn("No character!")
        return false
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("No humanoid!")
        return false
    end
    
    return WalkToService.WalkTo(humanoid, targetPosition)
end

function WalkToPart(part)
    if not part or not part.Position then
        warn("Invalid part!")
        return false
    end
    return WalkTo(part.Position)
end

function StopWalking()
    WalkToService.Stop()
end

function IsWalking()
    return WalkToService.isWalking
end

function WaitForArrival(timeout, threshold)
    timeout = timeout or 2
    threshold = threshold or 0.5
    local startTime = os.clock()
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    while IsWalking() do
        if os.clock() - startTime > timeout then
            print("Walk timeout")
            StopWalking()
            return false
        end
        
        if WalkToService.currentTarget then
            local hrpPos = hrp.Position
            local dx = WalkToService.currentTarget.X - hrpPos.X
            local dy = WalkToService.currentTarget.Y - hrpPos.Y
            local dz = WalkToService.currentTarget.Z - hrpPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < threshold then
                StopWalking()
                return true
            end
        end
        
        wait(0.1)
    end
    
    return true
end


local function GetFlowerZones()
    local zones = {}
    local flowerZones = game.Workspace.FlowerZones
    
    if flowerZones then
        for _, zone in pairs(flowerZones:GetChildren()) do
            if not string.find(string.lower(zone.Name), "brick") then
                table.insert(zones, zone.Name)
            end
        end
    end
    
    table.sort(zones)
    
    return zones
end


-- UI

local UI = {
    isRunning = true,
    activeTab = 1,
    dragging = nil,
    lastMousePressed = false,
    needsRedraw = true,
    drawings = {},
    buttons = {},
    statusUpdaterThread = nil,
    autoFarmThread = nil,
    autoDigThread = nil,
    coconutCrabThread = nil,
    tweenQueueThread = nil,
    huntingVicious = false,
    walkedToViciousOnce = false,
    collectingSproutTokens = false,
    
    panel = {
        x = 400,
        y = 200,
        width = 800,
        height = 495,
        sidebarWidth = 140
    },
    
    tabs = {
        {name = "Home", icon = "H"},
        {name = "Farming", icon = "F"},
        {name = "Combat", icon = "C"},
        {name = "Settings", icon = "S"}
    },
    
    status = "Ready",
    
    dropdownOpen = false,
    selectedOption = "Select Field...",
    dropdownScroll = 0,
    combatDropdownOpen = false,
    selectedCombatTarget = "Any Mob",
    autoFarmEnabled = false,
    autoFarmRunning = false,
    tweenSpeed = 50,
    autoDigEnabled = false,
    autoDigRunning = false,
    tweenQueue = {},
    currentTween = nil,
    processingTween = false,
    autoGrindBlooms = false,
    lastCloudTime = 0,
    lastFlameTime = 0,
    trainSnail = false,
    trainSnailRunning = false,
    sprinklersPlaced = false,
    selectedSprinkler = "None (0)",
    pausedForTimedAction = false,
    originalAutoFarmField = nil,
    lastFieldChangeSource = nil,

}

local GRAVITY_OFFSET = 0x1d0
local GRAVITY_CONTAINER_OFFSET = 0x3c8
local PRIMITIVES_POINTER1 = 0x3c8
local PRIMITIVES_POINTER2 = 0x240
local READONLY_GRAVITY_OFFSET = 0x9b0

function SetGravity(humanoid, value)
    if not humanoid or not humanoid.Address then
        return false
    end
    
    local success = pcall(function()
        memory_write("float", humanoid.Address + GRAVITY_OFFSET, value)
        memory_write("float", humanoid.Address + GRAVITY_CONTAINER_OFFSET, value)
        
        local primPtr1 = memory_read("ptr", humanoid.Address + PRIMITIVES_POINTER1)
        if primPtr1 and primPtr1 ~= 0 then
            local primPtr2 = memory_read("ptr", primPtr1 + PRIMITIVES_POINTER2)
            if primPtr2 and primPtr2 ~= 0 then
                memory_write("float", primPtr2, value)
            end
        end
    end)
    
    return success
end

function GetGravity(humanoid)
    if not humanoid or not humanoid.Address then
        return nil
    end
    
    local success, value = pcall(function()
        return memory_read("float", humanoid.Address + GRAVITY_OFFSET)
    end)
    
    return success and value or nil
end

function ResetPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or not humanoid.Address then return false end
    
    print("Resetting player")
    local OFFSET = 0x18C
    local addr = humanoid.Address
    local v = Vector3.new(0, 0, 0)
    memory_write("float", addr + OFFSET + 8, v.Z)
    
    return true
end

function WaitForRespawn(timeout)
    timeout = timeout or 30
    local startTime = os.clock()
    local player = game.Players.LocalPlayer
    while os.clock() - startTime < timeout do
        local character = player.Character
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health <= 0 then
            print("Died")
            break
        end
        
        wait(0.1)
    end

    startTime = os.clock()
    while os.clock() - startTime < timeout do
        local character = player.Character
        if character and character.Parent then
            local humanoid = character:FindFirstChild("Humanoid")
            local hrp = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and hrp and humanoid.Health > 0 then
                return true
            end
        end
    end
    
    print("ERROR: Respawn timeout!")
    return false
end

-- poi--------------------------------------------------

function UI:Track(obj, relX, relY, relX2, relY2)
    table.insert(self.drawings, {
        instance = obj,
        relX = relX,
        relY = relY,
        relX2 = relX2,
        relY2 = relY2,
        isLine = (relX2 ~= nil)
    })
    return obj
end

function UI:Clear()
    for _, d in pairs(self.drawings) do
        pcall(function() d.instance:Remove() end)
    end
    self.drawings = {}
    self.buttons = {}
end

function UI:CreateRect(x, y, w, h, color, transparency)
    local rect = Drawing.new("Square")
    rect.Size = Vector2.new(w, h)
    rect.Color = color
    rect.Filled = true
    rect.Visible = true
    rect.Transparency = transparency or 1
    rect.Position = Vector2.new(self.panel.x + x, self.panel.y + y)
    return self:Track(rect, x, y)
end

function UI:CreateText(text, x, y, color, size, center)
    local txt = Drawing.new("Text")
    txt.Text = text
    txt.Color = color
    txt.Size = size or 14
    txt.Outline = true
    txt.Visible = true
    txt.Center = center or false
    txt.Position = Vector2.new(self.panel.x + x, self.panel.y + y)
    return self:Track(txt, x, y)
end

function UI:CreateLine(x1, y1, x2, y2, color, thickness)
    local line = Drawing.new("Line")
    line.From = Vector2.new(self.panel.x + x1, self.panel.y + y1)
    line.To = Vector2.new(self.panel.x + x2, self.panel.y + y2)
    line.Color = color
    line.Thickness = thickness or 1
    line.Visible = true
    return self:Track(line, x1, y1, x2, y2)
end

function UI:RegisterButton(x, y, w, h, callback)
    table.insert(self.buttons, {
        x = x,
        y = y,
        width = w,
        height = h,
        callback = callback
    })
end

function UI:RenderTitleBar()
    local p = self.panel
    
    -- Title bar background with gradient effect
    self:CreateRect(0, 0, p.width, 50, Color3.fromRGB(25, 28, 35))
    self:CreateRect(0, 48, p.width, 2, Color3.fromRGB(16, 185, 129))
    
    -- Title
    self:CreateText("Windy BSS - test", 20, 15, Color3.fromRGB(255, 255, 255), 18)
    self:CreateText("Bee Swarm Simulator", 20, 32, Color3.fromRGB(150, 160, 175), 11)
    
    -- Status indicator
    local statusX = p.width - 120
    self:CreateRect(statusX, 15, 8, 8, Color3.fromRGB(52, 211, 153))
    self:CreateText("Active", statusX + 15, 13, Color3.fromRGB(200, 210, 220), 12)
    
    -- Close button
    local closeX = p.width - 40
    self:CreateRect(closeX, 12, 28, 28, Color3.fromRGB(239, 68, 68))
    self:CreateText("×", closeX + 8, 13, Color3.fromRGB(255, 255, 255), 20)
    self:RegisterButton(closeX, 12, 28, 28, function() UI:Shutdown() end)
end

function UI:RenderSidebar()
    local p = self.panel
    local sw = p.sidebarWidth
    self:CreateRect(0, 50, sw, p.height - 50, Color3.fromRGB(20, 23, 30))
    self:CreateRect(sw, 50, 1, p.height - 50, Color3.fromRGB(40, 45, 55))
    
    local tabHeight = 45
    local startY = 70
    
    for i, tab in ipairs(self.tabs) do
        local tabY = startY + ((i - 1) * tabHeight)
        local isActive = (i == self.activeTab)
        
        if isActive then
            self:CreateRect(0, tabY, sw, tabHeight, Color3.fromRGB(16, 185, 129))
            -- Active indicator
            self:CreateRect(0, tabY, 4, tabHeight, Color3.fromRGB(6, 150, 100))
        else
            self:CreateRect(0, tabY, sw, tabHeight, Color3.fromRGB(20, 23, 30))
        end
        
        local iconColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(120, 130, 145)
        self:CreateText(tab.icon, 25, tabY + 8, iconColor, 16)
        
        local textColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(150, 160, 175)
        self:CreateText(tab.name, 50, tabY + 15, textColor, 13)
        
        self:RegisterButton(0, tabY, sw, tabHeight, function()
            self.activeTab = i
            self.needsRedraw = true
        end)
        
        if i < #self.tabs then
            local sepColor = isActive and Color3.fromRGB(6, 150, 100) or Color3.fromRGB(30, 35, 45)
            self:CreateRect(15, tabY + tabHeight - 1, sw - 30, 1, sepColor)
        end
    end
end

function UI:RenderMainTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Dashboard", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    self:CreateRect(contentX, contentY, 360, 80, Color3.fromRGB(30, 35, 45))
    self:CreateRect(contentX, contentY, 360, 3, Color3.fromRGB(16, 185, 129))
    
    self:CreateText("Current Status", contentX + 15, contentY + 15, Color3.fromRGB(180, 190, 200), 12)
    self:CreateText(self.status, contentX + 15, contentY + 35, Color3.fromRGB(16, 185, 129), 16)
    
    contentY = contentY + 100
    
    self:CreateRect(contentX, contentY, 170, 45, Color3.fromRGB(16, 185, 129))
    self:CreateText("Start Bot", contentX + 50, contentY + 15, Color3.fromRGB(255, 255, 255), 14)
    self:RegisterButton(contentX, contentY, 170, 45, function()
        self.status = "Bot Running..."
        self.needsRedraw = true
    end)
    
    self:CreateRect(contentX + 190, contentY, 170, 45, Color3.fromRGB(239, 68, 68))
    self:CreateText("Stop Bot", contentX + 240, contentY + 15, Color3.fromRGB(255, 255, 255), 14)
    self:RegisterButton(contentX + 190, contentY, 170, 45, function()
        self.status = "Stopped"
        self.needsRedraw = true
    end)
    
    contentY = contentY + 65
    self:CreateText("Quick Actions", contentX, contentY, Color3.fromRGB(180, 190, 200), 13)
    
    contentY = contentY + 25
    local btnY = contentY
    
    local actions = {
    {text = "Claim Hive", callback = function() self:WalkToHive() end},
    {text = "Find Bubbles", callback = function() self:FindBubbleLocation() end},
    {text = "Collect", callback = function() print("Collect tokens") end}
}
    
    for i, action in ipairs(actions) do
        local btnX = contentX + ((i - 1) * 125)
        self:CreateRect(btnX, btnY, 110, 38, Color3.fromRGB(45, 55, 70))
        self:CreateText(action.text, btnX + 20, btnY + 12, Color3.fromRGB(200, 210, 220), 13)
        self:RegisterButton(btnX, btnY, 110, 38, action.callback)
    end
end

function UI:RenderFarmingTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Farming Settings", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    -- Toggle options
    local toggles = {
        {label = "Auto Farm", key = "autoFarmEnabled"},
        {label = "Auto Dig", key = "autoDigEnabled"},
        {label = "Use Sprinkler", key = "useSprinkler"},
        {label = "Debug", key = "debugMode"}
    }
    
    for i, toggle in ipairs(toggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if toggle.key == "autoFarmEnabled" then
                self.autoFarmEnabled = not self.autoFarmEnabled
                self.needsRedraw = true
                
                if self.autoFarmEnabled then
                    self:StartAutoFarm()
                else
                    self:StopAutoFarm()
                end
            elseif toggle.key == "autoDigEnabled" then
                self.autoDigEnabled = not self.autoDigEnabled
                self.needsRedraw = true
                
                if self.autoDigEnabled then
                    self:StartAutoDig()
                else
                    self:StopAutoDig()
                end
            elseif toggle.key == "useSprinkler" then
                self.useSprinkler = not self.useSprinkler
                self.needsRedraw = true
            end
        end)
    end
    
    local dropdown1X = contentX + 220
    local dropdownY = contentY
    
    self:CreateText("Field Selection", dropdown1X, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    self:CreateText("Last selected: " .. self.selectedOption, dropdown1X, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    self:CreateRect(dropdown1X, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedOption, dropdown1X + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    self:CreateText("v", dropdown1X + 135, dropdownY + 6, Color3.fromRGB(150, 160, 175), 12)
    
    self:RegisterButton(dropdown1X, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.dropdownOpen = not self.dropdownOpen
            self.needsRedraw = true
        end
    end)
    
    local dropdown2X = dropdown1X + 170
    
    self:CreateText("Sprinkler", dropdown2X, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    if not self.secondDropdownOpen then
        self.secondDropdownOpen = false
    end
    if not self.selectedSecondOption then
        self.selectedSecondOption = "None (0)"
    end
    
    self:CreateText("Selected: " .. self.selectedSprinkler, dropdown2X, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)

    self:CreateRect(dropdown2X, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedSprinkler, dropdown2X + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    
    self:RegisterButton(dropdown2X, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.secondDropdownOpen = not self.secondDropdownOpen
            self.needsRedraw = true
        end
    end)
    
    -- Field Abilities Section - RIGHT COLUMN under sprinkler
    local fieldAbilityX = dropdown2X
    local fieldAbilityY = dropdownY + 50
    
    self:CreateText("Dispensers & Misc", fieldAbilityX, fieldAbilityY, Color3.fromRGB(200, 210, 220), 14)
    
    fieldAbilityY = fieldAbilityY + 25
    
    local fieldToggles = {
        {label = "Collect Wealth Clock", key = "collectWealthClock"},
        {label = "Collect Ant Pass", key = "collectAntPass"},
        {label = "Summon Honey Storm", key = "summonHoneyStorm"},
        {label = "Collect Glue", key = "collectGlue"},
        {label = "Farm Sprouts", key = "farmSprouts"},
        {label = "Use Field Dice", key = "useFieldDice"},
        {label = "Use Micro Converter", key = "useMicroConverter"},
        {label = "Use Coconut", key = "useCoconut"},
        {label = "Use Glitter", key = "useGlitter"},
        {label = "Use Snowflake", key = "useSnowflake"}
    }
    
    for i, toggle in ipairs(fieldToggles) do
        local toggleY = fieldAbilityY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(fieldAbilityX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        self:CreateText(toggle.label, fieldAbilityX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = fieldAbilityX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(fieldAbilityX, toggleY, 196, 22, function()
            if toggle.key then
                self[toggle.key] = not self[toggle.key]
                self.needsRedraw = true
            end
        end)
    end
    
    -- Gather Settings Section
    contentY = contentY + 120
    self:CreateText("Gather Settings", contentX, contentY, Color3.fromRGB(200, 210, 220), 14)
    
    contentY = contentY + 25
    
    local gatherToggles = {
        {label = "Collect Tokens", key = "collectTokens"},
        {label = "Farm Blooms", key = "autoGrindBlooms"},
        {label = "Farm Under Balloons", key = "farmUnderBalloons"},
        {label = "Farm Under Clouds", key = "farmUnderClouds"},
        {label = "Farm Flames (Buggy)", key = "farmFlames"},
        {label = "Farm Bubbles", key = "farmBubbles"},
        {label = "Convert Balloon", key = "convertBalloon"},
        {label = "Reset When Full", key = "resetWhenFull"}
    }
    
    for i, toggle in ipairs(gatherToggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if toggle.key then
                self[toggle.key] = not self[toggle.key]
                self.needsRedraw = true
            end
        end)
    end
    
    -- RENDER DROPDOWNS LAST SO THEY APPEAR ON TOP
    if self.dropdownOpen then
        local options = GetFlowerZones()
        local menuY = dropdownY + 28
        
        self:CreateRect(dropdown1X, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
        
        for i, option in ipairs(options) do
            local optionY = menuY + ((i - 1) * 24)
            
            self:CreateRect(dropdown1X, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
            self:CreateText(option, dropdown1X + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
            
            self:RegisterButton(dropdown1X, optionY, 150, 24, function()
                if not self.lastMousePressed then
                    self.selectedOption = option
                    self.dropdownOpen = false
                    self.needsRedraw = true
                end
            end)
        end
    end
    
    if self.secondDropdownOpen then
        local options = {
            "Basic (1)",
            "Silver (2)",
            "Gold (3)",
            "Diamond (4)",
            "Supreme (1)",
            "None (0)"
        }
        local menuY = dropdownY + 28
        
        self:CreateRect(dropdown2X, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
        
        for i, option in ipairs(options) do
            local optionY = menuY + ((i - 1) * 24)
            
            self:CreateRect(dropdown2X, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
            self:CreateText(option, dropdown2X + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
            
            self:RegisterButton(dropdown2X, optionY, 150, 24, function()
                if not self.lastMousePressed then
                    self.selectedSprinkler = option
                    self.secondDropdownOpen = false
                    self.needsRedraw = true
                end
            end)
        end
    end
end

function UI:RenderCombatTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Combat & Mobs", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    local combatToggles = {
        {label = "Kill Coconut Crab", key = "killCoconutCrab"},
        {label = "Train Snail", key = "trainSnail"},
        {label = "Kill King Beetle (a)", key = "killKingBeetle"},
        {label = "Kill Vicious Bee (a)", key = "killViciousBee"},
        {label = "Kill Commando Chick (a)", key = "killCommandoChick"},
        {label = "Kill Windy (a)", key = "killWindy"},
        {label = "Kill Tunnel Bear (a)", key = "killTunnelBear"},
        {label = "Hi", key = "avoidTough"}
    }

    for i, toggle in ipairs(combatToggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if toggle.key == "killCoconutCrab" then
                if not value and self.autoFarmEnabled then
                    print("Turn off Auto Farm first")
                    return
                end
                
                self.killCoconutCrab = not self.killCoconutCrab
                self.needsRedraw = true
                
                if self.killCoconutCrab then
                    self:StartCoconutCrab()
                else
                    self:StopCoconutCrab()
                end
            elseif toggle.key == "trainSnail" then
                if not value and self.autoFarmEnabled then
                    print("turn off Auto Farm first")
                    return
                end
                
                self.trainSnail = not self.trainSnail
                self.needsRedraw = true
                
                if self.trainSnail then
                    self:StartTrainSnail()
                else
                    self:StopTrainSnail()
                end
            elseif toggle.key == "killKingBeetle" then
                self.killKingBeetle = not self.killKingBeetle
                self.needsRedraw = true
                
                if self.killKingBeetle then
                    if not self.autoFarmEnabled then
                        print("King Beetle enabled - will activate when Auto Farm starts")
                    else
                        print("King Beetle enabled - will check in 24 hours")
                    end
                else
                    print("King Beetle disabled")
                end
            elseif toggle.key == "killViciousBee" then
                self.killViciousBee = not self.killViciousBee
                self.needsRedraw = true
                
                if self.killViciousBee then
                    if not self.autoFarmEnabled then
                        print("Vicious Bee enabled - will activate when Auto Farm starts")
                    else
                        print("Vicious Bee enabled - checking continuously")
                    end
                else
                    print("Vicious Bee disabled")
                end
            elseif toggle.key == "killCommandoChick" then
                self.killCommandoChick = not self.killCommandoChick
                self.needsRedraw = true
                print("DEBUG: About to check for Commando Chick...")
                if self.killCommandoChick then
                    if not self.autoFarmEnabled then
                        print("Commando Chick enabled - will activate when Auto Farm starts")
                    else
                        print("Commando Chick enabled - checking continuously")
                    end
               else
                    print("Commando Chick disabled")
               end
            elseif toggle.key == "killTunnelBear" then
    self.killTunnelBear = not self.killTunnelBear
    self.needsRedraw = true
    
    if self.killTunnelBear then
        if not self.autoFarmEnabled then
            print("Tunnel Bear enabled - will activate when Auto Farm starts")
        else
            print("Tunnel Bear enabled - will check in 48 hours")
        end
    else
        print("Tunnel Bear disabled")
    end
            elseif toggle.key == "killWindy" then
                self.killWindy = not self.killWindy
                self.needsRedraw = true
    
                if self.killWindy then
                    if not self.autoFarmEnabled then
                        print("Windy Bee enabled - will activate when Auto Farm starts")
                    else
                        print("Windy Bee enabled - checking continuously")
                    end
                else
                    print("Windy Bee disabled")
                end
            else
                self[toggle.key] = not self[toggle.key]
                self.needsRedraw = true
            end
        end)
    end
    
    local dropdownX = contentX + 220
    local dropdownY = contentY
    
    self:CreateText("Target Selection", dropdownX, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    self:CreateText("Last selected: " .. (self.selectedCombatTarget or "Any Mob"), dropdownX, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    self:CreateRect(dropdownX, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedCombatTarget or "Any Mob", dropdownX + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    self:CreateText("v", dropdownX + 135, dropdownY + 6, Color3.fromRGB(150, 160, 175), 12)
    
    self:RegisterButton(dropdownX, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.combatDropdownOpen = not self.combatDropdownOpen
            self.needsRedraw = true
        end
    end)
    
    if self.combatDropdownOpen then
        local options = {
            "Any Mob",
            "Ladybugs",
            "Rhino Beetles",
            "Mantis",
            "Scorpions",
            "Werewolf",
            "Cave Monsters",
            "King Beetle",
            "Tunnel Bear"
        }
        
        local menuY = dropdownY + 28
        
        self:CreateRect(dropdownX, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
        
        for i, option in ipairs(options) do
            local optionY = menuY + ((i - 1) * 24)
            
            self:CreateRect(dropdownX, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
            self:CreateText(option, dropdownX + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
            
            self:RegisterButton(dropdownX, optionY, 150, 24, function()
                if not self.lastMousePressed then
                    self.selectedCombatTarget = option
                    self.combatDropdownOpen = false
                    self.needsRedraw = true
                end
            end)
        end
    end
end

function UI:RenderSettingsTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Settings", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    -- Settings toggles
    local settingsToggles = {
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false}
    }
    
    for i, toggle in ipairs(settingsToggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        -- Toggle background
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        -- Label
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        -- Toggle switch
        local switchX = contentX + 170
        local switchColor = toggle.value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        -- Toggle circle
        local circleX = toggle.value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            print(toggle.label .. " toggled")
        end)
    end
    
    -- Tween Speed Slider on the right
    local sliderX = contentX + 220
    local sliderY = contentY
    
    self:CreateText("Place Holder Tween", sliderX, sliderY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    -- Display current speed value
    self:CreateText("Speed: " .. tostring(self.tweenSpeed), sliderX, sliderY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    -- Slider background
    local sliderWidth = 150
    self:CreateRect(sliderX, sliderY + 8, sliderWidth, 6, Color3.fromRGB(40, 45, 55))
    
    -- Calculate slider position (map 20-120 to 0-150)
    local normalizedValue = (self.tweenSpeed - 20) / (120 - 20)
    local sliderPos = normalizedValue * sliderWidth
    
    -- Slider fill
    self:CreateRect(sliderX, sliderY + 8, sliderPos, 6, Color3.fromRGB(16, 185, 129))
    
    -- Slider handle
    self:CreateRect(sliderX + sliderPos - 4, sliderY + 2, 8, 18, Color3.fromRGB(16, 185, 129))
    
    self:RegisterButton(sliderX, sliderY + 2, sliderWidth, 18, function()
        self.draggingSlider = true
    end)

    -- Min/Max labels
    self:CreateText("20", sliderX, sliderY + 20, Color3.fromRGB(120, 130, 145), 10)
    self:CreateText("120", sliderX + sliderWidth - 15, sliderY + 20, Color3.fromRGB(120, 130, 145), 10)
    
    -- Version info at bottom
    local versionY = contentY + 240
    self:CreateText("Version 1.1.0 - Convesion Fix 2", sliderX, versionY, Color3.fromRGB(100, 110, 125), 11)
    self:CreateText("Lito", sliderX, versionY + 18, Color3.fromRGB(100, 110, 125), 11)
end




function UI:StartAutoFarm()
    if self.selectedOption == "Select Field..." or self.selectedOption == "" then
        print("Please select a field first!")
        self.autoFarmEnabled = false
        self.needsRedraw = true
        return
    end
    
    if not self.originalAutoFarmField or self.lastFieldChangeSource == "autofarm" then
        self.originalAutoFarmField = self.selectedOption
        self.lastFieldChangeSource = "autofarm"
        print("DEBUG: Set originalAutoFarmField = " .. self.originalAutoFarmField)
    end

    -- Check if coconut crab is running
    if self.killCoconutCrab then
        print("Turn off Coconut Crab first!")
        self.autoFarmEnabled = false
        self.needsRedraw = true
        return
    end

    -- CRITICAL: Kill any existing auto farm thread first
    if self.autoFarmRunning then
        print("ERROR: Auto farm already running! Stopping old instance...")
        self:StopAutoFarm()
        wait(1)
    end
    
    -- CRITICAL: Kill the thread if it still exists
    if self.autoFarmThread then
        print("Killing old auto farm thread...")
        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
        wait(0.5)
    end
    
    self.autoFarmRunning = true
    self.status = "Auto Farm Active"
    self.needsRedraw = true
    self:StartTimedActionsHandler()
    
    self.autoFarmThread = spawn(function()
        -- CRITICAL: Check if Vicious Bee despawned or moved during token collection
-- Only check if we are ACTIVELY hunting Vicious Bee right now
if self.killViciousBee and huntingVicious then
    local viciousBeeData = self:CheckForViciousBee()
    
    if not viciousBeeData then
        -- Vicious Bee despawned completely!
        print("✓ Vicious Bee despawned during token collection! Exiting to main loop...")
        StopWalking()
        return false
    elseif viciousBeeData.field.Name ~= self.selectedOption then
        -- Vicious Bee moved to different field
        print("⚠️ Vicious Bee moved to " .. viciousBeeData.field.Name .. " during token collection!")
        StopWalking()
        return false
    end
end
        
        local lastSelectedField = self.selectedOption
        local fullPollenTime = nil
        local returningToHive = false
        local huntingWindy = false
        local originalFieldBeforeWindy = nil
        local walkedToWindyOnce = false
        local hasReachedFieldOnce = false
        
        -- Helper function to check for death and handle respawn
        local function checkAndHandleDeath()
            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if not character then
                return true -- Treat no character as "wait for respawn"
            end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                print("=== PLAYER DIED ===")
                self.status = "Respawning..."
                self.needsRedraw = true
                
                -- Stop everything
                StopWalking()
                self:ClearTweenQueue()
                
                -- Wait for respawn
                local respawned = WaitForRespawn(30)
                
                if respawned then
                    print("✓ Respawned successfully")
                    
                    self.status = "Waiting for bees..."
                    self.needsRedraw = true
                    wait(15)
                    -- If was hunting Vicious Bee, return to original field
                    -- Don't reset Vicious hunting on death - keep hunting until it despawns
if self.huntingVicious then
    print("Died while hunting Vicious Bee, will resume hunting after respawn")
    walkedToViciousOnce = false  -- Reset so we walk to it again after respawn
end
                    
                    -- Reset states (INCLUDING SPRINKLERS)
                    returningToHive = false
                    fullPollenTime = nil
                    self.sprinklersPlaced = false  -- CRITICAL: Reset sprinkler flag so they get placed again
                    self.status = "Auto Farm Active"
                    self.needsRedraw = true
                    
                    wait(3)
                    
                    -- Force tween back to selected field
                    player = game.Players.LocalPlayer
                    character = player.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local flowerZones = game.Workspace.FlowerZones
                            if flowerZones and self.selectedOption then
                                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                                if targetZone then
                                    print("Forcing tween back to field after death...")
                                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                                    self:QueueTween(hrp, targetPos, true)
                                    
                                    while self.processingTween and self.autoFarmEnabled do
                                        wait(0.1)
                                    end
                                    
                                    wait(1)
                                    print("✓ Arrived back at field after death")
                                    print("Sprinklers will be placed next time in field")
                                end
                            end
                        end
                    end
                else
                    print("ERROR: Failed to respawn, stopping auto farm")
                    self:StopAutoFarm()
                    return false
                end
                
                return true -- Death was handled
            end
            
            return false -- No death detected
        end
        
        while self.autoFarmEnabled and self.autoFarmRunning do
            -- Check for death at start of loop
            if checkAndHandleDeath() then
                wait(0.5)
                continue
            end
            
            -- Pause if timed action is running
            if self.pausedForTimedAction then
                wait(0.5)
                continue
            end
            
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then
                    print("No character, waiting...")
                    wait(1)
                    return
                end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then
                    print("No HRP, waiting...")
                    wait(1)
                    return
                end
                
                local coreStats = player:FindFirstChild("CoreStats")
                
                if coreStats then
                    local pollen = coreStats:FindFirstChild("Pollen")
                    local capacity = coreStats:FindFirstChild("Capacity")
                    
                    if pollen and capacity then
                        local pollenValue = pollen.Value
                        local capacityValue = capacity.Value
                                                
                        if pollenValue >= capacityValue then
                            if not fullPollenTime then
                                fullPollenTime = os.clock()
                            else
                                local elapsed = os.clock() - fullPollenTime
                            end
                            
                            if fullPollenTime and os.clock() - fullPollenTime >= 2 and not returningToHive then
                                returningToHive = true
                                
                                -- Check if Reset When Full is enabled
                                if self.resetWhenFull then
                                    self.status = "Resetting (Full)"
                                    self.needsRedraw = true
                                    
                                    StopWalking()
                                    self:ClearTweenQueue()
                                    
                                    print("=== RESET WHEN FULL TRIGGERED ===")
                                    ResetPlayer()
                                    
                                    -- Wait for respawn
                                    local respawned = WaitForRespawn(30)
                                    
                                    if respawned then
                                        print("✓ Respawned successfully")
                                        self.status = "Waiting for bees..."
                                        self.needsRedraw = true
                                        wait(15)
                                        
                                        -- Reset state
                                        returningToHive = false
                                        fullPollenTime = nil
                                        self.sprinklersPlaced = false
                                        self.status = "Auto Farm Active"
                                        self.needsRedraw = true
                                        
                                        print("✓ Resuming auto farm...")
                                        
                                        -- IMPORTANT: Force the player to go back to the field first
                                        local player = game.Players.LocalPlayer
                                        local character = player.Character
                                        if character then
                                            local hrp = character:FindFirstChild("HumanoidRootPart")
                                            if hrp then
                                                local flowerZones = game.Workspace.FlowerZones
                                                if flowerZones and self.selectedOption then
                                                    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                                                    if targetZone then
                                                        print("Forcing tween back to field after respawn...")
                                                        local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                                                        self:QueueTween(hrp, targetPos, true)
                                                        
                                                        -- Wait for tween to complete
                                                        while self.processingTween and self.autoFarmEnabled do
                                                            wait(0.1)
                                                        end
                                                        
                                                        wait(1)
                                                        print("✓ Arrived back at field after respawn")
                                                    end
                                                end
                                            end
                                        end
                                    else
                                        print("ERROR: Failed to respawn, stopping auto farm")
                                        self:StopAutoFarm()
                                        return
                                    end
                                else
                                    -- Original hive behavior
                                    self.status = "Going to Hive"
                                    self.needsRedraw = true
                                    
                                    StopWalking()
                                    
                                    self:ClearTweenQueue()
                                    wait(0.5)
                                    
                                    local hivePlatforms = game.Workspace:FindFirstChild("HivePlatforms")
                                    
                                    if hivePlatforms then
                                        local playerHive = nil
                                        
                                        for _, platform in pairs(hivePlatforms:GetChildren()) do
                                            local playerRef = platform:FindFirstChild("PlayerRef")
                                            if playerRef and playerRef.Value then
                                                local refPlayer = playerRef.Value
                                                
                                                if refPlayer.Name == player.Name then
                                                    playerHive = platform
                                                    break
                                                end
                                            end
                                        end
                                        
                                        if playerHive then
                                            local hivePart = playerHive:FindFirstChild("Platform") or playerHive:FindFirstChildWhichIsA("BasePart")
                                            
                                            if hivePart then
                                                local hivePos = Vector3.new(hivePart.Position.X, hivePart.Position.Y + 5, hivePart.Position.Z)
                                                
                                                local startPos = hrp.Position
                                                local dx = hivePos.X - startPos.X
                                                local dy = hivePos.Y - startPos.Y
                                                local dz = hivePos.Z - startPos.Z
                                                local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                                                
                                                self:QueueTween(hrp, hivePos, true)
                                                local maxWaitTime = 60
                                                local startWait = os.clock()
                                                local loopCount = 0
                                                
                                                while self.processingTween and self.autoFarmEnabled do
                                                    loopCount = loopCount + 1
                                                    
                                                    if os.clock() - startWait > maxWaitTime then
                                                        print("ee: TIMEOUT!")
                                                        self:ClearTweenQueue()
                                                        break
                                                    end
                                                    wait(0.1)
                                                end
                                                wait(2)
                                                while not isrbxactive() and self.autoFarmEnabled do
                                                    warn("Roblox Is Not Active")
                                                    self.status = "Waiting for Roblox window"
                                                    self.needsRedraw = true
                                                    wait(0.5)
                                                end
                                                
                                                if self.autoFarmEnabled then
                                    -- CRITICAL: Verify player is actually at hive before converting
                                    hrp = character:FindFirstChild("HumanoidRootPart")
                                    if not hrp then
                                        print("ERROR: No HRP for conversion check")
                                        returningToHive = false
                                        fullPollenTime = nil
                                    else
                                        local currentPos = hrp.Position
                                        local dx = hivePos.X - currentPos.X
                                        local dy = hivePos.Y - currentPos.Y
                                        local dz = hivePos.Z - currentPos.Z
                                        local distanceToHive = math.sqrt(dx * dx + dy * dy + dz * dz)
                                        
                                        print("Distance to hive: " .. string.format("%.1f", distanceToHive) .. " studs")
                                        
                                        -- If player is NOT at hive (more than 25 studs away), try to return
                                        if distanceToHive > 25 then
                                            print("⚠️ Player is " .. string.format("%.1f", distanceToHive) .. " studs from hive!")
                                            
                                            self.status = "Returning to Hive"
                                            self.needsRedraw = true
                                            
                                            -- Try walking back first (5 second attempt)
                                            print("Attempting to walk back to hive...")
                                            WalkTo(hivePos)
                                            
                                            local walkStartTime = os.clock()
                                            local walkSuccess = false
                                            
                                            while IsWalking() and self.autoFarmEnabled do
                                                if os.clock() - walkStartTime > 5 then
                                                    print("Walk timeout (5s), switching to tween...")
                                                    StopWalking()
                                                    break
                                                end
                                                
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local cPos = hrp.Position
                                                    local cdx = hivePos.X - cPos.X
                                                    local cdy = hivePos.Y - cPos.Y
                                                    local cdz = hivePos.Z - cPos.Z
                                                    local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                                    
                                                    if cDist < 25 then
                                                        print("✓ Walked back to hive successfully")
                                                        StopWalking()
                                                        walkSuccess = true
                                                        break
                                                    end
                                                end
                                                
                                                wait(0.1)
                                            end
                                            
                                            StopWalking()
                                            
                                            -- If walk failed, use tween
                                            if not walkSuccess then
                                                print("Walk failed, using tween to return to hive...")
                                                self:QueueTween(hrp, hivePos, true)
                                                
                                                local tweenStartTime = os.clock()
                                                while self.processingTween and self.autoFarmEnabled do
                                                    if os.clock() - tweenStartTime > 60 then
                                                        print("ERROR: Tween timeout!")
                                                        self:ClearTweenQueue()
                                                        returningToHive = false
                                                        fullPollenTime = nil
                                                        break
                                                    end
                                                    wait(0.1)
                                                end
                                                
                                                if self.processingTween then
                                                    wait(1)
                                                    print("✓ Tweened back to hive")
                                                end
                                            end
                                            
                                            wait(0.5)
                                        end
                                        
                                        -- Final distance check before converting
                                        hrp = character:FindFirstChild("HumanoidRootPart")
                                        if hrp then
                                            currentPos = hrp.Position
                                            dx = hivePos.X - currentPos.X
                                            dy = hivePos.Y - currentPos.Y
                                            dz = hivePos.Z - currentPos.Z
                                            distanceToHive = math.sqrt(dx * dx + dy * dy + dz * dz)
                                            
                                            if distanceToHive > 25 then
                                                print("ERROR: Still not at hive after return attempts (" .. string.format("%.1f", distanceToHive) .. " studs)")
                                                print("Skipping conversion and resuming farming")
                                                returningToHive = false
                                                fullPollenTime = nil
                                            else
                                                print("✓ At hive, starting conversion")
                                                self.status = "Converting Pollen"
                                                self.needsRedraw = true
                                                
                                                -- CRITICAL: Re-enable animations before converting
                                                disableUnwalk()
                                                wait(0.3)
                                                
                                                keypress(0x45)
                                                wait(0.1)
                                                keyrelease(0x45)
                                            end
                                        end
                                    end
                                                    
                                                    -- Check for nearby hive balloon if Convert Balloon is enabled
                                                    print("DEBUG BALLOON: convertBalloon = " .. tostring(self.convertBalloon))

                                                    local balloonFound = false
                                                    if self.convertBalloon then
                                                        print("DEBUG BALLOON: Checking for balloons...")
                                                        local balloons = game.Workspace:FindFirstChild("Balloons")
                                                        print("DEBUG BALLOON: Balloons folder exists: " .. tostring(balloons ~= nil))
                                                        
                                                        if balloons then
                                                            local hiveBalloons = balloons:FindFirstChild("HiveBalloons")
                                                            print("DEBUG BALLOON: HiveBalloons exists: " .. tostring(hiveBalloons ~= nil))
                                                            
                                                            if hiveBalloons then
                                                                print("DEBUG BALLOON: HiveBalloons children count: " .. #hiveBalloons:GetChildren())
                                                                
                                                                for _, balloonInstance in pairs(hiveBalloons:GetChildren()) do
                                                                    print("DEBUG BALLOON: Checking balloonInstance: " .. balloonInstance.Name)
                                                                    
                                                                    if balloonInstance.Name == "HiveBalloonInstance" then
                                                                        local balloonBody = balloonInstance:FindFirstChild("BalloonBody")
                                                                        print("DEBUG BALLOON: BalloonBody exists: " .. tostring(balloonBody ~= nil))
                                                                        
                                                                        if balloonBody and balloonBody:IsA("BasePart") then
                                                                            local balloonPos = balloonBody.Position
                                                                            local hrpPos = hrp.Position
                                                                            
                                                                            local dx = balloonPos.X - hrpPos.X
                                                                            local dy = balloonPos.Y - hrpPos.Y
                                                                            local dz = balloonPos.Z - hrpPos.Z
                                                                            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                                                                            
                                                                            print("DEBUG BALLOON: Balloon distance: " .. string.format("%.1f", distance) .. " studs")
                                                                            
                                                                            if distance <= 20 then
                                                                                print("✓✓✓ Hive balloon found within 12 studs! Waiting for it to disappear...")
                                                                                balloonFound = true
                                                                                self.status = "Converting Balloon"
                                                                                self.needsRedraw = true
                                                                                
                                                                                while self.autoFarmEnabled and balloonBody and balloonBody.Parent do
                                                        -- CRITICAL: Check if player is still at hive during balloon conversion
                                                        hrp = character:FindFirstChild("HumanoidRootPart")
                                                        if hrp then
                                                            local cPos = hrp.Position
                                                            local cdx = hivePos.X - cPos.X
                                                            local cdy = hivePos.Y - cPos.Y
                                                            local cdz = hivePos.Z - cPos.Z
                                                            local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                                            
                                                            if cDist > 25 then
                                                                print("⚠️ Player moved away from hive during balloon conversion (" .. string.format("%.1f", cDist) .. " studs)!")
                                                                print("Attempting to return to hive...")
                                                                
                                                                WalkTo(hivePos)
                                                                local walkStart = os.clock()
                                                                
                                                                while IsWalking() and self.autoFarmEnabled do
                                                                    if os.clock() - walkStart > 5 then
                                                                        StopWalking()
                                                                        print("Walk timeout, using tween...")
                                                                        self:QueueTween(hrp, hivePos, true)
                                                                        
                                                                        while self.processingTween and self.autoFarmEnabled do
                                                                            wait(0.1)
                                                                        end
                                                                        break
                                                                    end
                                                                    
                                                                    hrp = character:FindFirstChild("HumanoidRootPart")
                                                                    if hrp then
                                                                        local rPos = hrp.Position
                                                                        local rdx = hivePos.X - rPos.X
                                                                        local rdy = hivePos.Y - rPos.Y
                                                                        local rdz = hivePos.Z - rPos.Z
                                                                        local rDist = math.sqrt(rdx * rdx + rdy * rdy + rdz * rdz)
                                                                        
                                                                        if rDist < 5 then
                                                                            StopWalking()
                                                                            wait(1)
                                                                            break
                                                                        end
                                                                    end
                                                                    
                                                                    wait(0.1)
                                                                end
                                                                
                                                                StopWalking()
                                                                wait(1)
                                                                print("✓ Returned to hive")
                                                                
                                                                -- Wait for Roblox to be active before pressing E
                                                                while not isrbxactive() and self.autoFarmEnabled do
                                                                    warn("Roblox Is Not Active - waiting to press E")
                                                                    self.status = "Waiting for Roblox window"
                                                                    self.needsRedraw = true
                                                                    wait(0.5)
                                                                end
                                                                
                                                                if self.autoFarmEnabled then
                                                                    print("Pressing E to restart conversion...")
                                                                    keypress(0x45)
                                                                    wait(0.2)
                                                                    keyrelease(0x45)
                                                                    wait(0.5)
                                                                    print("✓ Conversion restarted")
                                                                end
                                                            end
                                                        end
                                                        
                                                        print("DEBUG BALLOON: Still waiting for balloon to disappear...")
                                                        wait(0.5)
                                                    end
                                                                                
                                                                                print("✓ Balloon disappeared!")
                                                                                break
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            end
                                                        end
                                                    end

                                                    while self.autoFarmEnabled do
                                                -- CRITICAL: Check if player is still at hive during conversion
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local cPos = hrp.Position
                                                    local cdx = hivePos.X - cPos.X
                                                    local cdy = hivePos.Y - cPos.Y
                                                    local cdz = hivePos.Z - cPos.Z
                                                    local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                                    
                                                    if cDist > 25 then
                                                        print("⚠️ Player moved away from hive during conversion (" .. string.format("%.1f", cDist) .. " studs)!")
                                                        print("Attempting to return to hive...")
                                                        
                                                        WalkTo(hivePos)
                                                        local walkStart = os.clock()
                                                        
                                                        while IsWalking() and self.autoFarmEnabled do
                                                            if os.clock() - walkStart > 5 then
                                                                StopWalking()
                                                                print("Walk timeout, using tween...")
                                                                self:QueueTween(hrp, hivePos, true)
                                                                
                                                                while self.processingTween and self.autoFarmEnabled do
                                                                    wait(0.1)
                                                                end
                                                                break
                                                            end
                                                            
                                                            hrp = character:FindFirstChild("HumanoidRootPart")
                                                            if hrp then
                                                                local rPos = hrp.Position
                                                                local rdx = hivePos.X - rPos.X
                                                                local rdy = hivePos.Y - rPos.Y
                                                                local rdz = hivePos.Z - rPos.Z
                                                                local rDist = math.sqrt(rdx * rdx + rdy * rdy + rdz * rdz)
                                                                
                                                                if rDist < 5 then
                                                                    StopWalking()
                                                                    wait(1)
                                                                    break
                                                                end
                                                            end
                                                            
                                                            wait(0.1)
                                                        end
                                                        
                                                        StopWalking()
                                                        print("✓ Returned to hive")
                                                        
                                                        -- Wait for Roblox to be active before pressing E
                                                        while not isrbxactive() and self.autoFarmEnabled do
                                                            warn("Roblox Is Not Active - waiting to press E")
                                                            self.status = "Waiting for Roblox window"
                                                            self.needsRedraw = true
                                                            wait(0.5)
                                                        end
                                                        
                                                        if self.autoFarmEnabled then
                                                            print("Pressing E to restart conversion...")
                                                            keypress(0x45)
                                                            wait(0.2)
                                                            keyrelease(0x45)
                                                            wait(0.5)
                                                            print("✓ Conversion restarted")
                                                        end
                                                    end
                                                end
                                                
                                                local currentPollen = pollen.Value
                                                
                                                if currentPollen <= 0 then
                                                    print("Pollen reached 0, waiting 4 seconds for bees to convert...")
                                                    wait(4)
                                                    break
                                                end
                                                
                                                wait(0.5)
                                            end
                                                                                    
                                                    returningToHive = false
                                                    fullPollenTime = nil
                                                    self.status = "Auto Farm Active"
                                                    self.needsRedraw = true
                                                end
                                            else
                                                wait(0.1)
                                            end
                                        else
                                            returningToHive = false
                                            fullPollenTime = nil
                                        end
                                    else
                                        returningToHive = false
                                        fullPollenTime = nil
                                    end
                                end
                            end
                        else
                            -- Not full
                            if fullPollenTime then
                                fullPollenTime = nil
                            end
                            if returningToHive then
                                returningToHive = false
                            end
                        end
                    end
                end
                
                -- Skip field logic if returning to hive
                if returningToHive then
                    wait(1)
                    return
                end
                
                -- Check for Windy Bee
if self.killWindy then
    print("DEBUG: Checking for Windy Bee...")
    local windyBeeData = self:CheckForWindyBee()
    
    if windyBeeData then
        local windyBeeField = windyBeeData.field
        local windyBeePos = windyBeeData.position
        
        -- Windy Bee is present
        if not huntingWindy then
            -- Just started hunting
            print("=== WINDY BEE DETECTED - SWITCHING TO " .. windyBeeField.Name .. " ===")
            originalFieldBeforeWindy = self.selectedOption
            if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
                self.originalAutoFarmField = self.selectedOption
            end
            self.selectedOption = windyBeeField.Name
            self.sprinklersPlaced = false
            huntingWindy = true
            walkedToWindyOnce = false
            self.status = "Going to Windy Bee Field"
            self.needsRedraw = true
            lastSelectedField = windyBeeField.Name
            
            -- STEP 1: Tween to the field center first
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(windyBeeField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    print("Step 1: Tweening to " .. windyBeeField.Name .. " center")
                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    -- Wait for tween to complete
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    
                    print("✓ Arrived at field center")
                    wait(0.5)
                end
            end
            
            -- STEP 2: Tween to Windy Bee position ONCE (with live position updates)
            if self.autoFarmEnabled and not walkedToWindyOnce then
                self.status = "Tweening to Windy Bee"
                self.needsRedraw = true
                print("Step 2: Tweening to Windy Bee with live position tracking...")
                
                -- Start the tween to initial position
                windyBeeData = self:CheckForWindyBee()
                if windyBeeData then
                    windyBeePos = windyBeeData.position
                    self:QueueTween(hrp, windyBeePos, true)
                end
                
                -- Update position every 0.5 seconds during tween
                local lastUpdateTime = os.clock()
                
                while self.processingTween and self.autoFarmEnabled do
                    if checkAndHandleDeath() then
                        break
                    end
                    
                    -- Update Windy Bee position every 0.5 seconds
                    if os.clock() - lastUpdateTime >= 0.5 then
                        windyBeeData = self:CheckForWindyBee()
                        if windyBeeData then
                            windyBeePos = windyBeeData.position
                            
                            -- Cancel current tween and start new one to updated position
                            if self.currentTween then
                                self.currentTween:Stop()
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local startPos = hrp.Position
                                local dx = windyBeePos.X - startPos.X
                                local dy = windyBeePos.Y - startPos.Y
                                local dz = windyBeePos.Z - startPos.Z
                                local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                                local tweenTime = distance / self.tweenSpeed
                                local tweenInfo = TweenInfo.new(tweenTime, "Linear", "None")
                                self.currentTween = TweenService:Create(hrp, tweenInfo, {Position = windyBeePos})
                                self.currentTween:Play()
                                
                                print("Updated Windy Bee position: " .. tostring(windyBeePos))
                            end
                        end
                        lastUpdateTime = os.clock()
                    end
                    
                    wait(0.1)
                end
                
                walkedToWindyOnce = true
                print("✓ Arrived at Windy Bee, starting normal farming")
                self.status = "Hunting Windy Bee"
                self.needsRedraw = true
                wait(0.5)
            end
            
        elseif windyBeeField.Name ~= self.selectedOption then
            -- Windy Bee moved to a different field
            print("Windy Bee moved to " .. windyBeeField.Name)
            self.selectedOption = windyBeeField.Name
            self.sprinklersPlaced = false
            walkedToWindyOnce = true  -- Don't walk to Windy again, just go to new field
            lastSelectedField = windyBeeField.Name
            
            -- Tween to new field center (don't walk to Windy position again)
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(windyBeeField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    print("Windy Bee moved, tweening to new field " .. windyBeeField.Name)
                    self.status = "Following to New Field"
                    self.needsRedraw = true
                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    -- Wait for tween to complete
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    
                    print("✓ Arrived at new field, resuming normal farming")
                end
            end
        end
        -- If already hunting in same field, just continue farming
    else
        -- No Windy Bee found
        if huntingWindy then
            -- Was hunting, but now it's gone
            print("✓ Windy Bee despawned! Returning to " .. originalFieldBeforeWindy)
            self.selectedOption = self.originalAutoFarmField or originalFieldBeforeWindy
            self.lastFieldChangeSource = "autofarm"
            self.sprinklersPlaced = false
            huntingWindy = false
            walkedToWindyOnce = false
            originalFieldBeforeWindy = nil
            self.status = "Returning to Original Field"
            self.needsRedraw = true
            lastSelectedField = self.selectedOption
            
            -- Stop walking
            StopWalking()
            
            -- Tween back to original field
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    self:QueueTween(hrp, targetPos, true)
                    
                    -- Wait for tween to complete
                    while self.processingTween and self.autoFarmEnabled do
                        wait(0.1)
                    end
                    
                    print("✓ Returned to original field")
                    self.status = "Auto Farm Active"
                    self.needsRedraw = true
                end
            end
        end
    end
end

-- Check for Sprouts
print("DEBUG SPROUT: Checking for sprouts...")
if self.farmSprouts then
    local sproutData = self:CheckForSprouts()
    
    if sproutData then
        local sproutField = sproutData.field
        print("DEBUG SPROUT: ✓✓✓ Sprout data received - Field: " .. sproutField.Name)
        
        -- Check if we're already farming this specific sprout field
        if not self.currentSproutField then
            -- Not farming any sprout yet, start farming this one
            print("=== SPROUT DETECTED - SWITCHING FROM " .. self.selectedOption .. " TO " .. sproutField.Name .. " ===")
            
            -- Save current field and track which sprout field we're farming
            if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
                self.originalAutoFarmField = self.selectedOption
                print("DEBUG SPROUT: Saved originalAutoFarmField = " .. self.originalAutoFarmField)
            end
            
            self.lastFieldChangeSource = "sprout"
            self.currentSproutField = sproutField.Name  -- Track which sprout field we're farming
            self.selectedOption = sproutField.Name
            self.sprinklersPlaced = false
            self.status = "Going to Sprout Field"
            self.needsRedraw = true
            lastSelectedField = sproutField.Name
            
            -- Tween to sprout field
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(sproutField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    print("DEBUG SPROUT: Tweening to " .. sproutField.Name)
                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    
                    print("DEBUG SPROUT: ✓ Arrived at sprout field")
                    wait(0.5)
                end
            end
        elseif self.currentSproutField == sproutField.Name then
            -- Already farming this sprout field, continue farming
            print("DEBUG SPROUT: Already farming sprout in " .. sproutField.Name)
        else
            -- Different sprout spawned, but we're committed to current one
            print("DEBUG SPROUT: New sprout in " .. sproutField.Name .. " but committed to " .. self.currentSproutField)
        end
    else
        -- No Sprout found - check if we WERE farming a sprout
        if self.currentSproutField then
            -- Sprout in OUR field despawned!
            local returnField = self.originalAutoFarmField or self.selectedOption
            print("DEBUG SPROUT: ✓ Sprout in " .. self.currentSproutField .. " despawned!")
            print("DEBUG SPROUT: Collecting tokens for 20 seconds before returning to " .. returnField)
            
            self.currentSproutField = nil  -- Clear tracked sprout field
            self.status = "Collecting Sprout Tokens"
            self.needsRedraw = true
            self.collectingSproutTokens = true
            
            -- ✓ USE YOUR ACTUAL TOKEN COLLECTOR
            self.sproutCollectionEndTime = os.clock() + 20
            local collectStartTime = os.clock()
            
            print("DEBUG SPROUT: Starting 20-second collection with TokenCollector...")
            
            while self.autoFarmEnabled and (os.clock() - collectStartTime) < 20 do
                -- ✓✓✓ USE THE REAL TokenCollector FUNCTION
                local collectedToken = self:TokenCollector(false)  -- false = don't check if in field
                
                if not collectedToken then
                    wait(0.5)
                end
                
                -- Check if time is up
                if os.clock() >= self.sproutCollectionEndTime then
                    print("DEBUG SPROUT: ✓ 20 seconds complete")
                    break
                end
            end
            
            self.sproutCollectionEndTime = nil
            self.collectingSproutTokens = false
            
            print("DEBUG SPROUT: ✓ Token collection complete! Returning to " .. returnField)
            
            self.selectedOption = returnField
            self.lastFieldChangeSource = "autofarm"
            self.sprinklersPlaced = false
            self.status = "Returning to Original Field"
            self.needsRedraw = true
            lastSelectedField = returnField
            
            StopWalking()
            
            -- Tween back to original field
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(returnField)
                if targetZone then
                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    print("DEBUG SPROUT: Tweening back to " .. returnField)
                    self:QueueTween(hrp, targetPos, true)
                    
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    
                    print("DEBUG SPROUT: ✓✓✓ Returned to original field: " .. returnField)
                    self.status = "Auto Farm Active"
                    self.needsRedraw = true
                end
            end
        end
    end
else
    print("DEBUG SPROUT: farmSprouts toggle is OFF")
end

-- Check if field selection changed
if self.selectedOption ~= lastSelectedField then
    print("Field changed to: " .. self.selectedOption)
    lastSelectedField = self.selectedOption
    originalField = self.selectedOption  -- Update global field storer
    self.sprinklersPlaced = false  -- Reset sprinkler flag on field change
    walkedToViciousOnce = false  -- Reset vicious walk flag on field change
    if not self.lastFieldChangeSource or self.lastFieldChangeSource == "autofarm" then
        self.originalAutoFarmField = self.selectedOption
        self.lastFieldChangeSource = "autofarm"
    end
end 
-- Check for Vicious Bee
if self.killViciousBee then
    local viciousBeeData = self:CheckForViciousBee()
    
    if viciousBeeData then
        local viciousBeeField = viciousBeeData.field
        local viciousBeePos = viciousBeeData.position
        
        -- Vicious Bee is present
        if not self.huntingVicious then
    -- Just started hunting
    print("=== VICIOUS BEE DETECTED - SWITCHING TO " .. viciousBeeField.Name .. " ===")
    
    -- Save the current auto-farm field BEFORE switching
    if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
        self.originalAutoFarmField = self.selectedOption
        print("DEBUG: Saved originalAutoFarmField = " .. self.originalAutoFarmField)
    end
    
    self.lastFieldChangeSource = "vicious"
    
    self.selectedOption = viciousBeeField.Name
    self.sprinklersPlaced = false
    self.huntingVicious = true
    self.walkedToViciousOnce = false
    self.status = "Going to Vicious Bee Field"
    self.needsRedraw = true
    lastSelectedField = viciousBeeField.Name
    
    -- STEP 1: Tween to the field center first
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones then
        local targetZone = flowerZones:FindFirstChild(viciousBeeField.Name)
        if targetZone then
            local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
            print("Step 1: Tweening to " .. viciousBeeField.Name .. " center")
            self:QueueTween(hrp, fieldCenterPos, true)
            
            -- Wait for tween to complete
            while self.processingTween and self.autoFarmEnabled do
                if checkAndHandleDeath() then
                    break
                end
                wait(0.1)
            end
            
            print("✓ Arrived at field center")
            wait(0.5)
        end
    end
                            
                           -- STEP 2: Walk to Vicious Bee position ONCE
if self.autoFarmEnabled and not self.walkedToViciousOnce then
    -- Get fresh Vicious Bee position
    viciousBeeData = self:CheckForViciousBee()
    if viciousBeeData then
        viciousBeePos = viciousBeeData.position
        
        self.status = "Walking to Vicious Bee"
        self.needsRedraw = true
        print("Step 2: Walking to Vicious Bee at " .. tostring(viciousBeePos))
        WalkTo(viciousBeePos)
        
        -- Wait for arrival with death checks AND position updates
        local startTime = os.clock()
        local lastUpdateTime = os.clock()
        
        while IsWalking() and self.autoFarmEnabled do
            if checkAndHandleDeath() then
                break
            end
            
            -- Update Vicious Bee position every 0.5 seconds
            if os.clock() - lastUpdateTime >= 0.5 then
                viciousBeeData = self:CheckForViciousBee()
                if viciousBeeData then
                    viciousBeePos = viciousBeeData.position
                    WalkTo(viciousBeePos)
                    print("Updated Vicious Bee position: " .. tostring(viciousBeePos))
                end
                lastUpdateTime = os.clock()
            end
            
            -- ✓ FIX: Check distance WITHOUT Y-axis (only X and Z)
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - viciousBeePos.X
                local dz = currentPos.Z - viciousBeePos.Z
                local distance2D = math.sqrt(dx * dx + dz * dz)
                
                -- Arrived if within 15 studs on ground plane (ignoring Y)
                if distance2D < 15 then
                    print("✓ Arrived at Vicious Bee (2D distance: " .. string.format("%.1f", distance2D) .. " studs)")
                    StopWalking()
                    break
                end
            end
            
            if os.clock() - startTime > 15 then
                print("Walk to Vicious Bee timeout")
                StopWalking()
                break
            end
            
            wait(0.1)
        end
        
        StopWalking()
        self.walkedToViciousOnce = true
        print("✓ Arrived at Vicious Bee, starting normal farming")
        self.status = "Hunting Vicious Bee"
        self.needsRedraw = true
    end
end
                            
                        elseif viciousBeeField.Name ~= self.selectedOption then
                            -- Vicious Bee moved to a different field
                            print("Vicious Bee moved to " .. viciousBeeField.Name)
                            self.selectedOption = viciousBeeField.Name
                            self.sprinklersPlaced = false
                            walkedToViciousOnce = false
                            lastSelectedField = viciousBeeField.Name
                            
                            -- STEP 1: Tween to new field center
                            local flowerZones = game.Workspace.FlowerZones
                            if flowerZones then
                                local targetZone = flowerZones:FindFirstChild(viciousBeeField.Name)
                                if targetZone then
                                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                                    print("Step 1: Tweening to new field " .. viciousBeeField.Name)
                                    self.status = "Following to New Field"
                                    self.needsRedraw = true
                                    self:QueueTween(hrp, fieldCenterPos, true)
                                    
                                    -- Wait for tween to complete
                                    while self.processingTween and self.autoFarmEnabled do
                                        if checkAndHandleDeath() then
                                            break
                                        end
                                        wait(0.1)
                                    end
                                    
                                    print("✓ Arrived at new field center")
                                    wait(0.5)
                                end
                            end
                            
                            -- STEP 2: Walk to new Vicious Bee position ONCE
                            if self.autoFarmEnabled and not self.walkedToViciousOnce then
                                -- Get fresh Vicious Bee position
                                viciousBeeData = self:CheckForViciousBee()
                                if viciousBeeData then
                                    viciousBeePos = viciousBeeData.position
                                    
                                    self.status = "Walking to Vicious Bee"
                                    self.needsRedraw = true
                                    print("Step 2: Walking to new Vicious Bee position: " .. tostring(viciousBeePos))
                                    WalkTo(viciousBeePos)
                                    
                                    -- Wait for arrival with death checks
                                    local startTime = os.clock()
                                    while IsWalking() and self.autoFarmEnabled do
                                        if checkAndHandleDeath() then
                                            break
                                        end
                                        
                                        if os.clock() - startTime > 15 then
                                            print("Walk to Vicious Bee timeout")
                                            StopWalking()
                                            break
                                        end
                                        
                                        wait(0.1)
                                    end
                                    
                                    StopWalking()
                                    self.walkedToViciousOnce = true
                                    print("✓ Arrived at new Vicious Bee location, resuming normal farming")
                                end
                            end
                        end
                        -- If already hunting in same field, just continue farming (don't walk to Vicious Bee again)
                    else
    -- No Vicious Bee found
    if self.huntingVicious then
        -- Was hunting, but now it's gone
        local returnField = self.originalAutoFarmField or self.selectedOption
        print("✓ Vicious Bee defeated or despawned! Returning to " .. returnField)
        
        self.selectedOption = returnField
        self.lastFieldChangeSource = "autofarm"
        self.sprinklersPlaced = false
        self.huntingVicious = false
        walkedToViciousOnce = false
        self.status = "Returning to Original Field"
        self.needsRedraw = true
        lastSelectedField = returnField
        
        -- Stop walking
        StopWalking()
        
        -- Tween back to original field
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(returnField)
            if targetZone then
                local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                self:QueueTween(hrp, targetPos, true)
                
                -- Wait for tween to complete
                while self.processingTween and self.autoFarmEnabled do
                    if checkAndHandleDeath() then
                        break
                    end
                    wait(0.1)
                end
                
                print("✓ Returned to original field: " .. returnField)
                self.status = "Auto Farm Active"
                self.needsRedraw = true
            end
        end
    end
end
                end
                
                local flowerZones = game.Workspace.FlowerZones
                if not flowerZones then
                    wait(1)
                    return
                end
                
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                
                if not targetZone then
                    print("ERROR: Field '" .. self.selectedOption .. "' not found!")
                    self.status = "Field not found!"
                    wait(5)
                    return
                end
                
                -- Check if player is in the selected field
                local hrpPos = hrp.Position
                local fieldPos = targetZone.Position
                local fieldSize = targetZone.Size
                
                local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                
                local inField = withinX and withinZ and withinY
                
                -- Check for blooms FIRST (before checking if in field)
                if self.autoGrindBlooms then
                    local bloom = self:CheckForBlooms()
                    if bloom then
                        print("Found bloom in field, grinding...")
                        self:GrindBloom(bloom)
                    end
                end
                
                if inField then
                    if not hasReachedFieldOnce then
                        hasReachedFieldOnce = true
                        print("✓ Reached field for first time, sprout checks now enabled")
                    end
                    -- CRITICAL: Check if Windy Bee moved to a different field
                    if self.killWindy then
                        local windyBeeData = self:CheckForWindyBee()
                        if windyBeeData and windyBeeData.field.Name ~= self.selectedOption then
                            print("⚠️ Windy Bee moved to " .. windyBeeData.field.Name .. "!")
                            StopWalking()
                            self:ClearTweenQueue()
                            wait(0.5)
                            -- Let the main loop handle the field switch
                            wait(1)
                            return
                        end
                    end
                    
                    -- CRITICAL: Check for thorns if hunting Vicious Bee
                    if self.huntingVicious then
                        local thornData = self:CheckForThornsNearby(4)
                        if thornData then
                            print("⚠️ THORN DETECTED " .. string.format("%.1f", thornData.distance) .. " studs away - EVADING!")
                            self.status = "Evading Thorns"
                            self.needsRedraw = true
                            
                            StopWalking()
                            
                            -- Calculate escape direction (away from thorn)
                            local thornPos = thornData.position
                            local escapeX = hrpPos.X + (hrpPos.X - thornPos.X) * 3
                            local escapeZ = hrpPos.Z + (hrpPos.Z - thornPos.Z) * 3
                            local escapePos = Vector3.new(escapeX, hrpPos.Y, escapeZ)
                            
                            print("Moving away from thorn to: " .. tostring(escapePos))
                            WalkTo(escapePos)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                wait(0.1)
                            end
                            
                            StopWalking()
                            wait(0.5)
                            
                            -- Skip to next loop iteration
                            wait(1)
                            return
                        end
                    end
    
                    -- Check if sprinklers need to be placed FIRST
                    if self.useSprinkler and not self.sprinklersPlaced then
                        print("In field, placing sprinklers...")
                        self.status = "Placing Sprinklers"
                        self.needsRedraw = true
                        
                        -- Stop any movement
                        StopWalking()
                        self:ClearTweenQueue()
                        
                        -- Get lock position at Y+5
                        local lockPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        
                        -- Lock position for 6 seconds
                        local lockStart = os.clock()
                        local sprinklersStarted = false
                        
                        while os.clock() - lockStart < 6 and self.autoFarmEnabled do
                            -- Check for death during sprinkler placement
                            if checkAndHandleDeath() then
                                break
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                hrp.Position = lockPos
                                hrp.Velocity = Vector3.new(0, 0, 0)
                            end
                            
                            -- Start placing sprinklers after 0.5 seconds of lock
                            if not sprinklersStarted and os.clock() - lockStart >= 0.5 then
                                print("Placing sprinklers while locked...")
                                spawn(function()
                                    self:UseSprinkler()
                                end)
                                sprinklersStarted = true
                            end
                            
                            wait(0.01)
                        end
                        
                        self.sprinklersPlaced = true
                        print("✓ Sprinklers placed, resuming farming")
                    end    
                    
                    -- Check for death before token collection
                    if not checkAndHandleDeath() then
                        local collectedToken = self:TokenCollector()
                        
                        if not collectedToken then
                            self.status = huntingVicious and "Hunting Vicious Bee" or ("Farming at " .. self.selectedOption)
                            wait(1)
                        end
                    end
                else
                    self.status = "Returning to " .. self.selectedOption
                    
                    local startPos = hrp.Position
                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                    
                    local dx = targetPos.X - startPos.X
                    local dy = targetPos.Y - startPos.Y
                    local dz = targetPos.Z - startPos.Z
                    local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                    
                    self:QueueTween(hrp, targetPos)
                    
                    while self.processingTween and self.autoFarmEnabled do
                        -- Check for death during tween
                        if checkAndHandleDeath() then
                            break
                        end
                        
                        if self.selectedOption ~= lastSelectedField then
                            print("Field changed during tween, clearing queue...")
                            self:ClearTweenQueue()
                            break
                        end
                        
                        wait(0.1)
                    end
                end
            end)
            
            if not success then
                wait(2)
            end
            
            wait(0.5)
        end
        
        self.autoFarmRunning = false
        self.status = "Stopped"
    end)
end

function UI:StopAutoFarm()
    print("Stopping auto farm...")
    
    -- Kill thread first
    if self.autoFarmThread then
        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
    end
    
    self:StopTimedActionsHandler()
    self.autoFarmRunning = false
    self.autoFarmEnabled = false
    self:ClearTweenQueue()
    StopWalking()
    
    self.status = "Stopped"
    self.needsRedraw = true
    
    print("Auto farm stopped")
end

function UI:StartAutoDig()
    if self.autoDigRunning then
        print("Auto dig already running!")
        return
    end
    
    self.autoDigRunning = true
    
    spawn(function()
        while self.autoDigEnabled and self.autoDigRunning do
            -- Check if Roblox window is active
            if isrbxactive() then
                mouse1press()
                wait(10)
                mouse1release()
                wait(0.5)
            else
                warn("isrbxactive = false - auto dig")
                wait(0.5)
            end
        end
        
        self.autoDigRunning = false
        mouse1release()
    end)
end

function UI:StopAutoDig()
    self.autoDigRunning = false
    self.autoDigEnabled = false
    mouse1release()
end

function UI:QueueTween(hrp, targetPos, priority)
    local tweenData = {hrp = hrp, targetPos = targetPos, priority = priority or false}
    
    if priority then
        self:ClearTweenQueue()
        table.insert(self.tweenQueue, tweenData)
        print("Priority tween queued (queue cleared)")
    else
        table.insert(self.tweenQueue, tweenData)
        print("Normal tween queued (queue size: " .. #self.tweenQueue .. ")")
    end
    
    if not self.processingTween then
        self:ProcessTweenQueue()
    else
        warn("Tween Failure 1")
    end
end
function UI:ProcessTweenQueue()
    if self.processingTween then 
        warn("Multiple Not Allowed w-2")
        return 
    end
    
    spawn(function()
        while #self.tweenQueue > 0 and (self.autoFarmEnabled or self.killCoconutCrab or self.trainSnail) do
            self.processingTween = true
            
            local tweenData = table.remove(self.tweenQueue, 1)
            local hrp = tweenData.hrp
            local targetPos = tweenData.targetPos
            
            if not hrp or not hrp.Parent then
                self.processingTween = false
                continue
            end
            
            -- Disable animations RIGHT before tween starts
            print("Disabling animations for tween")
            enableUnwalk()
            
            local startPos = hrp.Position
            local dx = targetPos.X - startPos.X
            local dy = targetPos.Y - startPos.Y
            local dz = targetPos.Z - startPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            local tweenTime = distance / self.tweenSpeed
            local tweenInfo = TweenInfo.new(tweenTime, "Linear", "None")
            self.currentTween = TweenService:Create(hrp, tweenInfo, {Position = targetPos})
            
            self.currentTween:Play()
            
            local startTime = os.clock()
            while self.currentTween and self.currentTween.IsPlaying and (self.autoFarmEnabled or self.killCoconutCrab or self.trainSnail) do
                wait(0.1)
                
                if os.clock() - startTime > tweenTime + 5 then
                    print("Tween timeout")
                    break
                end
            end
            self.currentTween = nil
            
            -- Re-enable animations RIGHT after tween ends
            print("Re-enabling animations after tween")
            disableUnwalk()
            
            wait(0.2)
        end
        
        self.processingTween = false
        self.tweenQueue = {}
    end)
end

function UI:ClearTweenQueue()
    self.tweenQueue = {}
    if self.currentTween then
        self.currentTween:Stop()
        self.currentTween = nil
    end
    self.processingTween = false
    
    -- SAFETY: Re-enable animations when queue is cleared
    disableUnwalk()
end

function UI:UseSprinkler()
    if not isrbxactive() then
        warn("isrbxactive = false - sprinkler")
        return false
    end
    local clickCount = 0
    local keyCode = 0x31
    
    if self.selectedSprinkler:find("Basic") then
        clickCount = 1
    elseif self.selectedSprinkler:find("Silver") then
        clickCount = 2
    elseif self.selectedSprinkler:find("Gold") then
        clickCount = 3
    elseif self.selectedSprinkler:find("Diamond") then
        clickCount = 4
    elseif self.selectedSprinkler:find("Supreme") then
        clickCount = 1
    elseif self.selectedSprinkler:find("None") then
        print("No sprinkler selected")
        return true
    end
    
    if clickCount == 0 then
        print("Invalid sprinkler selection")
        return true
    end
    
    for i = 1, clickCount do
        keypress(keyCode)
        wait(0.1)
        keyrelease(keyCode)
        wait(1.1)
    end
end

function UI:TokenCollector(checkField)
    if checkField == nil then checkField = true end  -- Default to checking field
    
    if not self.autoFarmEnabled then
        return false
    end
    
    if not self.collectTokens then
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local collectibles = game.Workspace:FindFirstChild("Collectibles")
    if not collectibles then return false end
    
    -- Initialize last field center time if not exists
    if not self.lastFieldCenterTime then
        self.lastFieldCenterTime = os.clock()
        self.nextFieldCenterInterval = math.random(60, 90)
    end
    
    -- Initialize all cooldown timers
    if not self.lastBalloonCheckTime then
        self.lastBalloonCheckTime = 0
    end
    if not self.lastCloudTime then
        self.lastCloudTime = 0
    end
    if not self.nextCloudInterval then
        self.nextCloudInterval = math.random(10, 15)
    end
    if not self.lastBubbleCheckTime then
        self.lastBubbleCheckTime = 0
    end
    if not self.lastFlameCheckTime then
        self.lastFlameCheckTime = 0
    end
    
    local tokensCollected = 0
    local recentTokens = {}
    
while self.autoFarmEnabled and self.collectTokens do
        -- CRITICAL: Check for death at start of token collection loop
character = player.Character
if character then
    local humanoid = character:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health <= 0 then
        print("Death detected in TokenCollector, exiting...")
        StopWalking()
        return false
    end
else
    print("No character in TokenCollector, exiting...")
    return false
end

-- CRITICAL: Check if sprout despawned during token collection
-- BUT ONLY if we're actively farming sprouts (not during the 20s collection period)
if self.farmSprouts and self.lastFieldChangeSource == "sprout" and not self.collectingSproutTokens then
    print("DEBUG: Checking for sprouts (hasReachedFieldOnce=true)...")
    local sproutData = self:CheckForSprouts()
    if not sproutData then
        print("✓ Sprout despawned during token collection!")
        StopWalking()
        return false
    end
end

-- CRITICAL: Check if Windy Bee moved to a different field
if self.killWindy then
    local windyBeeData = self:CheckForWindyBee()
    if windyBeeData and windyBeeData.field.Name ~= self.selectedOption then
        print("⚠️ Windy Bee moved to " .. windyBeeData.field.Name .. " during token collection!")
        StopWalking()
        return false
    end
end
 
-- CRITICAL: Check if 20-second sprout collection time is up
if self.sproutCollectionEndTime and os.clock() >= self.sproutCollectionEndTime then
    print("TokenCollector: 20s timer expired, exiting")
    StopWalking()
    return false
end
       
        

        -- CRITICAL: Check if Windy Bee moved to a different field
        if self.killWindy then
            local windyBeeData = self:CheckForWindyBee()
            if windyBeeData and windyBeeData.field.Name ~= self.selectedOption then
                print("⚠️ Windy Bee moved to " .. windyBeeData.field.Name .. " during token collection!")
                StopWalking()
                return false
            end
        end
        
        -- CRITICAL: Check if Vicious Bee despawned or moved during token collection
        if self.killViciousBee then
            local viciousBeeData = self:CheckForViciousBee()
            
            if not viciousBeeData then
                -- Vicious Bee despawned completely!
                print("✓ Vicious Bee despawned during token collection! Exiting to main loop...")
                StopWalking()
                return false
            elseif viciousBeeData.field.Name ~= self.selectedOption then
                -- Vicious Bee moved to different field
                print("⚠️ Vicious Bee moved to " .. viciousBeeData.field.Name .. " during token collection!")
                StopWalking()
                return false
            end
        end

        local currentTime = os.clock()
        
        -- ============================================================
        -- POLLEN CHECK
        -- ============================================================
        local coreStats = player:FindFirstChild("CoreStats")
        if coreStats then
            local pollen = coreStats:FindFirstChild("Pollen")
            local capacity = coreStats:FindFirstChild("Capacity")
            if pollen and capacity then
                local pollenValue = pollen.Value
                local capacityValue = capacity.Value
                
                if pollenValue >= capacityValue then
                    print("Pollen full during token collection! Exiting to return to hive...")
                    StopWalking()
                    return true
                end
            end
        end

        -- ============================================================
        -- BALLOON CHECK (5 second cooldown)
        -- ============================================================
        if self.farmUnderBalloons then
            if currentTime - self.lastBalloonCheckTime >= 5 then
                local balloon = self:FindBalloonInField()
                if balloon then
                    print("✓ Balloon detected, farming under it...")
                    StopWalking()
                    self:FarmUnderBalloon(balloon)
                end
                self.lastBalloonCheckTime = currentTime
            end
        end

        -- ============================================================
        -- CLOUD CHECK (10-15 second cooldown)
        -- ============================================================
        if self.farmUnderClouds then
            if currentTime - self.lastCloudTime >= self.nextCloudInterval then
                local cloud = self:FindCloudInField()
                if cloud then
                    print("✓ Cloud detected, walking under it...")
                    StopWalking()
                    self:FarmUnderCloud(cloud)
                    self.nextCloudInterval = math.random(10, 15)
                else
                    self.lastCloudTime = currentTime
                    self.nextCloudInterval = 2
                end
            end
        end
        
        -- ============================================================
        -- BUBBLE CHECK (3 second cooldown, only if 3 or fewer)
        -- ============================================================
        if self.farmBubbles then
            if currentTime - self.lastBubbleCheckTime >= 3 then
                local bubbles = self:CheckForBubblesInField()
                if bubbles and #bubbles > 0 and #bubbles <= 3 then
                    print("✓ Found " .. #bubbles .. " bubbles, farming...")
                    StopWalking()
                    self:FarmBubbles(bubbles)
                end
                self.lastBubbleCheckTime = currentTime
            end
        end
        
        -- ============================================================
        -- FLAME CHECK (6 second cooldown)
        -- ============================================================
        if self.farmFlames then
            if currentTime - self.lastFlameCheckTime >= 6 then
                local flames = self:CheckForFlamesInField()
                if flames and #flames > 0 then
                    print("✓ Found " .. #flames .. " flames, farming...")
                    StopWalking()
                    self:FarmFlames(flames)
                end
                self.lastFlameCheckTime = currentTime
            end
        end
        
       -- ============================================================
        -- FIELD CHECK
        -- ============================================================
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local hrpPos = hrp.Position
                    local fieldPos = targetZone.Position
                    local fieldSize = targetZone.Size
                    
                    local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                    local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                    local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                    
                    local inField = withinX and withinZ and withinY
                    
                    if not inField then
                        -- If farming sprouts, just walk back to field center
                        if self.farmSprouts and self.lastFieldChangeSource == "sprout" then
                            print("Left field during sprout farming, walking back to center...")
                            local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 5, fieldPos.Z)
                            WalkTo(centerPos)
                            WaitForArrival(10, 10)
                            StopWalking()
                            wait(0.5)
                            -- Continue token collection, don't exit
                        else
                            print("Left field during token collection, returning to auto farm")
                            StopWalking()
                            return false
                        end
                    end
                end
            end
        end
        
        -- ============================================================
        -- FIELD CENTER RETURN
        -- ============================================================
        if currentTime - self.lastFieldCenterTime >= self.nextFieldCenterInterval then
            print("Returning to field center...")
            self.status = "Returning to center"
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local centerPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                    WalkTo(centerPos)
                    WaitForArrival(10, 10)
                    StopWalking()
                    wait(0.5)
                end
            end
            
            self.lastFieldCenterTime = os.clock()
            self.nextFieldCenterInterval = math.random(60, 90)
            recentTokens = {}
        end
        
        -- ============================================================
        -- TOKEN COLLECTION
        -- ============================================================
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end
        local hrpPos = hrp.Position
        
        local closestToken = nil
        local closestDistance = math.huge
        
        for _, token in pairs(collectibles:GetChildren()) do
            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                local tokenPos = token.Position
                if tokenPos then
                    local isRecent = false
                    for _, recentPos in ipairs(recentTokens) do
                        local dx = math.abs(tokenPos.X - recentPos.X)
                        local dy = math.abs(tokenPos.Y - recentPos.Y)
                        local dz = math.abs(tokenPos.Z - recentPos.Z)
                        if dx < 3 and dy < 3 and dz < 3 then
                            isRecent = true
                            break
                        end
                    end
                    
                    if not isRecent then
                        local dy = math.abs(hrpPos.Y - tokenPos.Y)
                        if dy <= 10 then
                            local dx = hrpPos.X - tokenPos.X
                            local dz = hrpPos.Z - tokenPos.Z
                            local distSquared = dx * dx + dz * dz
                            
                            if distSquared < 2500 and distSquared < closestDistance then
                                closestDistance = distSquared
                                closestToken = tokenPos
                            end
                        end
                    end
                end
            end
        end
        
        -- TOKEN COLLECTION OR WAIT
        if closestToken then
            tokensCollected = tokensCollected + 1
            self.status = "Token #" .. tokensCollected
            
            WalkTo(closestToken)
            
            local startTime = os.clock()
            
            while IsWalking() and self.autoFarmEnabled do
                -- Check for death during token walk
                character = player.Character
                if character then
                    local humanoid = character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health <= 0 then
                        print("Death detected while walking to token, exiting...")
                        StopWalking()
                        return false
                    end
                else
                    print("No character while walking to token, exiting...")
                    StopWalking()
                    return false
                end
                
                if os.clock() - startTime > 3 then
                    StopWalking()
                    break
                end
                
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local currentPos = hrp.Position
                    local dx = currentPos.X - closestToken.X
                    local dz = currentPos.Z - closestToken.Z
                    local distSquared = dx * dx + dz * dz
                    
                    if distSquared < 25 then
                        StopWalking()
                        break
                    end
                end
                
                wait(0.1)
            end
            
            StopWalking()
            
            table.insert(recentTokens, closestToken)
            if #recentTokens > 10 then
                table.remove(recentTokens, 1)
            end
        else
            -- No token found - clear recent list if needed
            if #recentTokens > 0 then
                print("No new tokens found, clearing recent list...")
                recentTokens = {}
            end
        end
        
        wait(0.05)
    end
    
    return tokensCollected > 0
end

function UI:CheckForThornsNearby(maxDistance)
    maxDistance = maxDistance or 4
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if not particles then return nil end
    
    local hrpPos = hrp.Position
    local closestThorn = nil
    local closestDistance = math.huge
    
    for _, thorn in pairs(particles:GetChildren()) do
        if thorn.Name == "Thorns" and thorn:IsA("MeshPart") then
            local thornPos = thorn.Position
            local dx = hrpPos.X - thornPos.X
            local dz = hrpPos.Z - thornPos.Z
            local distance = math.sqrt(dx * dx + dz * dz)
            
            if distance < maxDistance and distance < closestDistance then
                closestDistance = distance
                closestThorn = {position = thornPos, distance = distance}
            end
        end
    end
    
    return closestThorn
end

function UI:CheckForBlooms()
    print("=== BLOOM CHECK START ===")
    
    if not self.autoGrindBlooms or not self.autoFarmEnabled then
        print("DEBUG: Bloom check skipped (disabled)")
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    -- Get current field info first
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    print("DEBUG: Searching for blooms in " .. self.selectedOption)
    
    -- Method 1: Check Happenings.PoppablePlants.Blooms
    local happenings = game.Workspace:FindFirstChild("Happenings")
    if happenings then
        print("✓ Found Happenings")
        
        local poppablePlants = happenings:FindFirstChild("PoppablePlants")
        if poppablePlants then
            print("✓ Found PoppablePlants")
            
            local bloomsFolder = poppablePlants:FindFirstChild("Blooms")
            if bloomsFolder then
                print("✓ Found Blooms folder")
                local bloomCount = 0
                
                for _, bloomModel in pairs(bloomsFolder:GetChildren()) do
                    if bloomModel:IsA("Model") and bloomModel.Name == "Blooms" then
                        bloomCount = bloomCount + 1
                        local stem = bloomModel:FindFirstChild("Stem")
                        if stem and stem:IsA("BasePart") then
                            local stemPos = stem.Position
                            
                            local dx = math.abs(stemPos.X - fieldPos.X)
                            local dz = math.abs(stemPos.Z - fieldPos.Z)
                            local dy = math.abs(stemPos.Y - fieldPos.Y)
                            
                            local withinX = dx <= fieldSize.X / 2
                            local withinZ = dz <= fieldSize.Z / 2
                            local withinY = dy <= 50
                            
                            if withinX and withinZ and withinY then
                                print("✓✓✓ FOUND BLOOM IN FIELD (Method 1)!")
                                return stem
                            end
                        end
                    end
                end
                
                print("DEBUG: Found " .. bloomCount .. " blooms but none in current field")
            end
            
            -- Method 2: Search directly in PoppablePlants for Blooms models
            print("DEBUG: Searching PoppablePlants children directly...")
            for _, child in pairs(poppablePlants:GetChildren()) do
                if child:IsA("Model") and child.Name == "Blooms" then
                    print("DEBUG: Found Blooms model directly: " .. child:GetFullName())
                    local stem = child:FindFirstChild("Stem")
                    if stem and stem:IsA("BasePart") then
                        local stemPos = stem.Position
                        
                        local dx = math.abs(stemPos.X - fieldPos.X)
                        local dz = math.abs(stemPos.Z - fieldPos.Z)
                        local dy = math.abs(stemPos.Y - fieldPos.Y)
                        
                        local withinX = dx <= fieldSize.X / 2
                        local withinZ = dz <= fieldSize.Z / 2
                        local withinY = dy <= 50
                        
                        print("DEBUG: Bloom at " .. string.format("(%.1f, %.1f, %.1f)", stemPos.X, stemPos.Y, stemPos.Z))
                        print("DEBUG: Field at " .. string.format("(%.1f, %.1f, %.1f)", fieldPos.X, fieldPos.Y, fieldPos.Z))
                        print("DEBUG: Distance: X=" .. string.format("%.1f", dx) .. " Z=" .. string.format("%.1f", dz))
                        
                        if withinX and withinZ and withinY then
                            print("✓✓✓ FOUND BLOOM IN FIELD (Method 2)!")
                            return stem
                        end
                    end
                end
            end
        end
        
        -- Method 3: Search all descendants of Happenings
        print("DEBUG: Searching all Happenings descendants...")
        for _, descendant in pairs(happenings:GetDescendants()) do
            if descendant:IsA("Model") and descendant.Name == "Blooms" then
                local stem = descendant:FindFirstChild("Stem")
                if stem and stem:IsA("BasePart") then
                    local stemPos = stem.Position
                    
                    local dx = math.abs(stemPos.X - fieldPos.X)
                    local dz = math.abs(stemPos.Z - fieldPos.Z)
                    local dy = math.abs(stemPos.Y - fieldPos.Y)
                    
                    local withinX = dx <= fieldSize.X / 2
                    local withinZ = dz <= fieldSize.Z / 2
                    local withinY = dy <= 50
                    
                    if withinX and withinZ and withinY then
                        print("✓✓✓ FOUND BLOOM IN FIELD (Method 3)!")
                        print("DEBUG: Full path: " .. descendant:GetFullName())
                        return stem
                    end
                end
            end
        end
    end
    
    print("DEBUG: No blooms found in field")
    print("=== BLOOM CHECK END ===")
    return nil
end

-- ============================================================
-- FIXED SPROUT FARMING SYSTEM WITH EXTENSIVE DEBUG
-- ============================================================

function UI:CheckForSprouts()
    print("=== DEBUG SPROUT: CheckForSprouts() CALLED ===")
    
    if not self.farmSprouts then
        print("DEBUG SPROUT: farmSprouts is disabled")
        return nil
    end
    
    if not self.autoFarmEnabled then
        print("DEBUG SPROUT: autoFarmEnabled is disabled")
        return nil
    end
    
    print("DEBUG SPROUT: Both flags enabled, proceeding...")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        print("DEBUG SPROUT: No character")
        return nil 
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        print("DEBUG SPROUT: No HRP")
        return nil 
    end
    
    print("DEBUG SPROUT: Character and HRP found")
    
    local sprouts = game.Workspace:FindFirstChild("Sprouts")
    if not sprouts then
        print("DEBUG SPROUT: ❌ Sprouts folder not found in Workspace")
        return nil
    end

    print("DEBUG SPROUT: ✓ Sprouts folder exists")
    local childCount = #sprouts:GetChildren()
    print("DEBUG SPROUT: Sprouts has " .. childCount .. " children")

    if childCount == 0 then
        print("DEBUG SPROUT: ❌ No children in Sprouts folder")
        return nil
    end

    -- Find all valid sprouts
    local sproutsList = {}
    for _, child in pairs(sprouts:GetChildren()) do
        print("DEBUG SPROUT: Checking child - Name: '" .. child.Name .. "' | ClassName: " .. child.ClassName)
        
        if child.Name == "Sprout" and child:IsA("MeshPart") then
            table.insert(sproutsList, child)
            print("DEBUG SPROUT: ✓ Valid sprout found at " .. tostring(child.Position))
        else
            print("DEBUG SPROUT: ✗ Not a valid sprout")
        end
    end
    
    if #sproutsList == 0 then
        print("DEBUG SPROUT: ❌ No valid sprouts found")
        return nil
    end
    
    print("DEBUG SPROUT: ✓✓✓ Found " .. #sproutsList .. " valid sprout(s)")
    
    -- Find closest sprout to player
    local closestSprout = nil
    local closestDistance = math.huge
    
    for i, sprout in ipairs(sproutsList) do
        local sproutPos = sprout.Position
        local dx = hrp.Position.X - sproutPos.X
        local dy = hrp.Position.Y - sproutPos.Y
        local dz = hrp.Position.Z - sproutPos.Z
        local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
        
        print("DEBUG SPROUT: Sprout #" .. i .. " distance = " .. string.format("%.1f", distance) .. " studs")
        
        if distance < closestDistance then
            closestDistance = distance
            closestSprout = sprout
        end
    end
    
    if not closestSprout then
        print("DEBUG SPROUT: ❌ No closest sprout found (shouldn't happen)")
        return nil
    end
    
    print("DEBUG SPROUT: ✓ Closest sprout is " .. string.format("%.1f", closestDistance) .. " studs away")
    
    -- Find which field the sprout is in
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then 
        print("DEBUG SPROUT: ❌ FlowerZones not found")
        return nil 
    end
    
    print("DEBUG SPROUT: Finding closest field to sprout...")
    
    local closestField = nil
    local closestFieldDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            local sproutPos = closestSprout.Position
            
            local dx = sproutPos.X - fieldPos.X
            local dy = sproutPos.Y - fieldPos.Y
            local dz = sproutPos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestFieldDistance then
                closestFieldDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then
        print("DEBUG SPROUT: ✓✓✓ SPROUT DETECTED IN " .. closestField.Name .. " (distance: " .. string.format("%.1f", closestFieldDistance) .. " studs)")
        return {sprout = closestSprout, field = closestField}
    end
    
    print("DEBUG SPROUT: ❌ No closest field found")
    return nil
end

function UI:GrindBloom(stem)
    print("=== GRIND BLOOM START ===")
    
    if not stem or not stem.Parent then
        print("ERROR: Bloom despawned before grinding")
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        print("ERROR: No character")
        return false 
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        print("ERROR: No HRP")
        return false 
    end
    
    print("Grinding bloom at: " .. tostring(stem.Position))
    self.status = "Grinding Bloom"
    self.needsRedraw = true
    
    -- Walk to bloom
    local bloomPos = Vector3.new(stem.Position.X, stem.Position.Y, stem.Position.Z)
    print("Walking to bloom...")
    WalkTo(bloomPos)
    
    -- Wait for arrival
    local startTime = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startTime > 10 then
            print("Walk timeout!")
            StopWalking()
            break
        end
        
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local currentPos = hrp.Position
            local dx = currentPos.X - bloomPos.X
            local dz = currentPos.Z - bloomPos.Z
            local distSquared = dx * dx + dz * dz
            
            if distSquared < 100 then -- Within 10 studs
                print("Arrived at bloom!")
                StopWalking()
                break
            end
        end
        
        wait(0.1)
    end
    
    StopWalking()
    
    -- Grind the bloom until it despawns
    print("Starting bloom grind loop...")
    local grindStartTime = os.clock()
    
    while self.autoFarmEnabled and self.autoGrindBlooms do
        -- Check if bloom still exists
        if not stem or not stem.Parent then
            print("✓✓✓ Bloom despawned!")
            self.status = "Bloom destroyed"
            self.needsRedraw = true
            wait(1)
            return true
        end
        
        local elapsedTime = os.clock() - grindStartTime
        if elapsedTime > 60 then
            print("Bloom grind timeout (60s)")
            return false
        end
        
        if elapsedTime > 0 and math.floor(elapsedTime) % 5 == 0 then
            print("Still grinding bloom... (" .. string.format("%.0f", elapsedTime) .. "s)")
        end
        
        -- Check if still in field
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local hrpPos = hrp.Position
                    local fieldPos = targetZone.Position
                    local fieldSize = targetZone.Size
                    
                    local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                    local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                    local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                    
                    if not withinX or not withinZ or not withinY then
                        print("Left field during bloom grind")
                        return false
                    end
                end
            end
        end
        
        wait(0.5)
    end
    
    print("Bloom grind loop ended")
    return false
end

function UI:CheckForViciousBee()
    if not self.killViciousBee or not self.autoFarmEnabled then
        return nil
    end
    
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return nil
    end
    
    -- Find Vicious Bee
    local viciousBee = nil
    for _, mob in pairs(monsters:GetChildren()) do
        if string.find(mob.Name, "Vicious") then
            viciousBee = mob
            break
        end
    end
    
    if not viciousBee then
        return nil
    end
    
    -- Get Vicious Bee position
    local viciousBeeHRP = viciousBee:FindFirstChild("HumanoidRootPart")
    if not viciousBeeHRP then
        return nil
    end
    
    local viciousBeePos = viciousBeeHRP.Position
    
    -- Find closest field
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then return nil end
    
    local closestField = nil
    local closestDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            
            local dx = viciousBeePos.X - fieldPos.X
            local dy = viciousBeePos.Y - fieldPos.Y
            local dz = viciousBeePos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestDistance then
                closestDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then
        print("Found Vicious Bee at " .. string.format("(%.1f, %.1f, %.1f)", viciousBeePos.X, viciousBeePos.Y, viciousBeePos.Z))
        print("Nearest field: " .. closestField.Name .. " (" .. string.format("%.1f", closestDistance) .. " studs)")
        return {field = closestField, position = viciousBeePos}
    end
    
    return nil
end

function UI:CheckForWindyBee()
    if not self.killWindy or not self.autoFarmEnabled then
        return nil
    end
    
    local npcBees = game.Workspace:FindFirstChild("NPCBees")
    if not npcBees then
        return nil
    end
    
    local windyBee = npcBees:FindFirstChild("Windy")
    if not windyBee then
        return nil
    end
    
    -- Try to find ANY part to get position
    local windyBeePart = nil
    
    -- Try common part names
    windyBeePart = windyBee:FindFirstChild("HumanoidRootPart") or 
                   windyBee:FindFirstChild("Torso") or 
                   windyBee:FindFirstChild("Head") or
                   windyBee:FindFirstChildWhichIsA("BasePart")
    
    if not windyBeePart then
        print("DEBUG: Windy Bee parts:")
        for _, child in pairs(windyBee:GetChildren()) do
            print("  - " .. child.Name .. " (" .. child.ClassName .. ")")
        end
        return nil
    end
    
    print("DEBUG: Using part: " .. windyBeePart.Name .. " for position")
    
    local windyBeePos = windyBeePart.Position
    
    -- Find closest field
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then return nil end
    
    local closestField = nil
    local closestDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            
            local dx = windyBeePos.X - fieldPos.X
            local dy = windyBeePos.Y - fieldPos.Y
            local dz = windyBeePos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestDistance then
                closestDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then
        print("✓✓✓ Found Windy Bee at " .. string.format("(%.1f, %.1f, %.1f)", windyBeePos.X, windyBeePos.Y, windyBeePos.Z))
        print("✓✓✓ Nearest field: " .. closestField.Name .. " (" .. string.format("%.1f", closestDistance) .. " studs)")
        return {field = closestField, position = windyBeePos}
    end
    
    return nil
end

function UI:CheckForTunnelBear()
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then return false end
    
    local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
    return tunnelBear ~= nil
end

function UI:FightTunnelBear()
    print("=== TUNNEL BEAR AUTO-FARM ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Tunnel Bear")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Tunnel Bear")
        return false
    end
    
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Going to Tunnel Bear"
    self.needsRedraw = true
    
    -- Step 1: Tween to check location
    local checkPos = Vector3.new(276, 6, -41)
    
    print("Tweening to Tunnel Bear check location...")
    self:QueueTween(hrp, checkPos, true)
    
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Tunnel Bear check tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at check location, walking to spawn trigger...")
    wait(0.5)
    
    -- Step 2: Walk to spawn trigger location
    local triggerPos = Vector3.new(422, 6, -48)
    WalkTo(triggerPos)
    
    startWait = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startWait > 30 then
            print("Walk to trigger timeout")
            StopWalking()
            break
        end
        wait(0.1)
    end
    
    StopWalking()
    print("Arrived at trigger location, checking for Tunnel Bear spawn...")
    wait(2)
    
    -- Step 3: Check if Tunnel Bear spawned
    if not self:CheckForTunnelBear() then
        print("Tunnel Bear did not spawn, returning to farming")
        print("Setting 48-hour cooldown even though it didn't spawn...")
        
        if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
            print("Returning to " .. self.selectedOption)
            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then
                                    print("ERROR: Return to field timeout!")
                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            
                            print("✓ Returned to field")
                        end
                    end
                end
            end
        end
        
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return true
    end
    
    print("=== TUNNEL BEAR SPAWNED! ===")
    self.status = "Fighting Tunnel Bear"
    self.needsRedraw = true
    
    -- Step 4: Walk to Tunnel Bear position (+50 on X axis) with live tracking AND death detection
    print("Walking to Tunnel Bear fight position (X+50) with live tracking...")
    
    local lastUpdateTime = os.clock()
    local startWalkTime = os.clock()
    
    -- Start initial walk
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if monsters then
        local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
        if tunnelBear then
            local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
            if tunnelBearHRP then
                local bearPos = tunnelBearHRP.Position
                local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                WalkTo(fightPos)
            end
        end
    end
    
    -- Update position every 0.5 seconds
    while IsWalking() and self.autoFarmEnabled do
        -- CRITICAL: Check for death during walk
        character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                print("=== PLAYER DIED DURING TUNNEL BEAR WALK ===")
                StopWalking()
                
                -- Wait for respawn
                print("Waiting for respawn...")
                local respawned = WaitForRespawn(30)
                
                if respawned then
                    print("✓ Respawned successfully")
                    self.status = "Waiting for bees..."
                    self.needsRedraw = true
                    wait(15)
                    
                    -- Resume walking to Tunnel Bear
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            monsters = game.Workspace:FindFirstChild("Monsters")
                            if monsters then
                                local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                                if tunnelBear then
                                    local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                                    if tunnelBearHRP then
                                        local bearPos = tunnelBearHRP.Position
                                        local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                                        print("Resuming walk to Tunnel Bear at: " .. tostring(fightPos))
                                        WalkTo(fightPos)
                                        startWalkTime = os.clock()  -- Reset timer
                                    end
                                else
                                    print("Tunnel Bear despawned during death, skipping...")
                                    break
                                end
                            end
                        end
                    end
                else
                    print("ERROR: Failed to respawn during Tunnel Bear fight")
                    break
                end
            end
        end
        
        if os.clock() - startWalkTime > 30 then
            print("Walk to bear timeout")
            StopWalking()
            break
        end
        
        -- Update Tunnel Bear position every 0.5 seconds
        if os.clock() - lastUpdateTime >= 0.5 then
            monsters = game.Workspace:FindFirstChild("Monsters")
            if monsters then
                local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                if tunnelBear then
                    local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                    if tunnelBearHRP then
                        local bearPos = tunnelBearHRP.Position
                        local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                        WalkTo(fightPos)
                        print("Updated Tunnel Bear position: X=" .. string.format("%.1f", fightPos.X) .. " Y=" .. string.format("%.1f", fightPos.Y) .. " Z=" .. string.format("%.1f", fightPos.Z))
                    end
                else
                    print("Tunnel Bear despawned during walk")
                    StopWalking()
                    break
                end
            end
            lastUpdateTime = os.clock()
        end
        
        wait(0.1)
    end
    
    StopWalking()
    print("Arrived at fight position, waiting for Tunnel Bear to die...")
    
    -- Step 5: Wait for Tunnel Bear to die (with death detection)
    while self.autoFarmEnabled and self:CheckForTunnelBear() do
        -- Check for death while waiting
        character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                print("=== PLAYER DIED WHILE WAITING FOR TUNNEL BEAR ===")
                
                -- Wait for respawn
                print("Waiting for respawn...")
                local respawned = WaitForRespawn(30)
                
                if respawned then
                    print("✓ Respawned, returning to fight position...")
                    wait(3)
                    
                    -- Walk back to Tunnel Bear if still alive
                    if self:CheckForTunnelBear() then
                        character = player.Character
                        if character then
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                monsters = game.Workspace:FindFirstChild("Monsters")
                                if monsters then
                                    local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                                    if tunnelBear then
                                        local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                                        if tunnelBearHRP then
                                            local bearPos = tunnelBearHRP.Position
                                            local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                                            print("Walking back to Tunnel Bear after death...")
                                            WalkTo(fightPos)
                                            
                                            local walkStart = os.clock()
                                            while IsWalking() and self.autoFarmEnabled do
                                                if os.clock() - walkStart > 30 then
                                                    StopWalking()
                                                    break
                                                end
                                                wait(0.1)
                                            end
                                            StopWalking()
                                            print("✓ Back at fight position")
                                        end
                                    else
                                        print("Tunnel Bear defeated while we were dead!")
                                        break
                                    end
                                end
                            end
                        end
                    else
                        print("Tunnel Bear defeated while we were dead!")
                        break
                    end
                else
                    print("ERROR: Failed to respawn during Tunnel Bear fight")
                    break
                end
            end
        end
        
        wait(0.5)
    end
    
    if self.autoFarmEnabled then
        print("✓ Tunnel Bear defeated!")
        print("Collecting tokens for 10 seconds...")
        
        self.status = "Collecting Tunnel Bear Tokens"
        self.needsRedraw = true
        
        local collectStartTime = os.clock()
        local recentTokens = {}
        
        while self.autoFarmEnabled and (os.clock() - collectStartTime) < 10 do
            local collectibles = game.Workspace:FindFirstChild("Collectibles")
            if collectibles then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local hrpPos = hrp.Position
                        local closestToken = nil
                        local closestDistance = math.huge
                        
                        for _, token in pairs(collectibles:GetChildren()) do
                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                local tokenPos = token.Position
                                if tokenPos then
                                    local isRecent = false
                                    for _, recentPos in ipairs(recentTokens) do
                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                            isRecent = true
                                            break
                                        end
                                    end
                                    
                                    if not isRecent then
                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                        if tdy <= 10 then
                                            local tdx = hrpPos.X - tokenPos.X
                                            local tdz = hrpPos.Z - tokenPos.Z
                                            local distSquared = tdx * tdx + tdz * tdz
                                            
                                            if distSquared < 2500 and distSquared < closestDistance then
                                                closestDistance = distSquared
                                                closestToken = tokenPos
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        if closestToken then
                            WalkTo(closestToken)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                
                                hrp = character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    local currentPos = hrp.Position
                                    local cdx = currentPos.X - closestToken.X
                                    local cdz = currentPos.Z - closestToken.Z
                                    local distSquared = cdx * cdx + cdz * cdz
                                    
                                    if distSquared < 25 then
                                        StopWalking()
                                        break
                                    end
                                end
                                
                                wait(0.05)
                            end
                            
                            StopWalking()
                            
                            table.insert(recentTokens, closestToken)
                            if #recentTokens > 10 then
                                table.remove(recentTokens, 1)
                            end
                        else
                            if #recentTokens > 0 then
                                recentTokens = {}
                            end
                        end
                    end
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()
        print("✓ Token collection complete!")
        print("Next Tunnel Bear in 48 hours")
    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
        print("Returning to " .. self.selectedOption)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("✓ Returned to field")
                    end
                end
            end
        end
    end
    
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:CheckForCommandoChick()
    if not self.killCommandoChick or not self.autoFarmEnabled then
        return false
    end
    
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return false
    end
    
    -- Check if Commando Chick exists
    for _, mob in pairs(monsters:GetChildren()) do
        if string.find(mob.Name, "Commando") then
            print("✓✓✓ COMMANDO CHICK FOUND: " .. mob.Name)
            return true
        end
    end
    
    return false
end

function UI:GetNearbyMonsters(playerPos, maxDistance)
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return {}
    end
    
    local nearbyMonsters = {}
    
    for _, mob in pairs(monsters:GetChildren()) do
        local mobHRP = mob:FindFirstChild("HumanoidRootPart")
        if mobHRP then
            local mobPos = mobHRP.Position
            local dx = playerPos.X - mobPos.X
            local dy = playerPos.Y - mobPos.Y
            local dz = playerPos.Z - mobPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance <= maxDistance then
                table.insert(nearbyMonsters, {mob = mob, position = mobPos, distance = distance})
            end
        end
    end
    
    return nearbyMonsters
end

function UI:SafeTokenCollector(safeDistance)
    if not self.autoFarmEnabled then
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local collectibles = game.Workspace:FindFirstChild("Collectibles")
    if not collectibles then return false end
    
    local tokensCollected = 0
    local recentTokens = {}
    
    while self.autoFarmEnabled and self.killCommandoChick do
        -- CRITICAL: Always check monster distance first
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end
        
        local hrpPos = hrp.Position
        local nearbyMonsters = self:GetNearbyMonsters(hrpPos, 100)
        
        -- Check if player is too close to any monster
        for _, monsterData in ipairs(nearbyMonsters) do
            if monsterData.distance < safeDistance then
                print("⚠️ TOO CLOSE TO MONSTER (" .. string.format("%.1f", monsterData.distance) .. " studs) - MOVING AWAY!")
                StopWalking()
                
                -- Calculate escape direction (away from monster)
                local monsterPos = monsterData.position
                local escapeX = hrpPos.X + (hrpPos.X - monsterPos.X) * 2
                local escapeZ = hrpPos.Z + (hrpPos.Z - monsterPos.Z) * 2
                local escapePos = Vector3.new(escapeX, hrpPos.Y, escapeZ)
                
                WalkTo(escapePos)
                wait(1)
                StopWalking()
                wait(0.5)
                break
            end
        end
        
        -- Find closest safe token
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end
        hrpPos = hrp.Position
        
        local closestToken = nil
        local closestDistance = math.huge
        
        for _, token in pairs(collectibles:GetChildren()) do
            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                local tokenPos = token.Position
                if tokenPos then
                    -- Check if token is too close to any monster
                    local tokenSafe = true
                    for _, monsterData in ipairs(nearbyMonsters) do
                        local monsterPos = monsterData.position
                        local dx = tokenPos.X - monsterPos.X
                        local dz = tokenPos.Z - monsterPos.Z
                        local distToMonster = math.sqrt(dx * dx + dz * dz)
                        
                        if distToMonster < safeDistance then
                            tokenSafe = false
                            break
                        end
                    end
                    
                    if tokenSafe then
                        local isRecent = false
                        for _, recentPos in ipairs(recentTokens) do
                            local dx = math.abs(tokenPos.X - recentPos.X)
                            local dy = math.abs(tokenPos.Y - recentPos.Y)
                            local dz = math.abs(tokenPos.Z - recentPos.Z)
                            if dx < 3 and dy < 3 and dz < 3 then
                                isRecent = true
                                break
                            end
                        end
                        
                        if not isRecent then
                            local dy = math.abs(hrpPos.Y - tokenPos.Y)
                            if dy <= 10 then
                                local dx = hrpPos.X - tokenPos.X
                                local dz = hrpPos.Z - tokenPos.Z
                                local distSquared = dx * dx + dz * dz
                                
                                if distSquared < 2500 and distSquared < closestDistance then
                                    closestDistance = distSquared
                                    closestToken = tokenPos
                                end
                            end
                        end
                    end
                end
            end
        end
        
        -- Collect token if found
        if closestToken then
            tokensCollected = tokensCollected + 1
            self.status = "Commando Token #" .. tokensCollected
            
            WalkTo(closestToken)
            
            local startTime = os.clock()
            while IsWalking() and self.autoFarmEnabled and self.killCommandoChick do
                -- Safety check during walk
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local currentPos = hrp.Position
                    local nearbyCheck = self:GetNearbyMonsters(currentPos, 100)
                    
                    for _, monsterData in ipairs(nearbyCheck) do
                        if monsterData.distance < safeDistance then
                            print("⚠️ MONSTER TOO CLOSE DURING WALK - STOPPING!")
                            StopWalking()
                            break
                        end
                    end
                    
                    local dx = currentPos.X - closestToken.X
                    local dz = currentPos.Z - closestToken.Z
                    local distSquared = dx * dx + dz * dz
                    
                    if distSquared < 25 then
                        StopWalking()
                        break
                    end
                end
                
                if os.clock() - startTime > 3 then
                    StopWalking()
                    break
                end
                
                wait(0.05)
            end
            
            StopWalking()
            
            table.insert(recentTokens, closestToken)
            if #recentTokens > 10 then
                table.remove(recentTokens, 1)
            end
        else
            if #recentTokens > 0 then
                recentTokens = {}
            end
            wait(0.2)
        end
        
        wait(0.05)
    end
    
    return tokensCollected > 0
end

function UI:FindBalloonInField()
    if not self.farmUnderBalloons or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local balloons = game.Workspace:FindFirstChild("Balloons")
    if not balloons then return nil end
    
    local fieldBalloons = balloons:FindFirstChild("FieldBalloons")
    if not fieldBalloons then return nil end
    
    -- Find balloon in current field
    for _, balloon in pairs(fieldBalloons:GetChildren()) do
        local balloonBody = balloon:FindFirstChild("BalloonBody")
        if balloonBody and balloonBody:IsA("BasePart") then
            local balloonPos = balloonBody.Position
            
            local dx = math.abs(balloonPos.X - fieldPos.X)
            local dz = math.abs(balloonPos.Z - fieldPos.Z)
            local dy = math.abs(balloonPos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 100
            
            if withinX and withinZ and withinY then
                print("✓ Found balloon in field: " .. balloon.Name)
                return balloonBody
            end
        end
    end
    
    return nil
end

function UI:FarmUnderBalloon(balloonBody)
    if not balloonBody or not balloonBody.Parent then
        print("ERROR: Invalid balloon body")
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Position under balloon (stay at ground level)
    local balloonPos = balloonBody.Position
    local targetPos = Vector3.new(balloonPos.X, balloonPos.Y, balloonPos.Z)
    
    -- Get the field's Y level
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones and self.selectedOption then
        local targetZone = flowerZones:FindFirstChild(self.selectedOption)
        if targetZone then
            targetPos = Vector3.new(balloonPos.X, targetZone.Position.Y + 5, balloonPos.Z)
        end
    end
    
    print("Moving under balloon to: " .. tostring(targetPos))
    self.status = "Farming Under Balloon"
    self.needsRedraw = true
    
    WalkTo(targetPos)
    
    local startTime = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startTime > 10 then
            print("Walk to balloon timeout")
            StopWalking()
            break
        end
        
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local currentPos = hrp.Position
            local dx = currentPos.X - targetPos.X
            local dz = currentPos.Z - targetPos.Z
            local distSquared = dx * dx + dz * dz
            
            if distSquared < 25 then
                print("Arrived under balloon")
                StopWalking()
                break
            end
        end
        
        wait(0.1)
    end
    
    StopWalking()
    
    print("✓ Under balloon, returning to token collector")
    -- Just return, let TokenCollector handle the rest
    return true
end

function UI:FindCloudInField()
    if not self.farmUnderClouds or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local clouds = game.Workspace:FindFirstChild("Clouds")
    if not clouds then return nil end
    
    -- Find cloud in current field
    for _, cloudInstance in pairs(clouds:GetChildren()) do
        if cloudInstance.Name == "CloudInstance" then
            local plane = cloudInstance:FindFirstChild("Plane")
            if plane and plane:IsA("BasePart") then
                local cloudPos = plane.Position
                
                local dx = math.abs(cloudPos.X - fieldPos.X)
                local dz = math.abs(cloudPos.Z - fieldPos.Z)
                local dy = math.abs(cloudPos.Y - fieldPos.Y)
                
                local withinX = dx <= fieldSize.X / 2
                local withinZ = dz <= fieldSize.Z / 2
                local withinY = dy <= 100
                
                if withinX and withinZ and withinY then
                    print("✓ Found cloud in field")
                    return plane
                end
            end
        end
    end
    
    return nil
end

function UI:FarmUnderCloud(cloudPlane)
    if not cloudPlane or not cloudPlane.Parent then
        print("ERROR: Invalid cloud plane")
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    print("Farming under cloud for 3 seconds...")
    self.status = "Farming Under Cloud"
    self.needsRedraw = true
    
    -- Get the field's Y level once
    local fieldY = nil
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones and self.selectedOption then
        local targetZone = flowerZones:FindFirstChild(self.selectedOption)
        if targetZone then
            fieldY = targetZone.Position.Y + 5
        end
    end
    
    if not fieldY then
        print("ERROR: Could not get field Y position")
        return false
    end
    
    -- Walk under cloud for 3 seconds, continuously updating position
    local walkStartTime = os.clock()
    
    while self.autoFarmEnabled and (os.clock() - walkStartTime) < 3 do
        -- Check if cloud still exists
        if not cloudPlane or not cloudPlane.Parent then
            print("Cloud despawned during farming")
            StopWalking()
            break
        end
        
        -- Get fresh cloud position
        local cloudPos = cloudPlane.Position
        local targetPos = Vector3.new(cloudPos.X, fieldY, cloudPos.Z)
        
        -- Update walk target to follow the cloud
        WalkTo(targetPos)
        
        wait(0.1) -- Update position every 0.1 seconds
    end
    
    StopWalking()
    
    -- Update last cloud time
    self.lastCloudTime = os.clock()
    
    print("✓ Cloud farming complete (3s), resuming normal farming")
    return true
end

function UI:CheckForFlamesInField()
    if not self.farmFlames or not self.autoFarmEnabled then
        return nil
    end
    
    -- Check cooldown timer
    local currentTime = os.clock()
    if self.lastFlameTime and (currentTime - self.lastFlameTime) < 6 then
        -- Still on cooldown
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local playerFlames = game.Workspace:FindFirstChild("PlayerFlames")
    if not playerFlames then 
        return nil 
    end
    
    local flamesInField = {}
    
    -- Find all flames in current field
    for _, flame in pairs(playerFlames:GetChildren()) do
        if flame.Name:match("^Flm%d+") and flame:IsA("BasePart") then
            local flamePos = flame.Position
            
            local dx = math.abs(flamePos.X - fieldPos.X)
            local dz = math.abs(flamePos.Z - fieldPos.Z)
            local dy = math.abs(flamePos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 50
            
            if withinX and withinZ and withinY then
                table.insert(flamesInField, flame)
            end
        end
    end
    
    if #flamesInField > 0 then
        print("✓ Found " .. #flamesInField .. " flame(s) in field")
        return flamesInField
    end
    
    return nil
end

function UI:CheckForFlamesInField()
    if not self.farmFlames or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local playerFlames = game.Workspace:FindFirstChild("PlayerFlames")
    if not playerFlames then 
        return nil 
    end
    
    local flamesInField = {}
    
    -- Find all flames in current field
    for _, flame in pairs(playerFlames:GetChildren()) do
        if flame.Name:match("^Flm%d+") and flame:IsA("BasePart") then
            local flamePos = flame.Position
            
            local dx = math.abs(flamePos.X - fieldPos.X)
            local dz = math.abs(flamePos.Z - fieldPos.Z)
            local dy = math.abs(flamePos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 50
            
            if withinX and withinZ and withinY then
                table.insert(flamesInField, flame)
            end
        end
    end
    
    if #flamesInField > 0 then
        print("✓ Found " .. #flamesInField .. " flame(s) in field")
        return flamesInField
    end
    
    return nil
end

function UI:CheckForBubblesInField()
    if not self.farmBubbles or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if not particles then return nil end
    
    local bubblesInField = {}
    local playerPos = hrp.Position
    
    -- ULTRA STRICT: Only check bubbles within 30 studs of player
    for _, child in pairs(particles:GetChildren()) do
        if child:IsA("BasePart") and child.Name == "Bubble" then
            local bubblePos = child.Position
            
            local dx = bubblePos.X - playerPos.X
            local dz = bubblePos.Z - playerPos.Z
            local distToPlayer = math.sqrt(dx * dx + dz * dz)
            
            -- Only farm bubbles within 30 studs
            if distToPlayer <= 30 then
                table.insert(bubblesInField, child)
                print("Found bubble " .. string.format("%.1f", distToPlayer) .. " studs away")
            end
        end
    end
    
    if #bubblesInField == 0 then
        return nil
    end
    
    print("✓ Found " .. #bubblesInField .. " bubble(s) nearby")
    return bubblesInField
end

function UI:FarmBubbles(bubbles)
    if not bubbles or #bubbles == 0 then
        return false
    end
    
    print("=== FARMING " .. #bubbles .. " BUBBLES ===")
    self.status = "Farming Bubbles"
    self.needsRedraw = true
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Walk to each bubble quickly - no waiting
    for i, bubble in ipairs(bubbles) do
        -- Safety check: make sure bubble exists and has Position
        if not bubble or not bubble.Parent or not bubble.Position then
            print("Bubble " .. i .. " is nil or invalid, skipping...")
            continue
        end
        
        if not self.autoFarmEnabled or not self.farmBubbles then
            wait(0.1)
            return false
        end
        
        local bubblePos = bubble.Position
        
        WalkTo(bubblePos)
        
        local startTime = os.clock()
        while IsWalking() and self.autoFarmEnabled and self.farmBubbles do
            if os.clock() - startTime > 1 then
                StopWalking()
                break
            end
            
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - bubblePos.X
                local dz = currentPos.Z - bubblePos.Z
                local distSquared = dx * dx + dz * dz
                
                if distSquared < 25 then
                    StopWalking()
                    break
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()
    end
end

function UI:StartStatusUpdater()
    if self.statusUpdaterThread then
        task.cancel(self.statusUpdaterThread)
        self.statusUpdaterThread = nil
    end
    
    self.statusUpdaterThread = task.spawn(function()
        
        while self.isRunning do
            if self.autoFarmEnabled then
                local success = pcall(function()
                    local player = game.Players.LocalPlayer
                    local character = player.Character
                    
                    if character then
                        local coreStats = player:FindFirstChild("CoreStats")
                        if coreStats then
                            local pollen = coreStats:FindFirstChild("Pollen")
                            local capacity = coreStats:FindFirstChild("Capacity")
                            
                            if pollen and capacity then
                                local pollenValue = math.floor(pollen.Value)
                                local capacityValue = math.floor(capacity.Value)
                                local percentage = math.floor((pollenValue / capacityValue) * 100)
                                
                                local newStatus = string.format("Farming | %d%% (%d/%d)", percentage, pollenValue, capacityValue)
                                
                                if self.status ~= newStatus then
                                    self.status = newStatus
                                    self.needsRedraw = true
                                end
                            end
                        end
                    end
                end)
                
                if not success then
                    warn("Status updater error (non-fatal)")
                end
            end
            
            task.wait(1)
        end
        
        self.statusUpdaterThread = nil
    end)
end

function UI:WalkToHive()
    self.status = "Finding Hive"
    self.needsRedraw = true
    
    spawn(function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        
        if not character then
            self.status = "Error: No character"
            self.needsRedraw = true
            return
        end
        
        local honeycombs = game.Workspace:FindFirstChild("Honeycombs")
        if not honeycombs then
            print("ERROR: Honeycombs not found!")
            self.status = "No Honeycombs!"
            self.needsRedraw = true
            return
        end
        
        local maxAttempts = 6
        local attemptCount = 0
        local claimed = false
        
        while not claimed and attemptCount < maxAttempts do
            attemptCount = attemptCount + 1
            
            local hives = honeycombs:GetChildren()
            local availableHive = nil
            
            for _, hive in pairs(hives) do
                local owner = hive:FindFirstChild("Owner")
                if owner then
                    local ownerValue = tostring(owner.Value)
                    if owner.Value == player then
                        self.status = "Hive Owned"
                        self.needsRedraw = true
                        return
                    elseif ownerValue:find("Unreadable_name") then
                        availableHive = hive
                        break
                    end
                end
            end
            
            if not availableHive then
                self.status = "No hives available"
                self.needsRedraw = true
                return
            end
            self.status = "Claiming " .. availableHive.Name
            self.needsRedraw = true
            local hivePart = availableHive:FindFirstChild("Display") or availableHive:FindFirstChildWhichIsA("BasePart")
            if not hivePart then
                wait(1)
            else
                -- In the WalkToHive function, change this line:
local hivePos = Vector3.new(hivePart.Position.X, hivePart.Position.Y, hivePart.Position.Z - 15)


local hivePos = Vector3.new(hivePart.Position.X, 4, hivePart.Position.Z - 15)
                
                local success = WalkTo(hivePos)
                if not success then
                    print("ERROR: WalkTo failed!")
                    wait(1)
                else
                    self.status = "Walking to " .. availableHive.Name
                    self.needsRedraw = true
                    
                    local arrived = WaitForArrival(30)
                    
                    StopWalking()
                    wait(0.5)
                    
                    if arrived then
                        self.status = "Claiming hive..."
                        self.needsRedraw = true
                        
                        wait(0.5)
                        
                        keypress(0x45)
                        wait(0.2)
                        keyrelease(0x45)
                        
                        wait(3)
                        
                        local owner = availableHive:FindFirstChild("Owner")
if owner then
    local ownerStr = tostring(owner.Value)
    if not ownerStr:find("Unreadable_name") then
        self.status = "Hive Claimed!"
        self.needsRedraw = true
        claimed = true
    else
        self.status = "Claim failed, retrying..."
        self.needsRedraw = true
    end
end
                    else
                        print("Walk timeout")
                    end
                    
                    wait(1)
                end
            end
        end
        
        if not claimed then
            self.status = "Claim failed"
            self.needsRedraw = true
        end
    end)
end

function UI:StartCoconutCrab()
    if self.coconutCrabRunning then
        print("Coconut Crab already running!")
        return
    end
    
    self.coconutCrabRunning = true
    self.status = "Coconut Crab Active"
    self.needsRedraw = true
    
    spawn(function()
        local targetPosition = Vector3.new(-312, 115, 511)
        local initialCrabCount = 0
        
        local monsters = game.Workspace:FindFirstChild("Monsters")
        if monsters then
            for _, mob in pairs(monsters:GetChildren()) do
                if mob.Name == "Coconut Crab (Lvl 12)" then
                    initialCrabCount = initialCrabCount + 1
                end
            end
        end
        
        print("Initial Coconut Crab count: " .. initialCrabCount)
        
        while self.killCoconutCrab and self.coconutCrabRunning do
            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if not character then
                wait(1)
                continue
            end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                wait(1)
                continue
            end
            
            local currentPos = hrp.Position
            local dx = currentPos.X - targetPosition.X
            local dy = currentPos.Y - targetPosition.Y
            local dz = currentPos.Z - targetPosition.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance > 15 then
                self.status = "Going to Coconut Crab"
                self.needsRedraw = true
                self:QueueTween(hrp, targetPosition, true)
                while self.processingTween and self.killCoconutCrab do
                    wait(0.1)
                end
            end
            
            local currentCrabCount = 0
            monsters = game.Workspace:FindFirstChild("Monsters")
            if monsters then
                for _, mob in pairs(monsters:GetChildren()) do
                    if mob.Name == "Coconut Crab (Lvl 12)" then
                        currentCrabCount = currentCrabCount + 1
                    end
                end
            end
            
            print("Crab check: Current=" .. currentCrabCount .. " | Initial=" .. initialCrabCount)
            
            if currentCrabCount > initialCrabCount then
                self.status = "Fighting Coconut Crab (" .. currentCrabCount .. ")"
                self.needsRedraw = true
                
                print("New crab detected! Waiting for kill...")
                
                local lastCrabCheck = os.clock()
                local loopCount = 0
                
                while self.killCoconutCrab and currentCrabCount > initialCrabCount do
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.Position = targetPosition
                        hrp.Velocity = Vector3.new(0, 0, 0)
                    end
                    
                    loopCount = loopCount + 1
                    
                    if os.clock() - lastCrabCheck >= 0.5 then
                        currentCrabCount = 0
                        monsters = game.Workspace:FindFirstChild("Monsters")
                        if monsters then
                            for _, mob in pairs(monsters:GetChildren()) do
                                if mob.Name == "Coconut Crab (Lvl 12)" then
                                    currentCrabCount = currentCrabCount + 1
                                end
                            end
                        end
                        lastCrabCheck = os.clock()
                        print("Crab recount: " .. currentCrabCount .. " (loop #" .. loopCount .. ")")
                    end
                    
                    wait(0.03)
                end
                
                print("Crab killed!")
                
                initialCrabCount = currentCrabCount
            else
                print("No new crab, going straight to farming")
            end
            
            self.status = "Going to Coconut Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local coconutField = flowerZones:FindFirstChild("Coconut Field")
                if coconutField then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(coconutField.Position.X, coconutField.Position.Y + 5, coconutField.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        while self.processingTween and self.killCoconutCrab do
                            wait(0.1)
                        end
                        
                        self.status = "Farming Coconut Field (30s)"
                        self.needsRedraw = true
                        
                        print("Farming Coconut Field for 30 seconds...")
                        
                        local farmStartTime = os.clock()
                        local recentTokens = {}
                        
                        while self.killCoconutCrab and (os.clock() - farmStartTime) < 30 do
                            local collectibles = game.Workspace:FindFirstChild("Collectibles")
                            if collectibles then
                                character = player.Character
                                if character then
                                    hrp = character:FindFirstChild("HumanoidRootPart")
                                    if hrp then
                                        local hrpPos = hrp.Position
                                        local closestToken = nil
                                        local closestDistance = math.huge
                                        
                                        for _, token in pairs(collectibles:GetChildren()) do
                                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                                local tokenPos = token.Position
                                                if tokenPos then
                                                    local isRecent = false
                                                    for _, recentPos in ipairs(recentTokens) do
                                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                                            isRecent = true
                                                            break
                                                        end
                                                    end
                                                    
                                                    if not isRecent then
                                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                                        if tdy <= 10 then
                                                            local tdx = hrpPos.X - tokenPos.X
                                                            local tdz = hrpPos.Z - tokenPos.Z
                                                            local distSquared = tdx * tdx + tdz * tdz
                                                            
                                                            if distSquared < 2500 and distSquared < closestDistance then
                                                                closestDistance = distSquared
                                                                closestToken = tokenPos
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        
                                        if closestToken then
                                            WalkTo(closestToken)
                                            
                                            local startTime = os.clock()
                                            while IsWalking() and self.killCoconutCrab do
                                                if os.clock() - startTime > 3 then
                                                    StopWalking()
                                                    break
                                                end
                                                
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local currentPos = hrp.Position
                                                    local cdx = currentPos.X - closestToken.X
                                                    local cdz = currentPos.Z - closestToken.Z
                                                    local distSquared = cdx * cdx + cdz * cdz
                                                    
                                                    if distSquared < 25 then
                                                        StopWalking()
                                                        break
                                                    end
                                                end
                                                
                                                wait(0.05)
                                            end
                                            
                                            StopWalking()
                                            
                                            table.insert(recentTokens, closestToken)
                                            if #recentTokens > 10 then
                                                table.remove(recentTokens, 1)
                                            end
                                        else
                                            if #recentTokens > 0 then
                                                recentTokens = {}
                                            end
                                        end
                                    end
                                end
                            end
                            
                            wait(0.05)
                        end
                        
                        print("Finished farming Coconut Field, looping back...")
                        StopWalking()
                    end
                end
            end
            
            wait(0.5)
        end
        
        self.coconutCrabRunning = false
        self.status = "Stopped"
        self.needsRedraw = true
    end)
end

function UI:StopCoconutCrab()
    self.coconutCrabRunning = false
    self.killCoconutCrab = false
    self:ClearTweenQueue()
    StopWalking()
    self.status = "Stopped"
    self.needsRedraw = true
end

function UI:StartTrainSnail()
    if self.trainSnailRunning then
        print("Train Snail already running!")
        return
    end
    self.trainSnailRunning = true
    self.status = "Train Snail Active"
    self.needsRedraw = true
    spawn(function()
        while self.trainSnail and self.trainSnailRunning do
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then
                    wait(1)
                    return
                end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then
                    wait(1)
                    return
                end
                
                local flowerZones = game.Workspace.FlowerZones
                if not flowerZones then
                    wait(1)
                    return
                end
                
                local stumpField = flowerZones:FindFirstChild("Stump Field")
                if not stumpField then
                    print("ERROR: Stump Field not found")
                    wait(5)
                    return
                end
                
                local hrpPos = hrp.Position
                local fieldPos = stumpField.Position
                local fieldSize = stumpField.Size
                local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                local inField = withinX and withinZ and withinY
                
                if inField then
                    local innerZoneX = fieldSize.X / 4 
                    local innerZoneZ = fieldSize.Z / 4
                    local withinInnerX = math.abs(hrpPos.X - fieldPos.X) <= innerZoneX
                    local withinInnerZ = math.abs(hrpPos.Z - fieldPos.Z) <= innerZoneZ
                    local inInnerZone = withinInnerX and withinInnerZ
                    
                    if not inInnerZone then
                        self.status = "Returning to Safe Zone"
                        self.needsRedraw = true
                        
                        StopWalking()
                        
                        local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 10, fieldPos.Z)
                        self:QueueTween(hrp, centerPos, true)
                        
                        while self.processingTween and self.trainSnail do
                            wait(0.1)
                        end
                        wait(0.5)
                    end
                    self.status = "Training at Stump Field"
                    self.needsRedraw = true
                    local collectibles = game.Workspace:FindFirstChild("Collectibles")
                    if collectibles then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local hrpPos = hrp.Position
                            local closestToken = nil
                            local closestDistance = math.huge
                            
                            for _, token in pairs(collectibles:GetChildren()) do
                                if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                    local tokenPos = token.Position
                                    if tokenPos and type(tokenPos) == "userdata" then
                                        local posX, posY, posZ = GetPosition(token)
                                        if posX and posY and posZ then
                                            local tokenInnerX = math.abs(posX - fieldPos.X) <= innerZoneX
                                            local tokenInnerZ = math.abs(posZ - fieldPos.Z) <= innerZoneZ
                                            
                                            if tokenInnerX and tokenInnerZ then
                                                local dy = math.abs(hrpPos.Y - posY)
                                                if dy <= 10 then
                                                    local dx = hrpPos.X - posX
                                                    local dz = hrpPos.Z - posZ
                                                    local distSquared = dx * dx + dz * dz
                                                    
                                                    if distSquared < 2500 and distSquared < closestDistance then
                                                        closestDistance = distSquared
                                                        closestToken = Vector3.new(posX, posY, posZ)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            if closestToken then
                                WalkTo(closestToken)
                                wait(0.5)
                                StopWalking()
                            else
                                wait(0.2)
                            end
                        end
                    else
                        wait(0.2)
                    end
                else
                    self.status = "Going to Stump Field"
                    self.needsRedraw = true
                    local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 10, fieldPos.Z)
                    self:QueueTween(hrp, centerPos, true)
                    
                    while self.processingTween and self.trainSnail do
                        wait(0.1)
                    end
                end
            end)
            
            if not success then
                print("ERROR in Train Snail: " .. tostring(err))
                wait(2)
            end
            
            wait(0.05)
        end
        
        self.trainSnailRunning = false
        self.status = "Stopped"
    end)
end

function UI:StopTrainSnail()
    self.trainSnailRunning = false
    self.trainSnail = false
    self:ClearTweenQueue()
    StopWalking()
    self.status = "Stopped"
    self.needsRedraw = true
end

-- ============================================================
-- TIMED ACTIONS SYSTEM
-- ============================================================

function UI:StartTimedActionsHandler()
    if self.timedActionsThread then
        task.cancel(self.timedActionsThread)
        self.timedActionsThread = nil
    end
    
    if not self.lastTunnelBearTime then
        self.lastTunnelBearTime = os.clock() - 172800  -- 48 hours ago
    end

    if not self.lastWealthClockTime then
        self.lastWealthClockTime = os.clock() - 3600  -- 1 hour ago
    end
    
    if not self.lastAntPassTime then
        self.lastAntPassTime = os.clock() - 10800  -- 3 hours ago
    end
    
    if not self.lastHoneyStormTime then
        self.lastHoneyStormTime = os.clock() - 14400  -- 4 hours ago
    end
    
    if not self.lastGlueTime then
        self.lastGlueTime = os.clock() - 3600  -- 1 hour ago
    end
    
    if not self.lastKingBeetleTime then
        self.lastKingBeetleTime = os.clock() - 86400  -- 24 hours ago
    end
    
    if not self.lastCommandoChickTime then
        self.lastCommandoChickTime = os.clock() - 1800  -- 30 minutes ago
    end

    self.timedActionsThread = spawn(function()
        while self.autoFarmEnabled do
            if self.pausedForTimedAction then
                wait(1)
                continue
            end
            
            if not self.autoFarmEnabled then
                break
            end
            
            local currentTime = os.clock()
            
            if self.collectWealthClock then
                if currentTime - self.lastWealthClockTime >= 3600 then
                    if self.autoFarmEnabled then
                        print("=== WEALTH CLOCK TIMER TRIGGERED ===")
                        self:CollectWealthClock()
                        self.lastWealthClockTime = currentTime
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            if self.killTunnelBear then
                if currentTime - self.lastTunnelBearTime >= 172800 then  -- 172800 seconds = 48 hours
                    if self.autoFarmEnabled then
                        print("=== TUNNEL BEAR TIMER TRIGGERED ===")
                        local success = self:FightTunnelBear()
                        if success then
                            self.lastTunnelBearTime = currentTime
                        end
                    end
                end
            end

            if self.collectAntPass then
                if currentTime - self.lastAntPassTime >= 10800 then
                    if self.autoFarmEnabled then
                        print("=== ANT PASS TIMER TRIGGERED ===")
                        self:CollectAntPass()
                        self.lastAntPassTime = currentTime
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            if self.summonHoneyStorm then
                if currentTime - self.lastHoneyStormTime >= 14400 then
                    if self.autoFarmEnabled then
                        print("=== HONEY STORM TIMER TRIGGERED ===")
                        self:SummonHoneyStorm()
                        self.lastHoneyStormTime = currentTime
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            if self.collectGlue then
                if currentTime - self.lastGlueTime >= 3600 then
                    if self.autoFarmEnabled then
                        print("=== GLUE COLLECTION TIMER TRIGGERED ===")
                        self:CollectGlue()
                        self.lastGlueTime = currentTime
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            if self.killKingBeetle then
                -- Initialize timer on first check if not set
                if not self.lastKingBeetleTime or self.lastKingBeetleTime == 0 then
                    self.lastKingBeetleTime = currentTime - 86400  -- Set to 24 hours ago for immediate first check
                end
                
                if currentTime - self.lastKingBeetleTime >= 86400 then
                    if self.autoFarmEnabled then
                        print("=== KING BEETLE TIMER TRIGGERED ===")
                        local success = self:KillKingBeetle()
                        if success then
                            self.lastKingBeetleTime = currentTime  -- Only set timer after successful kill
                        end
                    end
                end
            end
           

            wait(3)
            if not self.autoFarmEnabled then break end
            
            if self.killCommandoChick then
                if currentTime - self.lastCommandoChickTime >= 1800 then  -- 1800 seconds = 30 minutes
                    if self.autoFarmEnabled then
                        print("=== COMMANDO CHICK TIMER TRIGGERED ===")
                        self:FightCommandoChick()
                        self.lastCommandoChickTime = currentTime
                    end
                end
            end
 
            wait(10)
        end
        
        print("Timed actions handler stopped")
        self.timedActionsThread = nil
    end)
end

function UI:StopTimedActionsHandler()
    if self.timedActionsThread then
        task.cancel(self.timedActionsThread)
        self.timedActionsThread = nil
    end
end

function UI:CollectWealthClock()
    print("=== COLLECTING WEALTH CLOCK ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Wealth Clock")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Wealth Clock")
        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Collecting Wealth Clock"
    self.needsRedraw = true
    
    -- Target position
    local wealthClockPos = Vector3.new(329, 58, 191)
    
    print("Tweening to Wealth Clock...")
    self:QueueTween(hrp, wealthClockPos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Wealth Clock tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at Wealth Clock, waiting 1 second...")
    wait(1)
    
    if self.autoFarmEnabled then
        print("Pressing E to collect Wealth Clock...")
        keypress(0x45)
        wait(0.2)
        keyrelease(0x45)
        
        print("Waiting 1 second after pressing E...")
        wait(1)
        
        print("✓ Wealth Clock collected!")
        print("Next collection in 1 hour")
    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
        print("Returning to " .. self.selectedOption)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("✓ Returned to field")
                    end
                end
            end
        end
    end
    
    -- Restore token collection and resume auto farm
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:CollectAntPass()
    print("=== COLLECTING ANT PASS ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Ant Pass")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Ant Pass")
        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Collecting Ant Pass"
    self.needsRedraw = true
    
    -- Target position
    local antPassPos = Vector3.new(125, 32, 495)
    
    print("Tweening to Ant Pass...")
    self:QueueTween(hrp, antPassPos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Ant Pass tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at Ant Pass, waiting 1 second...")
    wait(1)
    
    if self.autoFarmEnabled then
        print("Pressing E to collect Ant Pass...")
        keypress(0x45)
        wait(0.2)
        keyrelease(0x45)
        
        print("Waiting 1 second after pressing E...")
        wait(1)
        
        print("✓ Ant Pass collected!")
        print("Next collection in 3 hours")
    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
        print("Returning to " .. self.selectedOption)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("✓ Returned to field")
                    end
                end
            end
        end
    end
    
    -- Restore token collection and resume auto farm
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:SummonHoneyStorm()
    print("=== SUMMONING HONEY STORM ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Honey Storm")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Honey Storm")
        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Summoning Honey Storm"
    self.needsRedraw = true
    
    -- Target position
    local honeyStormPos = Vector3.new(233, 34, 163)
    
    print("Tweening to Honey Storm...")
    self:QueueTween(hrp, honeyStormPos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Honey Storm tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at Honey Storm, waiting 1 second...")
    wait(1)
    
    if self.autoFarmEnabled then
        print("Pressing E to summon Honey Storm...")
        keypress(0x45)
        wait(0.2)
        keyrelease(0x45)
        
        print("Waiting 1 second after pressing E...")
        wait(1)
        
        print("✓ Honey Storm summoned!")
        print("Next summon in 4 hours")
    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
        print("Returning to " .. self.selectedOption)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("✓ Returned to field")
                    end
                end
            end
        end
    end
    
    -- Restore token collection and resume auto farm
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:CollectGlue()
    print("=== COLLECTING GLUE ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Glue")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Glue")
        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Collecting Glue"
    self.needsRedraw = true
    
    -- Target position (first location)
    local gluePos = Vector3.new(15, 92, 489)
    
    print("Tweening to Glue dispenser...")
    self:QueueTween(hrp, gluePos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Glue tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at Glue dispenser, waiting 2 seconds...")
    wait(2)
    
    if self.autoFarmEnabled then
        print("Pressing 2 to collect Glue...")
        keypress(0x32) -- 0x32 is the key code for "2"
        wait(0.2)
        keyrelease(0x32)
        
        print("Waiting for glue collection...")
        wait(2)
        
        -- Check if Y position is higher than 10,000
        character = player.Character
        if character then
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentY = hrp.Position.Y
                print("Current Y position: " .. currentY)
                
                if currentY > 10000 then
                    print("Y > 10k, tweening to sky location...")
                    local skyPos = Vector3.new(270, 25257, -723)
                    
                    self:QueueTween(hrp, skyPos, true)
                    
                    local startWait = os.clock()
                    while self.processingTween and self.autoFarmEnabled do
                        if os.clock() - startWait > 120 then
                            print("ERROR: Sky tween timeout!")
                            self:ClearTweenQueue()
                            break
                        end
                        wait(0.1)
                    end
                    
                    print("Arrived at sky location, waiting 2 seconds...")
                    wait(2)
                    
                    if self.autoFarmEnabled then
                        print("Pressing E...")
                        keypress(0x45)
                        wait(0.2)
                        keyrelease(0x45)
                        
                        wait(1)
                    end
                end
            end
        end
        
        -- Kill player using memory write
        print("Resetting player...")
        ResetPlayer()
        
        -- Wait for respawn
        print("Waiting for respawn...")
        local respawned = WaitForRespawn(30)
        
        if respawned then
            print("✓ Respawned after glue collection")
            self.status = "Waiting for bees..."
            self.needsRedraw = true
            wait(15)
            
            -- Return to field after respawn
            if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
                print("Returning to " .. self.selectedOption)
                self.status = "Returning to Field"
                self.needsRedraw = true
                
                local flowerZones = game.Workspace.FlowerZones
                if flowerZones then
                    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                    if targetZone then
                        player = game.Players.LocalPlayer
                        character = player.Character
                        if character then
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                                self:QueueTween(hrp, fieldPos, true)
                                
                                local startWait = os.clock()
                                while self.processingTween and self.autoFarmEnabled do
                                    if os.clock() - startWait > 60 then
                                        print("ERROR: Return to field timeout!")
                                        self:ClearTweenQueue()
                                        break
                                    end
                                    wait(0.1)
                                end
                                
                                print("✓ Returned to field")
                            end
                        end
                    end
                end
            end
        else
            print("ERROR: Failed to respawn after glue collection")
        end
        
        print("✓ Glue collection complete!")
    end
    
    -- Restore token collection and resume auto farm
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:Render()
    self:Clear()
    
    self:CreateRect(0, 0, self.panel.width, self.panel.height, Color3.fromRGB(17, 20, 27))
    
    self:RenderTitleBar()
    self:RenderSidebar()
    
    if self.activeTab == 1 then
        self:RenderMainTab()
    elseif self.activeTab == 2 then
        self:RenderFarmingTab()
    elseif self.activeTab == 3 then
        self:RenderCombatTab()
    elseif self.activeTab == 4 then
        self:RenderSettingsTab()
    end
    
    self.needsRedraw = false
end


-- INPUT -----------------------------------------------------------------------------------------------------------------


function UI:HandleInput()
    local mouse = game.Players.LocalPlayer:GetMouse()
    local mX, mY = mouse.X, mouse.Y
    local pressed = ismouse1pressed()
    if pressed and not self.lastMousePressed then
        local relX, relY = mX - self.panel.x, mY - self.panel.y
        
        -- Check if clicking inside ANY dropdown menu area FIRST
        local clickingInsideDropdownArea = false
        
        -- Check field selection dropdown area
        if self.dropdownOpen then
            local dropdown1X = self.panel.sidebarWidth + 30 + 220
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            local options = GetFlowerZones()
            
            if relX >= dropdown1X and relX <= dropdown1X + 150 and
               relY >= menuY and relY <= menuY + (#options * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- Check sprinkler dropdown area
        if self.secondDropdownOpen then
            local dropdown2X = self.panel.sidebarWidth + 30 + 220 + 170
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            
            if relX >= dropdown2X and relX <= dropdown2X + 150 and
               relY >= menuY and relY <= menuY + (6 * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- Check combat dropdown area
        if self.combatDropdownOpen then
            local dropdownX = self.panel.sidebarWidth + 30 + 220
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            
            if relX >= dropdownX and relX <= dropdownX + 150 and
               relY >= menuY and relY <= menuY + (9 * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- If clicking inside dropdown area, ONLY check dropdown buttons
        for _, btn in ipairs(self.buttons) do
            if relX >= btn.x and relX <= btn.x + btn.width and
               relY >= btn.y and relY <= btn.y + btn.height then
                
                -- If inside dropdown area, only allow dropdown button clicks
                if clickingInsideDropdownArea then
                    -- Check if this button is actually part of a dropdown menu
                    local isDropdownButton = false
                    
                    -- Check if button is in dropdown Y range
                    if self.dropdownOpen or self.secondDropdownOpen or self.combatDropdownOpen then
                        local dropdownY = 80 + 40
                        local menuY = dropdownY + 28
                        
                        if btn.y >= menuY and btn.height == 24 then
                            isDropdownButton = true
                        end
                    end
                    
                    -- Only execute callback if it's actually a dropdown button
                    if isDropdownButton and btn.callback then
                        btn.callback()
                        self.lastMousePressed = pressed
                        return
                    end
                else
                    -- Not in dropdown area, allow all button clicks
                    if btn.callback then
                        btn.callback()
                    end
                    self.lastMousePressed = pressed
                    return
                end
            end
        end
        
        if relX >= 0 and relX <= self.panel.width and relY >= 0 and relY <= 50 then
            self.dragging = {x = relX, y = relY}
        end
    end
    if pressed then
        if self.dragging then
            self.panel.x = mX - self.dragging.x
            self.panel.y = mY - self.dragging.y
            for _, d in pairs(self.drawings) do
                if d.isLine then
                    d.instance.From = Vector2.new(self.panel.x + d.relX, self.panel.y + d.relY)
                    d.instance.To = Vector2.new(self.panel.x + d.relX2, self.panel.y + d.relY2)
                else
                    d.instance.Position = Vector2.new(self.panel.x + d.relX, self.panel.y + d.relY)
                end
            end
        end
        
        if self.draggingSlider then
            self:HandleSliderDrag(mX, mY)
        end
    else
        self.dragging = nil
        self.draggingSlider = false
    end
    
    self.lastMousePressed = pressed
end

function UI:HandleSliderDrag(mX, mY)
    local sliderX = self.panel.x + self.panel.sidebarWidth + 30 + 220
    local sliderY = self.panel.y + 80 + 40 + 8
    local sliderWidth = 150
    
    -- Calculate position relative to slider
    local relX = mX - sliderX
    relX = math.max(0, math.min(relX, sliderWidth))
    
    -- Map to speed range (20-120)
    local normalizedValue = relX / sliderWidth
    self.tweenSpeed = 20 + (normalizedValue * 100)
    self.tweenSpeed = math.floor(self.tweenSpeed)
    
    self.needsRedraw = true
end

function UI:FindBubbleLocation()
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if particles then
        for _, child in pairs(particles:GetChildren()) do
        end
    end
    for _, descendant in pairs(game.Workspace:GetDescendants()) do
        if string.find(string.lower(descendant.Name), "bubble") then
        end
    end
end

function UI:CheckKingBeetle()
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then return false end
    
    local kingBeetle = monsters:FindFirstChild("King Beetle (Lvl 7)")
    return kingBeetle ~= nil
end

function UI:KillKingBeetle()
    print("=== KING BEETLE AUTO-FARM ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for King Beetle")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for King Beetle")
        return false
    end
    
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Checking King Beetle"
    self.needsRedraw = true
    
    local checkPos = Vector3.new(218, 4, 140)
    
    print("Tweening to King Beetle check location...")
    self:QueueTween(hrp, checkPos, true)
    
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: King Beetle check tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at check location, checking for King Beetle...")
    wait(1)
    
    if not self:CheckKingBeetle() then
        print("King Beetle not spawned, returning to farming")
        
        if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
            print("Returning to " .. self.selectedOption)
            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then
                                    print("ERROR: Return to field timeout!")
                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            
                            print("Returned to field")
                        end
                    end
                end
            end
        end
        
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return false
    end
    
    print("King Beetle spawned! Starting fight sequence...")
    self.status = "Fighting King Beetle"
    self.needsRedraw = true
    
    local waypoint1 = Vector3.new(108, 4, 169)
    print("Walking to waypoint 1...")
    self:QueueTween(hrp, waypoint1, true)
    
    startWait = os.clock()
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > 60 then
            print("ERROR: Waypoint 1 timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    wait(0.5)
    
    local waypoint2 = Vector3.new(109, 4, 253)
    print("Walking to waypoint 2...")
    self:QueueTween(hrp, waypoint2, true)
    
    startWait = os.clock()
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > 60 then
            print("ERROR: Waypoint 2 timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Waiting at waypoint 2, checking for King Beetle...")
    wait(1)
    
    local checkStartTime = os.clock()
    while self.autoFarmEnabled and self:CheckKingBeetle() do
        if os.clock() - checkStartTime > 300 then
            print("King Beetle timeout (5 minutes)")
            break
        end
        wait(0.5)
    end
    
    if self.autoFarmEnabled then
        print("King Beetle defeated!")
        
        local collectPos = Vector3.new(182, 4, 180)
        print("Walking to collection point...")
        self:QueueTween(hrp, collectPos, true)
        
        startWait = os.clock()
        while self.processingTween and self.autoFarmEnabled do
            if os.clock() - startWait > 60 then
                print("ERROR: Collection point timeout!")
                self:ClearTweenQueue()
                break
            end
            wait(0.1)
        end
        
        wait(0.5)
        
        print("Collecting tokens for 15 seconds...")
        self.status = "Collecting King Beetle Tokens"
        self.needsRedraw = true
        
        local collectStartTime = os.clock()
        local recentTokens = {}
        
        while self.autoFarmEnabled and (os.clock() - collectStartTime) < 15 do
            local collectibles = game.Workspace:FindFirstChild("Collectibles")
            if collectibles then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local hrpPos = hrp.Position
                        local closestToken = nil
                        local closestDistance = math.huge
                        
                        for _, token in pairs(collectibles:GetChildren()) do
                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                local tokenPos = token.Position
                                if tokenPos then
                                    local isRecent = false
                                    for _, recentPos in ipairs(recentTokens) do
                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                            isRecent = true
                                            break
                                        end
                                    end
                                    
                                    if not isRecent then
                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                        if tdy <= 10 then
                                            local tdx = hrpPos.X - tokenPos.X
                                            local tdz = hrpPos.Z - tokenPos.Z
                                            local distSquared = tdx * tdx + tdz * tdz
                                            
                                            if distSquared < 2500 and distSquared < closestDistance then
                                                closestDistance = distSquared
                                                closestToken = tokenPos
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        if closestToken then
                            WalkTo(closestToken)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                
                                hrp = character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    local currentPos = hrp.Position
                                    local cdx = currentPos.X - closestToken.X
                                    local cdz = currentPos.Z - closestToken.Z
                                    local distSquared = cdx * cdx + cdz * cdz
                                    
                                    if distSquared < 25 then
                                        StopWalking()
                                        break
                                    end
                                end
                                
                                wait(0.05)
                            end
                            
                            StopWalking()
                            
                            table.insert(recentTokens, closestToken)
                            if #recentTokens > 10 then
                                table.remove(recentTokens, 1)
                            end
                        else
                            if #recentTokens > 0 then
                                recentTokens = {}
                            end
                        end
                    end
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()
        print("Token collection complete!")
        print("Next King Beetle in 24 hours")
    end
    
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then
        print("Returning to " .. self.selectedOption)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("Returned to field")
                    end
                end
            end
        end
    end
    
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:FightCommandoChick()
    print("=== FIGHTING COMMANDO CHICK ===")
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then
        print("ERROR: No character for Commando Chick")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        print("ERROR: No HRP for Commando Chick")
        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local previousField = self.selectedOption
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Going to Commando Chick"
    self.needsRedraw = true
    
    -- Tween to Commando Chick spawn location
    local commandoPos = Vector3.new(476, 46, 203)
    
    print("Tweening to Commando Chick spawn area...")
    self:QueueTween(hrp, commandoPos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then
            print("ERROR: Commando Chick tween timeout!")
            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    print("Arrived at Commando Chick area, waiting 3 seconds for spawn...")
    wait(3)
    
    -- Check if Commando Chick spawned
    if not self:CheckForCommandoChick() then
        print("Commando Chick did not spawn, returning to farming")
        
        -- Return to field
        if self.autoFarmEnabled and previousField and previousField ~= "Select Field..." then
            print("Returning to " .. previousField)
            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(previousField)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then
                                    print("ERROR: Return to field timeout!")
                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            
                            print("✓ Returned to field")
                        end
                    end
                end
            end
        end
        
        -- Restore state
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return false
    end
    
    print("=== COMMANDO CHICK SPAWNED! ===")
    self.status = "Fighting Commando Chick"
    self.needsRedraw = true
    
    -- Farm tokens while Commando Chick is alive
    while self.autoFarmEnabled and self.killCommandoChick and self:CheckForCommandoChick() do
        local collectibles = game.Workspace:FindFirstChild("Collectibles")
        if collectibles then
            character = player.Character
            if character then
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local hrpPos = hrp.Position
                    local closestToken = nil
                    local closestDistance = math.huge
                    
                    for _, token in pairs(collectibles:GetChildren()) do
                        if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                            local tokenPos = token.Position
                            if tokenPos then
                                local dy = math.abs(hrpPos.Y - tokenPos.Y)
                                if dy <= 15 then
                                    local dx = hrpPos.X - tokenPos.X
                                    local dz = hrpPos.Z - tokenPos.Z
                                    local distSquared = dx * dx + dz * dz
                                    
                                    if distSquared < 2500 and distSquared < closestDistance then
                                        closestDistance = distSquared
                                        closestToken = tokenPos
                                    end
                                end
                            end
                        end
                    end
                    
                    if closestToken then
                        WalkTo(closestToken)
                        
                        local startTime = os.clock()
                        while IsWalking() and self.autoFarmEnabled do
                            if os.clock() - startTime > 3 then
                                StopWalking()
                                break
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local currentPos = hrp.Position
                                local cdx = currentPos.X - closestToken.X
                                local cdz = currentPos.Z - closestToken.Z
                                local distSquared = cdx * cdx + cdz * cdz
                                
                                if distSquared < 25 then
                                    StopWalking()
                                    break
                                end
                            end
                            
                            wait(0.05)
                        end
                        
                        StopWalking()
                    end
                end
            end
        end
        
        wait(0.5)
    end
    
    print("✓ Commando Chick defeated!")
    print("Next Commando Chick in 30 minutes")
    
    -- Return to field
    if self.autoFarmEnabled and previousField and previousField ~= "Select Field..." then
        print("Returning to " .. previousField)
        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(previousField)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 5, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then
                                print("ERROR: Return to field timeout!")
                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        
                        print("✓ Returned to field")
                    end
                end
            end
        end
    end
    
    -- Restore state
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:Shutdown()
    
    self.isRunning = false
    if self.statusUpdaterThread then
        task.cancel(self.statusUpdaterThread)
        self.statusUpdaterThread = nil
    end
    if self.autoFarmThread then
        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
    end
    if self.autoDigThread then
        task.cancel(self.autoDigThread)
        self.autoDigThread = nil
    end
    if self.coconutCrabThread then
        task.cancel(self.coconutCrabThread)
        self.coconutCrabThread = nil
    end
    if self.tweenQueueThread then
        task.cancel(self.tweenQueueThread)
        self.tweenQueueThread = nil
    end
    
    self:Clear()
end

-- ============================================================
-- MAIN LOOP
-- ============================================================

print("v1.1.0")
UI:Render()
UI:StartStatusUpdater()
spawn(function()
    while UI.isRunning do
        UI:HandleInput()
        if UI.needsRedraw then
            UI:Render()
        end
        wait(0.03)
    end
    UI:Clear()
    print("Complete")
end)
